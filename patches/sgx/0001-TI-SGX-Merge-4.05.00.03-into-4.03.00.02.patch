From 516f37e5c819ae22019fd8c8ed9b5a8563522afa Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Mon, 16 Jan 2012 12:54:01 -0600
Subject: [PATCH] TI SGX Merge 4.05.00.03 into 4.03.00.02

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 drivers/staging/Makefile                           |    2 +-
 drivers/staging/omap3-sgx/Kbuild                   |  126 ++-
 drivers/staging/omap3-sgx/Kconfig                  |   39 +-
 drivers/staging/omap3-sgx/Makefile                 |   87 ++-
 .../eurasiacon/build/linux/makefile.shared_conf    |   30 +-
 drivers/staging/omap3-sgx/include4/pvrversion.h    |    4 +-
 drivers/staging/omap3-sgx/include4/servicesext.h   |   10 +
 .../services4/3rdparty/bufferclass_ti/bc_cat.c     |   16 +-
 .../services4/3rdparty/bufferclass_ti/bc_cat.h     |    1 +
 .../dc_omapfb3_linux/3rdparty_dc_drm_shared.h      |   45 +
 .../services4/3rdparty/dc_omapfb3_linux/Kbuild     |   29 +
 .../3rdparty/dc_omapfb3_linux/kbuild/Makefile      |   36 +
 .../services4/3rdparty/dc_omapfb3_linux/omaplfb.h  |  269 ++++
 .../dc_omapfb3_linux/omaplfb_displayclass.c        | 1238 ++++++++++++++++++
 .../3rdparty/dc_omapfb3_linux/omaplfb_linux.c      |  781 ++++++++++++
 .../dc_ti335x_linux/3rdparty_dc_drm_shared.h       |   45 +
 .../services4/3rdparty/dc_ti335x_linux/Kbuild      |   32 +
 .../3rdparty/dc_ti335x_linux/kbuild/Makefile       |   36 +
 .../services4/3rdparty/dc_ti335x_linux/omaplfb.h   |  271 ++++
 .../dc_ti335x_linux/omaplfb_displayclass.c         | 1259 +++++++++++++++++++
 .../3rdparty/dc_ti335x_linux/omaplfb_linux.c       |  836 +++++++++++++
 .../dc_ti81xx_linux/3rdparty_dc_drm_shared.h       |   45 +
 .../services4/3rdparty/dc_ti81xx_linux/Kbuild      |   23 +-
 .../3rdparty/dc_ti81xx_linux/kbuild/Makefile       |   13 +-
 .../services4/3rdparty/dc_ti81xx_linux/omaplfb.h   |  259 ++--
 .../dc_ti81xx_linux/omaplfb_displayclass.c         | 1323 ++++++++------------
 .../3rdparty/dc_ti81xx_linux/omaplfb_linux.c       |  873 +++++++++----
 .../staging/omap3-sgx/services4/include/sgxinfo.h  |   15 +
 .../services4/srvkm/bridged/bridged_pvr_bridge.c   |    2 +-
 .../srvkm/bridged/sgx/bridged_sgx_bridge.c         |  190 +++
 .../omap3-sgx/services4/srvkm/common/metrics.c     |    3 +
 .../omap3-sgx/services4/srvkm/common/pvrsrv.c      |   30 +-
 .../omap3-sgx/services4/srvkm/common/queue.c       |    4 +-
 .../omap3-sgx/services4/srvkm/common/resman.c      |    4 +-
 .../services4/srvkm/devices/sgx/sgxconfig.h        |   11 +-
 .../services4/srvkm/devices/sgx/sgxinit.c          |   58 +-
 .../services4/srvkm/devices/sgx/sgxkick.c          |    2 +-
 .../services4/srvkm/devices/sgx/sgxpower.c         |   10 +-
 .../services4/srvkm/devices/sgx/sgxreset.c         |    3 +-
 .../services4/srvkm/devices/sgx/sgxtransfer.c      |    4 +-
 .../services4/srvkm/devices/sgx/sgxutils.c         |   64 +-
 .../services4/srvkm/devices/sgx/sgxutils.h         |    6 +-
 .../omap3-sgx/services4/srvkm/env/linux/event.c    |    4 +-
 .../omap3-sgx/services4/srvkm/env/linux/mm.c       |    4 +-
 .../omap3-sgx/services4/srvkm/env/linux/mm.h       |    6 +-
 .../omap3-sgx/services4/srvkm/env/linux/mmap.c     |    5 +-
 .../omap3-sgx/services4/srvkm/env/linux/module.c   |    6 +-
 .../omap3-sgx/services4/srvkm/env/linux/mutils.c   |    4 +-
 .../omap3-sgx/services4/srvkm/env/linux/mutils.h   |    8 +-
 .../omap3-sgx/services4/srvkm/env/linux/osfunc.c   |  201 ++--
 .../omap3-sgx/services4/srvkm/env/linux/proc.c     |    5 +-
 .../services4/srvkm/env/linux/pvr_bridge_k.c       |    1 -
 .../services4/srvkm/env/linux/pvr_debug.c          |    6 +-
 .../omap3-sgx/services4/srvkm/env/linux/pvr_drm.c  |  105 ++-
 .../services4/srvkm/env/linux/pvr_uaccess.h        |    5 +-
 .../omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h   |    1 +
 .../omap3-sgx/services4/srvkm/include/device.h     |   11 +-
 .../omap3-sgx/services4/srvkm/include/osfunc.h     |    1 +
 .../omap3-sgx/services4/system/omap4/sysinfo.h     |    3 +-
 .../services4/system/omap4/sysutils_linux.c        |   36 +-
 .../omap3-sgx/services4/system/ti335x/oemfuncs.h   |   56 +
 .../omap3-sgx/services4/system/ti335x/sysconfig.c  |  974 ++++++++++++++
 .../omap3-sgx/services4/system/ti335x/sysconfig.h  |   54 +
 .../omap3-sgx/services4/system/ti335x/sysinfo.h    |   40 +
 .../omap3-sgx/services4/system/ti335x/syslocal.h   |  135 ++
 .../omap3-sgx/services4/system/ti335x/sysutils.c   |   34 +
 .../services4/system/ti335x/sysutils_linux.c       |  774 ++++++++++++
 .../system/ti335x/sysutils_linux_wqueue_compat.c   |  505 ++++++++
 .../system/ti81xx/sysutils_linux_wqueue_compat.c   |    7 +-
 .../ti81xx/sysutils_linux_wqueue_compat_orig.c     |  472 -------
 .../tools/intern/debug/dbgdriv/linux/hostfunc.c    |    3 +-
 .../tools/intern/debug/dbgdriv/linux/main.c        |    9 +-
 72 files changed, 9656 insertions(+), 1953 deletions(-)
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/3rdparty_dc_drm_shared.h
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/Kbuild
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/kbuild/Makefile
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb.h
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_displayclass.c
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_linux.c
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/3rdparty_dc_drm_shared.h
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/Kbuild
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/kbuild/Makefile
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/omaplfb.h
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/omaplfb_displayclass.c
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/omaplfb_linux.c
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/3rdparty_dc_drm_shared.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti335x/oemfuncs.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti335x/sysconfig.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti335x/sysconfig.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti335x/sysinfo.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti335x/syslocal.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti335x/sysutils.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti335x/sysutils_linux.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti335x/sysutils_linux_wqueue_compat.c
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux_wqueue_compat_orig.c

diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index 62cdeb9..6a7fc6f 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -42,7 +42,7 @@ obj-$(CONFIG_WLAGS49_H2)	+= wlags49_h2/
 obj-$(CONFIG_WLAGS49_H25)	+= wlags49_h25/
 obj-$(CONFIG_FB_SM7XX)		+= sm7xx/
 obj-$(CONFIG_CRYSTALHD)		+= crystalhd/
-obj-$(CONFIG_OMAP3_SGX) 	+= omap3-sgx/
+obj-$(CONFIG_TI_SGX)	+= omap3-sgx/
 obj-$(CONFIG_CXT1E1)		+= cxt1e1/
 obj-$(CONFIG_FB_XGI)		+= xgifb/
 obj-$(CONFIG_TIDSPBRIDGE)	+= tidspbridge/
diff --git a/drivers/staging/omap3-sgx/Kbuild b/drivers/staging/omap3-sgx/Kbuild
index aa483db..fc7a199 100644
--- a/drivers/staging/omap3-sgx/Kbuild
+++ b/drivers/staging/omap3-sgx/Kbuild
@@ -5,6 +5,7 @@
 export KERNEL_PATH=$(KERNELDIR)
 export KERNEL_SRC=$(KERNELDIR)
 export KDIR=$(KERNELDIR)
+
 BUILD = release
 
 TI_PLATFORM = omap3
@@ -29,8 +30,18 @@ SYS_CFLAGS += -DPVR_HAS_BROKEN_OMAPFB_H
 endif
 OPTIM                   = -Os
 
-
+ifeq ($(TI_PLATFORM),omap4)
+SGXCORE = 540
+else
 SGXCORE = 530
+endif
+
+ifeq ($(TI_PLATFORM),ti335x)
+CORE = -DSGX530 -DSUPPORT_SGX530 -DSGX_CORE_REV=125
+else
+ifeq ($(TI_PLATFORM),omap4)
+CORE = -DSGX540 -DSUPPORT_SGX540 -DSGX_CORE_REV=120
+else
 ifeq ($(TI_PLATFORM),ti81xx)
 CORE = -DPLAT_TI81xx -DSGX530 -DSUPPORT_SGX530 -DSGX_CORE_REV=125
 else
@@ -46,6 +57,8 @@ endif
 endif
 endif
 endif
+endif
+endif
 
 SUPPORT_SGX = 1
 SUPPORT_HW_RECOVERY = 1
@@ -56,6 +69,31 @@ SUPPORT_TI_PM = 0
 PVR2D_ALT_2DHW = 1
 
 LDM_PLATFORM ?= 1
+SUPPORT_XORG ?=0
+SUPPORT_DRI_DRM_NOT_PCI ?= 0
+
+ifeq ($(SUPPORT_XORG),1)
+SUPPORT_DRI_DRM = 1
+SUPPORT_DRI_DRM_NOT_PCI = 1
+endif
+
+
+ifeq ($(SUPPORT_DRI_DRM_NOT_PCI),1)
+KBUILD_EXTRA_SYMBOLS = `pwd`/services4/3rdparty/linux_drm/kbuild/Module.symvers
+endif
+
+SUPPORT_DRI_DRM ?= $(SUPPORT_XORG)
+SUPPORT_DRI_DRM_EXT ?= 0
+SUPPORT_DRI_DRM_NO_DROPMASTER ?= 0
+#SUPPORT_SECURE_DRM_AUTH_EXPORT ?= $(SUPPORT_XORG)
+
+SUPPORT_DRI_DRM_NO_LIBDRM ?= 0
+ifneq ($(SUPPORT_XORG),1)
+ifeq ($(SUPPORT_DRI_DRM),1)
+SUPPORT_DRI_DRM_NO_LIBDRM = 1
+endif
+endif
+
 
 # Only enable active power management if passive power management is
 # enabled, as indicated by LDM_PLATFORM being set to 1.  On OMAP,
@@ -64,20 +102,38 @@ LDM_PLATFORM ?= 1
 # passive power management isn't enabled, the driver won't see the
 # system suspend/resume events, and so won't take appropriate action.
 ifeq ($(LDM_PLATFORM),1)
+ifeq ($(TI_PLATFORM),ti335x)
+SUPPORT_ACTIVE_POWER_MANAGEMENT ?= 0
+else
 ifeq ($(TI_PLATFORM),ti81xx)
 SUPPORT_ACTIVE_POWER_MANAGEMENT ?= 0
 else
 SUPPORT_ACTIVE_POWER_MANAGEMENT = 1
 endif
+endif
 else
 SUPPORT_ACTIVE_POWER_MANAGEMENT = 0
 endif
 
+#if 0
+ifeq ($(LDM_PLATFORM),1)
+DISPLAY_CONTROLLER                      = omaplfb
+OMAP_NON_FLIP_DISPLAY                   = 0
+else
+DISPLAY_CONTROLLER                      = pvrlfb
+DISPLAY_CONTROLLER_DIR                  = 3rdparty/linux_framebuffer
+OMAP_NON_FLIP_DISPLAY                   = 1
+endif
+#endif
+
+
 
 PVRSRV_MODNAME ?= pvrsrvkm
 
 SYS_CFLAGS += -DPVRSRV_MODNAME="\"$(PVRSRV_MODNAME)"\"
 
+#ARCH_CFLAGS             += -ftree-vectorize -mfpu=neon -mfloat-abi=hard
+ARCH_CFLAGS     += -Wno-sign-conversion
 
 
 export PVR_BUILD_DIR := $(shell pwd)
@@ -146,7 +202,6 @@ PVRSRV_LOG_MEMORY_ALLOCS ?= 0
 PVRSRV_DEBUG_OS_MEMORY ?= 0
 endif
 
-SUPPORT_XORG ?= 0
 ifneq ($(SUPPORT_XORG),1)
 SUPPORT_XWS        ?= 1
 XWS_SERVER_ONLY    ?= 0
@@ -167,13 +222,11 @@ else
 SUPPORT_SECURE_FD_EXPORT        ?= 0
 endif
 
-
-
+SUPPORT_DRI_DRM_NO_LIBDRM ?= 0
 
 TRANSFER_QUEUE				?= 1
 SUPPORT_SGX_EVENT_OBJECT		?= 1
 SUPPORT_SECURE_HANDLES			= 1
-SUPPORT_SECURE_FD_EXPORT        	= 1
 SUPPORT_SRVINIT				= 1
 SUPPORT_PERCONTEXT_PB			= 1
 DISABLE_SGX_PB_GROW_SHRINK             ?= 1
@@ -181,6 +234,11 @@ SUPPORT_LINUX_X86_PAT 			?=1
 SUPPORT_LINUX_X86_WRITECOMBINE 		?=1
 SUPPORT_SGX_LOW_LATENCY_SCHEDULING 	?=1
 
+ifeq ($(SUPPORT_XORG),1)
+SUPPORT_PDUMP_MULTI_PROCESS = 1
+endif
+
+
 SUPPORT_OMAP3430_SGXFCLK_96M ?= 0
 SUPPORT_OMAP3430_OMAPFB3 ?= 0
 
@@ -275,11 +333,17 @@ SYS_CFLAGS.$(PVRSRV_RESET_ON_HWTIMEOUT)                 += -DPVRSRV_RESET_ON_HWT
 SYS_CFLAGS.$(PVRSRV_CLIENT_RESET_ON_HWTIMEOUT)  += -DPVRSRV_CLIENT_RESET_ON_HWTIMEOUT
 SYS_CFLAGS.$(NO_HARDWARE)                                               += -DNO_HARDWARE
 
+SYS_CFLAGS.$(SUPPORT_DRI_DRM)                                   += -DSUPPORT_DRI_DRM
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_EXT)                               += -DSUPPORT_DRI_DRM_EXT
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_NOT_PCI)                           += -DPVR_DRI_DRM_NOT_PCI
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_NO_DROPMASTER)             += -DSUPPORT_DRI_DRM_NO_DROPMASTER
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_NO_LIBDRM)                         += -DSUPPORT_DRI_DRM_NO_LIBDRM
+SYS_CFLAGS.$(DRM_PVR_RESERVED_INTEL_ORDER)              += -DDRM_PVR_RESERVED_INTEL_ORDER
+SYS_CFLAGS.$(DRM_PVR_USE_INTEL_FB)                              += -DDRM_PVR_USE_INTEL_FB
+
 
 
 
-SYS_CFLAGS.$(SUPPORT_DRI_DRM)				+= -DSUPPORT_DRI_DRM
-SYS_CFLAGS.$(SUPPORT_DRI_DRM_EXT)                               += -DSUPPORT_DRI_DRM_EXT
 SYS_CFLAGS.$(SUPPORT_LIBDRM_LITE)                               += -DSUPPORT_LIBDRM_LITE
 
 ifneq ("$(NO_HARDWARE)", "1")
@@ -352,8 +416,9 @@ SYS_CFLAGS.$(SUPPORT_PVR_PDP_LINUX_FB) += -DPVR_PDP_LINUX_FB
 SYS_CFLAGS.$(SUPPORT_LINUX_USING_WORKQUEUES) += -DPVR_LINUX_USING_WORKQUEUES \
                                 -DPVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE \
                                 -DPVR_LINUX_TIMERS_USING_WORKQUEUES \
-                                -DSYS_CUSTOM_POWERLOCK_WRAP
-
+                                -DSYS_CUSTOM_POWERLOCK_WRAP \
+				-DPVR_NO_FULL_CACHE_OPS \
+				-DSGX_CLK_CORE_DIV5
 
 
 SYS_CFLAGS.$(SUPPORT_SGX_NEW_STATUS_VALS)       += -DSUPPORT_SGX_NEW_STATUS_VALS
@@ -429,6 +494,21 @@ services4/srvkm/bridged/sgx/bridged_sgx_bridge.c \
 services4/system/$(TI_PLATFORM)/sysutils.c \
 services4/system/$(TI_PLATFORM)/sysconfig.c \
 
+ifneq ($(FBDEV),no)
+EXTRA_CFLAGS += -DFBDEV_PRESENT
+endif
+
+
+ifeq ($(TI_PLATFORM),ti335x)
+DRIFILES = services4/srvkm/env/linux/pvr_drm.c services4/3rdparty/dc_ti335x_linux/omaplfb_linux.c services4/3rdparty/dc_ti335x_linux/omaplfb_displayclass.c 
+else
+ifeq ($(TI_PLATFORM),ti81xx)
+DRIFILES = services4/srvkm/env/linux/pvr_drm.c services4/3rdparty/dc_ti81xx_linux/omaplfb_linux.c services4/3rdparty/dc_ti81xx_linux/omaplfb_displayclass.c 
+else
+DRIFILES = services4/srvkm/env/linux/pvr_drm.c services4/3rdparty/dc_omapfb3_linux/omaplfb_linux.c services4/3rdparty/dc_omapfb3_linux/omaplfb_displayclass.c
+endif
+endif
+
 EXTRA_CFLAGS += -I$(src)/include4
 EXTRA_CFLAGS += -I$(src)/services4/include
 EXTRA_CFLAGS += -I$(src)/services4/srvkm/include
@@ -440,14 +520,40 @@ EXTRA_CFLAGS += -I$(src)/services4/system/include
 EXTRA_CFLAGS += -I$(src)/services4/system/$(TI_PLATFORM)
 EXTRA_CFLAGS += -I$(src)/services4/srvkm/bridged/sgx
 
+
+ifeq ($(SUPPORT_XORG),1)
+EXTRA_CFLAGS += -I$(KERNELDIR)/include/drm 
+EXTRA_CFLAGS += -I$(src)/services4/3rdparty/linux_drm
+EXTRA_CFLAGS += -I$(src)/services4/include/env/linux
+EXTRA_CFLAGS += -I$(KERNELDIR)/drivers/video/omap2
+EXTRA_CFLAGS += -I$(KERNELDIR)/arch/arm/plat-omap/include
+ifeq ($(TI_PLATFORM),omap4)
+EXTRA_CFLAGS += -DCONFIG_SLOW_WORK 
+endif
+endif
+
 EXTRA_CFLAGS += $(ALL_CFLAGS)
 
 pvrsrvkm-y	:= $(FILES:.c=.o)
 
+ifeq ($(SUPPORT_XORG),1)
+pvrsrvkm-y +=  $(DRIFILES:.c=.o)
+endif
+
+ifneq ($(SUPPORT_XORG),1)
+ifeq ($(TI_PLATFORM),ti335x)
+obj-y := services4/3rdparty/dc_ti335x_linux/
+else
 ifeq ($(TI_PLATFORM),ti81xx)
 obj-y := services4/3rdparty/dc_ti81xx_linux/
 else
-obj-y := services4/3rdparty/dc_omap3430_linux/
+obj-y := services4/3rdparty/dc_omapfb3_linux/
+endif
+endif
 endif
 obj-y += services4/3rdparty/bufferclass_ti/
+#obj-y += services4/3rdparty/bufferclass_example/
 
+ifeq ($(SUPPORT_XORG),1)
+obj-y += services4/3rdparty/linux_drm/
+endif
diff --git a/drivers/staging/omap3-sgx/Kconfig b/drivers/staging/omap3-sgx/Kconfig
index 7e3bdb6..2b98a88 100644
--- a/drivers/staging/omap3-sgx/Kconfig
+++ b/drivers/staging/omap3-sgx/Kconfig
@@ -2,8 +2,39 @@
 # SGX Driver Support
 #
 
-config OMAP3_SGX
-	bool "OMAP3 SGX support (TI: 4.03.00.02)"
-	depends on OMAP2_DSS && m
+menuconfig TI_SGX
+	tristate "TI SGX support (TI: 4.05.00.03)"
+	depends on DRM && OMAP2_DSS && m
 	help
-	  This is TI's OMAP3 SGX Kernel Modules 4.03.00.02
+	  This is TI's OMAP3 SGX Kernel Modules 4.05.00.03
+
+config TI_SGX_ES3
+	bool "TI es3.x OMAP35x support (Experimental)"
+	depends on TI_SGX && BROKEN
+	help
+	  Say yes to include support for es3.x (OMAP35x)
+
+config TI_SGX_ES5
+	bool "TI es5.x DM37x/AM37x support (Experimental)"
+	depends on TI_SGX
+	  help
+	  Say yes to include support for es5.x (DM37x/AM37x)
+
+config TI_SGX_ES6
+	bool "TI es6.x 816x(389x)/814x(387x) support (Experimental)"
+	depends on TI_SGX && BROKEN
+	  help
+	  Say yes to include support for es6.x (816x(389x)/814x(387x))
+
+config TI_SGX_ES7
+	bool "TI es7.x OMAP4 support (Experimental)"
+	depends on TI_SGX && BROKEN
+	  help
+	  Say yes to include support for es7.x (OMAP4)
+
+config TI_SGX_ES8
+	bool "TI es8.x AM335x support (Experimental)"
+	depends on TI_SGX && BROKEN
+	  help
+	  Say yes to include support for es8.x (AM335x)
+
diff --git a/drivers/staging/omap3-sgx/Makefile b/drivers/staging/omap3-sgx/Makefile
index 7fe1828..b8e2299 100644
--- a/drivers/staging/omap3-sgx/Makefile
+++ b/drivers/staging/omap3-sgx/Makefile
@@ -26,8 +26,18 @@ SYS_CFLAGS += -DPVR_HAS_BROKEN_OMAPFB_H
 endif
 OPTIM                   = -Os
 
-
+ifeq ($(TI_PLATFORM),omap4)
+SGXCORE = 540
+else
 SGXCORE = 530
+endif
+
+ifeq ($(TI_PLATFORM),ti335x)
+CORE = -DSGX530 -DSUPPORT_SGX530 -DSGX_CORE_REV=125
+else
+ifeq ($(TI_PLATFORM),omap4)
+CORE = -DSGX540 -DSUPPORT_SGX540 -DSGX_CORE_REV=120
+else
 ifeq ($(TI_PLATFORM),ti81xx)
 CORE = -DPLAT_TI81xx -DSGX530 -DSUPPORT_SGX530 -DSGX_CORE_REV=125
 else
@@ -43,6 +53,8 @@ endif
 endif
 endif
 endif
+endif
+endif
 
 SUPPORT_SGX = 1
 SUPPORT_HW_RECOVERY = 1
@@ -53,6 +65,31 @@ SUPPORT_TI_PM = 0
 PVR2D_ALT_2DHW = 1
 
 LDM_PLATFORM ?= 1
+SUPPORT_XORG ?=0
+SUPPORT_DRI_DRM_NOT_PCI ?= 0
+
+ifeq ($(SUPPORT_XORG),1)
+SUPPORT_DRI_DRM = 1
+SUPPORT_DRI_DRM_NOT_PCI = 1
+endif
+
+
+ifeq ($(SUPPORT_DRI_DRM_NOT_PCI),1)
+KBUILD_EXTRA_SYMBOLS = `pwd`/services4/3rdparty/linux_drm/kbuild/Module.symvers
+endif
+
+SUPPORT_DRI_DRM ?= $(SUPPORT_XORG)
+SUPPORT_DRI_DRM_EXT ?= 0
+SUPPORT_DRI_DRM_NO_DROPMASTER ?= 0
+#SUPPORT_SECURE_DRM_AUTH_EXPORT ?= $(SUPPORT_XORG)
+
+SUPPORT_DRI_DRM_NO_LIBDRM ?= 0
+ifneq ($(SUPPORT_XORG),1)
+ifeq ($(SUPPORT_DRI_DRM),1)
+SUPPORT_DRI_DRM_NO_LIBDRM = 1
+endif
+endif
+
 
 # Only enable active power management if passive power management is
 # enabled, as indicated by LDM_PLATFORM being set to 1.  On OMAP,
@@ -61,20 +98,38 @@ LDM_PLATFORM ?= 1
 # passive power management isn't enabled, the driver won't see the
 # system suspend/resume events, and so won't take appropriate action.
 ifeq ($(LDM_PLATFORM),1)
+ifeq ($(TI_PLATFORM),ti335x)
+SUPPORT_ACTIVE_POWER_MANAGEMENT ?= 0
+else
 ifeq ($(TI_PLATFORM),ti81xx)
 SUPPORT_ACTIVE_POWER_MANAGEMENT ?= 0
 else
 SUPPORT_ACTIVE_POWER_MANAGEMENT = 1
 endif
+endif
 else
 SUPPORT_ACTIVE_POWER_MANAGEMENT = 0
 endif
 
+#if 0
+ifeq ($(LDM_PLATFORM),1)
+DISPLAY_CONTROLLER                      = omaplfb
+OMAP_NON_FLIP_DISPLAY                   = 0
+else
+DISPLAY_CONTROLLER                      = pvrlfb
+DISPLAY_CONTROLLER_DIR                  = 3rdparty/linux_framebuffer
+OMAP_NON_FLIP_DISPLAY                   = 1
+endif
+#endif
+
+
 
 PVRSRV_MODNAME ?= pvrsrvkm
 
 SYS_CFLAGS += -DPVRSRV_MODNAME="\"$(PVRSRV_MODNAME)"\"
 
+#ARCH_CFLAGS             += -ftree-vectorize -mfpu=neon -mfloat-abi=hard
+ARCH_CFLAGS     += -Wno-sign-conversion
 
 
 export PVR_BUILD_DIR := $(shell pwd)
@@ -143,7 +198,6 @@ PVRSRV_LOG_MEMORY_ALLOCS ?= 0
 PVRSRV_DEBUG_OS_MEMORY ?= 0
 endif
 
-SUPPORT_XORG ?= 0
 ifneq ($(SUPPORT_XORG),1)
 SUPPORT_XWS        ?= 1
 XWS_SERVER_ONLY    ?= 0
@@ -164,13 +218,11 @@ else
 SUPPORT_SECURE_FD_EXPORT        ?= 0
 endif
 
-
-
+SUPPORT_DRI_DRM_NO_LIBDRM ?= 0
 
 TRANSFER_QUEUE				?= 1
 SUPPORT_SGX_EVENT_OBJECT		?= 1
 SUPPORT_SECURE_HANDLES			= 1
-SUPPORT_SECURE_FD_EXPORT        	= 1
 SUPPORT_SRVINIT				= 1
 SUPPORT_PERCONTEXT_PB			= 1
 DISABLE_SGX_PB_GROW_SHRINK             ?= 1
@@ -178,6 +230,11 @@ SUPPORT_LINUX_X86_PAT 			?=1
 SUPPORT_LINUX_X86_WRITECOMBINE 		?=1
 SUPPORT_SGX_LOW_LATENCY_SCHEDULING 	?=1
 
+ifeq ($(SUPPORT_XORG),1)
+SUPPORT_PDUMP_MULTI_PROCESS = 1
+endif
+
+
 SUPPORT_OMAP3430_SGXFCLK_96M ?= 0
 SUPPORT_OMAP3430_OMAPFB3 ?= 0
 
@@ -272,11 +329,17 @@ SYS_CFLAGS.$(PVRSRV_RESET_ON_HWTIMEOUT)                 += -DPVRSRV_RESET_ON_HWT
 SYS_CFLAGS.$(PVRSRV_CLIENT_RESET_ON_HWTIMEOUT)  += -DPVRSRV_CLIENT_RESET_ON_HWTIMEOUT
 SYS_CFLAGS.$(NO_HARDWARE)                                               += -DNO_HARDWARE
 
+SYS_CFLAGS.$(SUPPORT_DRI_DRM)                                   += -DSUPPORT_DRI_DRM
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_EXT)                               += -DSUPPORT_DRI_DRM_EXT
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_NOT_PCI)                           += -DPVR_DRI_DRM_NOT_PCI
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_NO_DROPMASTER)             += -DSUPPORT_DRI_DRM_NO_DROPMASTER
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_NO_LIBDRM)                         += -DSUPPORT_DRI_DRM_NO_LIBDRM
+SYS_CFLAGS.$(DRM_PVR_RESERVED_INTEL_ORDER)              += -DDRM_PVR_RESERVED_INTEL_ORDER
+SYS_CFLAGS.$(DRM_PVR_USE_INTEL_FB)                              += -DDRM_PVR_USE_INTEL_FB
+
 
 
 
-SYS_CFLAGS.$(SUPPORT_DRI_DRM)				+= -DSUPPORT_DRI_DRM
-SYS_CFLAGS.$(SUPPORT_DRI_DRM_EXT)                               += -DSUPPORT_DRI_DRM_EXT
 SYS_CFLAGS.$(SUPPORT_LIBDRM_LITE)                               += -DSUPPORT_LIBDRM_LITE
 
 ifneq ("$(NO_HARDWARE)", "1")
@@ -349,8 +412,9 @@ SYS_CFLAGS.$(SUPPORT_PVR_PDP_LINUX_FB) += -DPVR_PDP_LINUX_FB
 SYS_CFLAGS.$(SUPPORT_LINUX_USING_WORKQUEUES) += -DPVR_LINUX_USING_WORKQUEUES \
                                 -DPVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE \
                                 -DPVR_LINUX_TIMERS_USING_WORKQUEUES \
-                                -DSYS_CUSTOM_POWERLOCK_WRAP
-
+                                -DSYS_CUSTOM_POWERLOCK_WRAP \
+				-DPVR_NO_FULL_CACHE_OPS \
+				-DSGX_CLK_CORE_DIV5
 
 
 SYS_CFLAGS.$(SUPPORT_SGX_NEW_STATUS_VALS)       += -DSUPPORT_SGX_NEW_STATUS_VALS
@@ -384,7 +448,10 @@ export ALL_CFLAGS =	-DLINUX \
 			$(SYS_CFLAGS) $(SYS_CFLAGS.1) \
 			$(MODULE_CFLAGS) $(MODULE_CFLAGS.$(BUILD)) \
 			$(CORE) -fno-strict-aliasing -Wno-pointer-arith \
-			$(CFLAGS)
+			$(CFLAGS) $(ARCH_CFLAGS)
+ifdef SUPPORT_DRI_DRM_NO_TTM
+export SUPPORT_DRI_DRM_NO_TTM
+endif
 
 all:
 	$(MAKE) -C $(KERNELDIR) M=`pwd` $*
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/makefile.shared_conf b/drivers/staging/omap3-sgx/eurasiacon/build/linux/makefile.shared_conf
index 01bf4a0..04a4faf 100644
--- a/drivers/staging/omap3-sgx/eurasiacon/build/linux/makefile.shared_conf
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/makefile.shared_conf
@@ -148,6 +148,7 @@ PVRVERSION_BUILD	= $(shell echo $(PVRVERSION) | $(CUT) -d '.' -f4,5,6)
 
 # Linux kernel defines
 #
+ifneq ($(NO_KERNEL_MODULES),1)
 KERNEL_VER		= $(shell grep "^VERSION = " \
 	 				$(KERNELDIR)/Makefile | $(CUT) -f3 -d' ')
 KERNEL_REL		= $(shell grep "^PATCHLEVEL = " \
@@ -164,29 +165,19 @@ KERNEL_ID		?= $(shell grep -h '\#define UTS_RELEASE' $(KERNELDIR)/include/linux/
 				$(CUT) -f3 -d' ' | \
 				$(SED) s/\"//g)
 
+KM_SUFFIX		= ko
+
 ifeq ("$(KERNEL_ID)", "")
 # For Linux 2.6.33, the above method of finding the KERNEL ID no longer
 # works, as UTS_RELEASE is no longer defined anywhere.
 KERNEL_ID		:= $(KERNELVERSION)$(KERNEL_EXTRAVER)
 endif
+endif # !NO_KERNEL_MODULES
 
 # Get checksum from env variables
 #
 ENV_CHECKSUM	=	$(shell echo $(ALL_CFLAGS_$(MODSUFFIX)) | $(MD5SUM) - | $(CUT) -d' ' -f 1)
 
-# Linux kernel defines
-#
-ifeq ("$(KERNEL_VER)", "2")
-ifeq ("$(KERNEL_REL)", "6")
-KM_SUFFIX		= ko
-else
-KM_SUFFIX		= o
-CFLAGS_.o	+= -DEXPORT_SYMTAB $(CFLAGS_.ko)
-endif
-else 
-KM_SUFFIX		= o
-endif
-
 # The standard CFLAGS macro can be overridden on the 'make' command line.  We
 # put CBUILD in a separate macro so its setting doesn't get lost when a user
 # *does* override CFLAGS.
@@ -318,7 +309,7 @@ SUPPORT_SGX_EVENT_OBJECT ?=1
 SUPPORT_SECURE_HANDLES		= 1
 SUPPORT_SRVINIT = 1
 SUPPORT_PERCONTEXT_PB = 1
-DISABLE_SGX_PB_GROW_SHRINK ?= 0
+DISABLE_SGX_PB_GROW_SHRINK ?= 1
 SUPPORT_LINUX_X86_PAT ?=1
 SUPPORT_LINUX_X86_WRITECOMBINE ?=1
 SUPPORT_SGX_LOW_LATENCY_SCHEDULING ?=1
@@ -514,8 +505,10 @@ SYS_CFLAGS += -DDEBUG_LOG_PATH_TRUNCATE=\"$(EURASIAROOT)\"
 
 SYS_INCLUDES	=	-I$(EURASIAROOT)/include4 \
 					-I$(EURASIAROOT)/eurasiacon/includeext \
-					-I$(SYSBIN) \
-					-isystem $(KERNELDIR)/include
+					-I$(SYSBIN)
+ifneq ($(NO_KERNEL_MODULES),1)
+SYS_INCLUDES += -isystem $(KERNELDIR)/include
+endif
 
 
 ALL_CFLAGS_kbuild	=	$(CCFLAGS_KERNEL) -DLINUX \
@@ -534,9 +527,12 @@ export SUPPORT_XORG_SENSOR_FRAMEWORK
 endif
 
 # If we do not specify direst path to external 3pdd sources, use tarball
+EXTERNAL_3PDD_TARBALL_PATH :=
 ifeq ($(MRST_DRIVER_SOURCE),)
-EXTERNAL_3PDD_TARBALL_PATH = $(EURASIAROOT)/eurasiacon/external/$(EXTERNAL_3PDD_TARBALL)
+ifneq ($(EXTERNAL_3PDD_TARBALL),)
+EXTERNAL_3PDD_TARBALL_PATH := $(EURASIAROOT)/eurasiacon/external/$(EXTERNAL_3PDD_TARBALL)
 export EXTERNAL_3PDD_TARBALL_PATH
 endif
+endif
 
 
diff --git a/drivers/staging/omap3-sgx/include4/pvrversion.h b/drivers/staging/omap3-sgx/include4/pvrversion.h
index 3288915..78181d9 100644
--- a/drivers/staging/omap3-sgx/include4/pvrversion.h
+++ b/drivers/staging/omap3-sgx/include4/pvrversion.h
@@ -30,8 +30,8 @@
 #define PVRVERSION_MAJ 1
 #define PVRVERSION_MIN 6
 #define PVRVERSION_BRANCH 16
-#define PVRVERSION_BUILD 3977
-#define PVRVERSION_STRING "1.6.16.3977"
+#define PVRVERSION_BUILD 4117
+#define PVRVERSION_STRING "1.6.16.4117"
 #define PVRVERSION_FILE "eurasiacon.pj"
 
 #endif 
diff --git a/drivers/staging/omap3-sgx/include4/servicesext.h b/drivers/staging/omap3-sgx/include4/servicesext.h
index 2f81b11..c2c14af 100644
--- a/drivers/staging/omap3-sgx/include4/servicesext.h
+++ b/drivers/staging/omap3-sgx/include4/servicesext.h
@@ -804,6 +804,16 @@ typedef struct PVRSRV_CURSOR_INFO_TAG
 
 } PVRSRV_CURSOR_INFO;
 
+#if defined(PDUMP_SUSPEND_IS_PER_THREAD)
+typedef struct {
+	IMG_UINT32 threadId;
+	int suspendCount;
+} PVRSRV_THREAD_SUSPEND_COUNT;
+
+#define PVRSRV_PDUMP_SUSPEND_Q_NAME "PVRSRVPDumpSuspendMsgQ"
+#define PVRSRV_PDUMP_SUSPEND_Q_LENGTH 8
+
+#endif 
 
 typedef struct _PVRSRV_REGISTRY_INFO_
 {
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.c b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.c
index 79e7b85..5861e8e 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.c
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.c
@@ -110,7 +110,7 @@ static int bc_release(struct inode *i, struct file *f);
 static int bc_ioctl(struct inode *inode, struct file *file,
                     unsigned int cmd, unsigned long arg);
 #else
-static int bc_ioctl(struct file *file,
+static long bc_ioctl(struct file *file,
                     unsigned int cmd, unsigned long arg);
 #endif
 static int bc_mmap(struct file *filp, struct vm_area_struct *vma);
@@ -126,7 +126,7 @@ static PVRSRV_ERROR BCClosePVRServices(IMG_HANDLE hPVRServices);
 static IMG_VOID *BCAllocKernelMem(unsigned long ulSize);
 static IMG_VOID BCFreeKernelMem(IMG_VOID *pvMem);
 
-static PVRSRV_ERROR BCAllocContigMemory(unsigned long ulSize,
+static BCE_ERROR BCAllocContigMemory(unsigned long ulSize,
                                IMG_HANDLE * phMemHandle,
                                IMG_CPU_VIRTADDR *pLinAddr,
                                IMG_CPU_PHYADDR *pPhysAddr);
@@ -216,7 +216,7 @@ OPEN_FXN(8)
 OPEN_FXN(9)
 #endif
 
-static PVRSRV_ERROR CloseBCDevice(IMG_HANDLE hDevice)
+static PVRSRV_ERROR CloseBCDevice(IMG_UINT32 handle , IMG_HANDLE hDevice)
 {
     PVR_UNREFERENCED_PARAMETER(hDevice);
 
@@ -328,6 +328,12 @@ static int BC_CreateBuffers(int id, bc_buf_params_t *p)
         pixel_fmt = PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YUYV;
         stride = p->width << 1;
         break;
+    
+    case BC_PIX_FMT_ARGB:
+        pixel_fmt = PVRSRV_PIXEL_FORMAT_ARGB8888;
+        stride = p->width << 2;
+        break;
+
     default:
         return -EINVAL;
         break;
@@ -739,7 +745,7 @@ void BCFreeDiscontigMemory(unsigned long ulSize,
 }
 #else
 
-PVRSRV_ERROR BCAllocContigMemory(unsigned long ulSize,
+BCE_ERROR BCAllocContigMemory(unsigned long ulSize,
                                  IMG_HANDLE unref__ *phMemHandle, 
                                  IMG_CPU_VIRTADDR *pLinAddr, 
                                  IMG_CPU_PHYADDR *pPhysAddr)
@@ -922,7 +928,7 @@ static int bc_mmap(struct file *filp, struct vm_area_struct *vma)
 static int bc_ioctl(struct inode *inode, struct file *file,
                     unsigned int cmd, unsigned long arg)
 #else
-static int bc_ioctl(struct file *file,
+static long  bc_ioctl(struct file *file,
                     unsigned int cmd, unsigned long arg)
 #endif
 {
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.h b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.h
index 3ca0b69..388af28 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.h
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.h
@@ -37,6 +37,7 @@
 #define BC_PIX_FMT_UYVY     BC_FOURCC('U', 'Y', 'V', 'Y') /*YUV 4:2:2*/
 #define BC_PIX_FMT_YUYV     BC_FOURCC('Y', 'U', 'Y', 'V') /*YUV 4:2:2*/
 #define BC_PIX_FMT_RGB565   BC_FOURCC('R', 'G', 'B', 'P') /*RGB 5:6:5*/
+#define BC_PIX_FMT_ARGB     BC_FOURCC('A', 'R', 'G', 'B') /*ARGB 8:8:8:8*/
 
 enum BC_memory {
     BC_MEMORY_MMAP          = 1,
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/3rdparty_dc_drm_shared.h b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/3rdparty_dc_drm_shared.h
new file mode 100644
index 0000000..9b6d240
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/3rdparty_dc_drm_shared.h
@@ -0,0 +1,45 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef __3RDPARTY_DC_DRM_SHARED_H__
+#define __3RDPARTY_DC_DRM_SHARED_H__
+#if defined(SUPPORT_DRI_DRM)
+
+#define	PVR_DRM_DISP_CMD_ENTER_VT	1
+#define	PVR_DRM_DISP_CMD_LEAVE_VT	2
+
+#define	PVR_DRM_DISP_CMD_ON		3
+#define	PVR_DRM_DISP_CMD_STANDBY	4
+#define	PVR_DRM_DISP_CMD_SUSPEND	5
+#define	PVR_DRM_DISP_CMD_OFF		6
+
+#define	PVR_DRM_DISP_ARG_CMD		0
+#define	PVR_DRM_DISP_ARG_DEV		1
+#define	PVR_DRM_DISP_NUM_ARGS		2
+
+#endif	
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/Kbuild b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/Kbuild
new file mode 100644
index 0000000..063130e
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/Kbuild
@@ -0,0 +1,29 @@
+SYS_USING_INTERRUPTS = 1
+SUPPORT_OMAP3430_OMAPFB3 =1
+SUPPORT_TI_DSS_FW = 0
+PVR_LINUX_USING_WORKQUEUES = 1
+SYS_CFLAGS.$(SYS_USING_INTERRUPTS)                      += -DSYS_USING_INTERRUPTS
+SYS_CFLAGS.$(SUPPORT_OMAP3430_OMAPFB3)                         += -DSUPPORT_OMAP3430_OMAPFB3
+SYS_CFLAGS.$(SUPPORT_TI_DSS_FW)                         += -DSUPPORT_TI_DSS_FW
+SYS_CFLAGS.$(PVR_LINUX_USING_WORKQUEUES)             += -DPVR_LINUX_USING_WORKQUEUES
+SYS_CFLAGS += -DDISPLAY_CONTROLLER=omaplfb
+
+
+ccflags-y += -DLINUX
+ccflags-y += -Idrivers/staging/omap3-sgx/include4
+ccflags-y += -Idrivers/staging/omap3-sgx/services4/include
+ccflags-y += -Idrivers/staging/omap3-sgx/services4/system/$(PVR_SYSTEM)
+ccflags-y += -Idrivers/staging/omap3-sgx/services4/srvkm/env/linux
+ccflags-y += -Idrivers/staging/omap3-sgx/services4/include/env/linux
+ccflags-y += -Idrivers/staging/omap3-sgx/services4/system/include
+ccflags-y += -Idrivers/video/omap2
+ccflags-y += -Iarch/arm/plat-omap/include
+ccflags-y += $(SYS_CFLAGS.1)
+
+ifeq ($(SUPPORT_XORG),1)
+EXTRA_CFLAGS += -DSUPPORT_DRI_DRM
+EXTRA_CFLAGS += -DPVR_DISPLAY_CONTROLLER_DRM_IOCTL
+endif
+
+obj-m := omaplfb.o
+omaplfb-y := omaplfb_displayclass.o omaplfb_linux.o
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/kbuild/Makefile b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/kbuild/Makefile
new file mode 100644
index 0000000..f52617a
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/kbuild/Makefile
@@ -0,0 +1,36 @@
+#
+# Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+# 
+# This program is distributed in the hope it will be useful but, except 
+# as otherwise stated in writing, without any warranty; without even the 
+# implied warranty of merchantability or fitness for a particular purpose. 
+# See the GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+# 
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Imagination Technologies Ltd. <gpl-support@imgtec.com>
+# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+# 
+#
+
+MODULE		= $(DISPLAY_CONTROLLER)
+
+INCLUDES =
+
+SOURCES	=
+
+SYM_VERS_DEPS = $(EURASIAROOT)/services4/srvkm/env/linux
+
+include $(EURASIAROOT)/services4/$(DISPLAY_CONTROLLER_DIR)/makefile.linux.common
+
+include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb.h b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb.h
new file mode 100644
index 0000000..881a49d
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb.h
@@ -0,0 +1,269 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef __OMAPLFB_H__
+#define __OMAPLFB_H__
+
+#include <linux/version.h>
+
+#include <asm/atomic.h>
+
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/fb.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/notifier.h>
+#include <linux/mutex.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#define unref__ __attribute__ ((unused))
+
+typedef void *       OMAPLFB_HANDLE;
+
+typedef bool OMAPLFB_BOOL, *OMAPLFB_PBOOL;
+#define	OMAPLFB_FALSE false
+#define OMAPLFB_TRUE true
+
+typedef	atomic_t	OMAPLFB_ATOMIC_BOOL;
+
+typedef atomic_t	OMAPLFB_ATOMIC_INT;
+
+typedef struct OMAPLFB_BUFFER_TAG
+{
+	struct OMAPLFB_BUFFER_TAG	*psNext;
+	struct OMAPLFB_DEVINFO_TAG	*psDevInfo;
+
+	struct work_struct sWork;
+
+	
+	unsigned long		     	ulYOffset;
+
+	
+	
+	IMG_SYS_PHYADDR              	sSysAddr;
+	IMG_CPU_VIRTADDR             	sCPUVAddr;
+	PVRSRV_SYNC_DATA            	*psSyncData;
+
+	OMAPLFB_HANDLE      		hCmdComplete;
+	unsigned long    		ulSwapInterval;
+} OMAPLFB_BUFFER;
+
+typedef struct OMAPLFB_SWAPCHAIN_TAG
+{
+	
+	unsigned int			uiSwapChainID;
+
+	
+	unsigned long       		ulBufferCount;
+
+	
+	OMAPLFB_BUFFER     		*psBuffer;
+
+	
+	struct workqueue_struct   	*psWorkQueue;
+
+	
+	OMAPLFB_BOOL			bNotVSynced;
+
+	
+	int				iBlankEvents;
+
+	
+	unsigned int            	uiFBDevID;
+} OMAPLFB_SWAPCHAIN;
+
+typedef struct OMAPLFB_FBINFO_TAG
+{
+	unsigned long       ulFBSize;
+	unsigned long       ulBufferSize;
+	unsigned long       ulRoundedBufferSize;
+	unsigned long       ulWidth;
+	unsigned long       ulHeight;
+	unsigned long       ulByteStride;
+	unsigned long       ulPhysicalWidthmm;
+	unsigned long       ulPhysicalHeightmm;
+
+	
+	
+	IMG_SYS_PHYADDR     sSysAddr;
+	IMG_CPU_VIRTADDR    sCPUVAddr;
+
+	
+	PVRSRV_PIXEL_FORMAT ePixelFormat;
+}OMAPLFB_FBINFO;
+
+typedef struct OMAPLFB_DEVINFO_TAG
+{
+	
+	unsigned int            uiFBDevID;
+
+	
+	unsigned int            uiPVRDevID;
+
+	
+	struct mutex		sCreateSwapChainMutex;
+
+	
+	OMAPLFB_BUFFER          sSystemBuffer;
+
+	
+	PVRSRV_DC_DISP2SRV_KMJTABLE	sPVRJTable;
+	
+	
+	PVRSRV_DC_SRV2DISP_KMJTABLE	sDCJTable;
+
+	
+	OMAPLFB_FBINFO          sFBInfo;
+
+	
+	OMAPLFB_SWAPCHAIN      *psSwapChain;
+
+	
+	unsigned int		uiSwapChainID;
+
+	
+	OMAPLFB_ATOMIC_BOOL     sFlushCommands;
+
+	
+	struct fb_info         *psLINFBInfo;
+
+	
+	struct notifier_block   sLINNotifBlock;
+
+	
+	
+
+	
+	IMG_DEV_VIRTADDR	sDisplayDevVAddr;
+
+	DISPLAY_INFO            sDisplayInfo;
+
+	
+	DISPLAY_FORMAT          sDisplayFormat;
+	
+	
+	DISPLAY_DIMS            sDisplayDim;
+
+	
+	OMAPLFB_ATOMIC_BOOL	sBlanked;
+
+	
+	OMAPLFB_ATOMIC_INT	sBlankEvents;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	
+	OMAPLFB_ATOMIC_BOOL	sEarlySuspendFlag;
+
+	struct early_suspend    sEarlySuspend;
+#endif
+
+#if defined(SUPPORT_DRI_DRM)
+	OMAPLFB_ATOMIC_BOOL     sLeaveVT;
+#endif
+
+}  OMAPLFB_DEVINFO;
+
+#define	OMAPLFB_PAGE_SIZE 4096
+
+#ifdef	DEBUG
+#define	DEBUG_PRINTK(x) printk x
+#else
+#define	DEBUG_PRINTK(x)
+#endif
+
+#define DISPLAY_DEVICE_NAME "PowerVR OMAP Linux Display Driver"
+#define	DRVNAME	"omaplfb"
+#define	DEVNAME	DRVNAME
+#define	DRIVER_PREFIX DRVNAME
+
+typedef enum _OMAPLFB_ERROR_
+{
+	OMAPLFB_OK                             =  0,
+	OMAPLFB_ERROR_GENERIC                  =  1,
+	OMAPLFB_ERROR_OUT_OF_MEMORY            =  2,
+	OMAPLFB_ERROR_TOO_FEW_BUFFERS          =  3,
+	OMAPLFB_ERROR_INVALID_PARAMS           =  4,
+	OMAPLFB_ERROR_INIT_FAILURE             =  5,
+	OMAPLFB_ERROR_CANT_REGISTER_CALLBACK   =  6,
+	OMAPLFB_ERROR_INVALID_DEVICE           =  7,
+	OMAPLFB_ERROR_DEVICE_REGISTER_FAILED   =  8,
+	OMAPLFB_ERROR_SET_UPDATE_MODE_FAILED   =  9
+} OMAPLFB_ERROR;
+
+typedef enum _OMAPLFB_UPDATE_MODE_
+{
+	OMAPLFB_UPDATE_MODE_UNDEFINED			= 0,
+	OMAPLFB_UPDATE_MODE_MANUAL			= 1,
+	OMAPLFB_UPDATE_MODE_AUTO			= 2,
+	OMAPLFB_UPDATE_MODE_DISABLED			= 3
+} OMAPLFB_UPDATE_MODE;
+
+#ifndef UNREFERENCED_PARAMETER
+#define	UNREFERENCED_PARAMETER(param) (param) = (param)
+#endif
+
+OMAPLFB_ERROR OMAPLFBInit(void);
+OMAPLFB_ERROR OMAPLFBDeInit(void);
+
+OMAPLFB_DEVINFO *OMAPLFBGetDevInfoPtr(unsigned uiFBDevID);
+unsigned OMAPLFBMaxFBDevIDPlusOne(void);
+void *OMAPLFBAllocKernelMem(unsigned long ulSize);
+void OMAPLFBFreeKernelMem(void *pvMem);
+OMAPLFB_ERROR OMAPLFBGetLibFuncAddr(char *szFunctionName, PFN_DC_GET_PVRJTABLE *ppfnFuncTable);
+OMAPLFB_ERROR OMAPLFBCreateSwapQueue (OMAPLFB_SWAPCHAIN *psSwapChain);
+void OMAPLFBDestroySwapQueue(OMAPLFB_SWAPCHAIN *psSwapChain);
+void OMAPLFBInitBufferForSwap(OMAPLFB_BUFFER *psBuffer);
+void OMAPLFBSwapHandler(OMAPLFB_BUFFER *psBuffer);
+void OMAPLFBQueueBufferForSwap(OMAPLFB_SWAPCHAIN *psSwapChain, OMAPLFB_BUFFER *psBuffer);
+void OMAPLFBFlip(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_BUFFER *psBuffer);
+OMAPLFB_UPDATE_MODE OMAPLFBGetUpdateMode(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_BOOL OMAPLFBSetUpdateMode(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_UPDATE_MODE eMode);
+OMAPLFB_BOOL OMAPLFBWaitForVSync(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_BOOL OMAPLFBManualSync(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_BOOL OMAPLFBCheckModeAndSync(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_ERROR OMAPLFBUnblankDisplay(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_ERROR OMAPLFBEnableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_ERROR OMAPLFBDisableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBCreateSwapChainLockInit(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBCreateSwapChainLockDeInit(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBCreateSwapChainLock(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBCreateSwapChainUnLock(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBAtomicBoolInit(OMAPLFB_ATOMIC_BOOL *psAtomic, OMAPLFB_BOOL bVal);
+void OMAPLFBAtomicBoolDeInit(OMAPLFB_ATOMIC_BOOL *psAtomic);
+void OMAPLFBAtomicBoolSet(OMAPLFB_ATOMIC_BOOL *psAtomic, OMAPLFB_BOOL bVal);
+OMAPLFB_BOOL OMAPLFBAtomicBoolRead(OMAPLFB_ATOMIC_BOOL *psAtomic);
+void OMAPLFBAtomicIntInit(OMAPLFB_ATOMIC_INT *psAtomic, int iVal);
+void OMAPLFBAtomicIntDeInit(OMAPLFB_ATOMIC_INT *psAtomic);
+void OMAPLFBAtomicIntSet(OMAPLFB_ATOMIC_INT *psAtomic, int iVal);
+int OMAPLFBAtomicIntRead(OMAPLFB_ATOMIC_INT *psAtomic);
+void OMAPLFBAtomicIntInc(OMAPLFB_ATOMIC_INT *psAtomic);
+
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_displayclass.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_displayclass.c
new file mode 100644
index 0000000..fb80596
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_displayclass.c
@@ -0,0 +1,1238 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/fb.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/notifier.h>
+
+#include "img_defs.h"
+#include "servicesext.h"
+#include "kerneldisplay.h"
+#include "omaplfb.h"
+
+#define OMAPLFB_COMMAND_COUNT		1
+
+#define	OMAPLFB_VSYNC_SETTLE_COUNT	5
+
+//#define	OMAPLFB_MAX_NUM_DEVICES		FB_MAX
+#define	OMAPLFB_MAX_NUM_DEVICES	1
+
+#if (OMAPLFB_MAX_NUM_DEVICES > FB_MAX)
+#error "OMAPLFB_MAX_NUM_DEVICES must not be greater than FB_MAX"
+#endif
+
+static OMAPLFB_DEVINFO *gapsDevInfo[OMAPLFB_MAX_NUM_DEVICES];
+
+static PFN_DC_GET_PVRJTABLE gpfnGetPVRJTable = NULL;
+
+static inline unsigned long RoundUpToMultiple(unsigned long x, unsigned long y)
+{
+	unsigned long div = x / y;
+	unsigned long rem = x % y;
+
+	return (div + ((rem == 0) ? 0 : 1)) * y;
+}
+
+static unsigned long GCD(unsigned long x, unsigned long y)
+{
+	while (y != 0)
+	{
+		unsigned long r = x % y;
+		x = y;
+		y = r;
+	}
+
+	return x;
+}
+
+static unsigned long LCM(unsigned long x, unsigned long y)
+{
+	unsigned long gcd = GCD(x, y);
+
+	return (gcd == 0) ? 0 : ((x / gcd) * y);
+}
+
+unsigned OMAPLFBMaxFBDevIDPlusOne(void)
+{
+	return OMAPLFB_MAX_NUM_DEVICES;
+}
+
+OMAPLFB_DEVINFO *OMAPLFBGetDevInfoPtr(unsigned uiFBDevID)
+{
+	WARN_ON(uiFBDevID >= OMAPLFBMaxFBDevIDPlusOne());
+
+	if (uiFBDevID >= OMAPLFB_MAX_NUM_DEVICES)
+	{
+		return NULL;
+	}
+
+	return gapsDevInfo[uiFBDevID];
+}
+
+static inline void OMAPLFBSetDevInfoPtr(unsigned uiFBDevID, OMAPLFB_DEVINFO *psDevInfo)
+{
+	WARN_ON(uiFBDevID >= OMAPLFB_MAX_NUM_DEVICES);
+
+	if (uiFBDevID < OMAPLFB_MAX_NUM_DEVICES)
+	{
+		gapsDevInfo[uiFBDevID] = psDevInfo;
+	}
+}
+
+static inline OMAPLFB_BOOL SwapChainHasChanged(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+	return (psDevInfo->psSwapChain != psSwapChain) ||
+		(psDevInfo->uiSwapChainID != psSwapChain->uiSwapChainID);
+}
+
+static inline OMAPLFB_BOOL DontWaitForVSync(OMAPLFB_DEVINFO *psDevInfo)
+{
+	OMAPLFB_BOOL bDontWait;
+
+	bDontWait = OMAPLFBAtomicBoolRead(&psDevInfo->sBlanked) ||
+			OMAPLFBAtomicBoolRead(&psDevInfo->sFlushCommands);
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	bDontWait = bDontWait || OMAPLFBAtomicBoolRead(&psDevInfo->sEarlySuspendFlag);
+#endif
+#if defined(SUPPORT_DRI_DRM)
+	bDontWait = bDontWait || OMAPLFBAtomicBoolRead(&psDevInfo->sLeaveVT);
+#endif
+	return bDontWait;
+}
+
+static IMG_VOID SetDCState(IMG_HANDLE hDevice, IMG_UINT32 ui32State)
+{
+	OMAPLFB_DEVINFO *psDevInfo = (OMAPLFB_DEVINFO *)hDevice;
+
+	switch (ui32State)
+	{
+		case DC_STATE_FLUSH_COMMANDS:
+			OMAPLFBAtomicBoolSet(&psDevInfo->sFlushCommands, OMAPLFB_TRUE);
+			break;
+		case DC_STATE_NO_FLUSH_COMMANDS:
+			OMAPLFBAtomicBoolSet(&psDevInfo->sFlushCommands, OMAPLFB_FALSE);
+			break;
+		default:
+			break;
+	}
+}
+
+static PVRSRV_ERROR OpenDCDevice(IMG_UINT32 uiPVRDevID,
+                                 IMG_HANDLE *phDevice,
+                                 PVRSRV_SYNC_DATA* psSystemBufferSyncData)
+{
+	OMAPLFB_DEVINFO *psDevInfo;
+	OMAPLFB_ERROR eError;
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+
+	for (i = 0; i < uiMaxFBDevIDPlusOne; i++)
+	{
+		psDevInfo = OMAPLFBGetDevInfoPtr(i);
+		if (psDevInfo != NULL && psDevInfo->uiPVRDevID == uiPVRDevID)
+		{
+			break;
+		}
+	}
+	if (i == uiMaxFBDevIDPlusOne)
+	{
+		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
+			": %s: PVR Device %u not found\n", __FUNCTION__, uiPVRDevID));
+		return PVRSRV_ERROR_INVALID_DEVICE;
+	}
+
+	
+	psDevInfo->sSystemBuffer.psSyncData = psSystemBufferSyncData;
+	
+	eError = OMAPLFBUnblankDisplay(psDevInfo);
+	if (eError != OMAPLFB_OK)
+	{
+		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: OMAPLFBUnblankDisplay failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eError));
+		return PVRSRV_ERROR_UNBLANK_DISPLAY_FAILED;
+	}
+
+	
+	*phDevice = (IMG_HANDLE)psDevInfo;
+	
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR CloseDCDevice(IMG_HANDLE hDevice)
+{
+#if defined(SUPPORT_DRI_DRM)
+	OMAPLFB_DEVINFO *psDevInfo = (OMAPLFB_DEVINFO *)hDevice;
+
+	OMAPLFBAtomicBoolSet(&psDevInfo->sLeaveVT, OMAPLFB_FALSE);
+	(void) OMAPLFBUnblankDisplay(psDevInfo);
+#else
+	UNREFERENCED_PARAMETER(hDevice);
+#endif
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR EnumDCFormats(IMG_HANDLE hDevice,
+                                  IMG_UINT32 *pui32NumFormats,
+                                  DISPLAY_FORMAT *psFormat)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	
+	if(!hDevice || !pui32NumFormats)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	
+	*pui32NumFormats = 1;
+	
+	if(psFormat)
+	{
+		psFormat[0] = psDevInfo->sDisplayFormat;
+	}
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR EnumDCDims(IMG_HANDLE hDevice, 
+                               DISPLAY_FORMAT *psFormat,
+                               IMG_UINT32 *pui32NumDims,
+                               DISPLAY_DIMS *psDim)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+
+	if(!hDevice || !psFormat || !pui32NumDims)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	*pui32NumDims = 1;
+
+	
+	if(psDim)
+	{
+		psDim[0] = psDevInfo->sDisplayDim;
+	}
+	
+	return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR GetDCSystemBuffer(IMG_HANDLE hDevice, IMG_HANDLE *phBuffer)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	
+	if(!hDevice || !phBuffer)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	*phBuffer = (IMG_HANDLE)&psDevInfo->sSystemBuffer;
+
+	return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR GetDCInfo(IMG_HANDLE hDevice, DISPLAY_INFO *psDCInfo)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	
+	if(!hDevice || !psDCInfo)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	*psDCInfo = psDevInfo->sDisplayInfo;
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE        hDevice,
+                                    IMG_HANDLE        hBuffer, 
+                                    IMG_SYS_PHYADDR   **ppsSysAddr,
+                                    IMG_UINT32        *pui32ByteSize,
+                                    IMG_VOID          **ppvCpuVAddr,
+                                    IMG_HANDLE        *phOSMapInfo,
+                                    IMG_BOOL          *pbIsContiguous,
+	                                IMG_UINT32		  *pui32TilingStride)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	OMAPLFB_BUFFER *psSystemBuffer;
+
+	UNREFERENCED_PARAMETER(pui32TilingStride);
+
+	if(!hDevice)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	if(!hBuffer)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	if (!ppsSysAddr)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	if (!pui32ByteSize)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	psSystemBuffer = (OMAPLFB_BUFFER *)hBuffer;
+
+	*ppsSysAddr = &psSystemBuffer->sSysAddr;
+
+	*pui32ByteSize = (IMG_UINT32)psDevInfo->sFBInfo.ulBufferSize;
+
+	if (ppvCpuVAddr)
+	{
+		*ppvCpuVAddr = psSystemBuffer->sCPUVAddr;
+	}
+
+	if (phOSMapInfo)
+	{
+		*phOSMapInfo = (IMG_HANDLE)0;
+	}
+
+	if (pbIsContiguous)
+	{
+		*pbIsContiguous = IMG_TRUE;
+	}
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
+                                      IMG_UINT32 ui32Flags,
+                                      DISPLAY_SURF_ATTRIBUTES *psDstSurfAttrib,
+                                      DISPLAY_SURF_ATTRIBUTES *psSrcSurfAttrib,
+                                      IMG_UINT32 ui32BufferCount,
+                                      PVRSRV_SYNC_DATA **ppsSyncData,
+                                      IMG_UINT32 ui32OEMFlags,
+                                      IMG_HANDLE *phSwapChain,
+                                      IMG_UINT32 *pui32SwapChainID)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+	OMAPLFB_BUFFER *psBuffer;
+	IMG_UINT32 i;
+	PVRSRV_ERROR eError;
+	IMG_UINT32 ui32BuffersToSkip;
+
+	UNREFERENCED_PARAMETER(ui32OEMFlags);
+	
+	if(!hDevice
+	|| !psDstSurfAttrib
+	|| !psSrcSurfAttrib
+	|| !ppsSyncData
+	|| !phSwapChain)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	
+	
+	if (psDevInfo->sDisplayInfo.ui32MaxSwapChains == 0)
+	{
+		return PVRSRV_ERROR_NOT_SUPPORTED;
+	}
+
+	OMAPLFBCreateSwapChainLock(psDevInfo);
+
+	
+	if(psDevInfo->psSwapChain != NULL)
+	{
+		eError = PVRSRV_ERROR_FLIP_CHAIN_EXISTS;
+		goto ExitUnLock;
+	}
+	
+	
+	if(ui32BufferCount > psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers)
+	{
+		eError = PVRSRV_ERROR_TOOMANYBUFFERS;
+		goto ExitUnLock;
+	}
+	
+	if ((psDevInfo->sFBInfo.ulRoundedBufferSize * (unsigned long)ui32BufferCount) > psDevInfo->sFBInfo.ulFBSize)
+	{
+		eError = PVRSRV_ERROR_TOOMANYBUFFERS;
+		goto ExitUnLock;
+	}
+
+	
+	ui32BuffersToSkip = psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers - ui32BufferCount;
+
+	
+	if(psDstSurfAttrib->pixelformat != psDevInfo->sDisplayFormat.pixelformat
+	|| psDstSurfAttrib->sDims.ui32ByteStride != psDevInfo->sDisplayDim.ui32ByteStride
+	|| psDstSurfAttrib->sDims.ui32Width != psDevInfo->sDisplayDim.ui32Width
+	|| psDstSurfAttrib->sDims.ui32Height != psDevInfo->sDisplayDim.ui32Height)
+	{
+		
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto ExitUnLock;
+	}		
+
+	if(psDstSurfAttrib->pixelformat != psSrcSurfAttrib->pixelformat
+	|| psDstSurfAttrib->sDims.ui32ByteStride != psSrcSurfAttrib->sDims.ui32ByteStride
+	|| psDstSurfAttrib->sDims.ui32Width != psSrcSurfAttrib->sDims.ui32Width
+	|| psDstSurfAttrib->sDims.ui32Height != psSrcSurfAttrib->sDims.ui32Height)
+	{
+		
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto ExitUnLock;
+	}		
+
+	
+	UNREFERENCED_PARAMETER(ui32Flags);
+	
+#if defined(PVR_OMAPFB3_UPDATE_MODE)
+	if (!OMAPLFBSetUpdateMode(psDevInfo, PVR_OMAPFB3_UPDATE_MODE))
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't set frame buffer update mode %d\n", __FUNCTION__, psDevInfo->uiFBDevID, PVR_OMAPFB3_UPDATE_MODE);
+	}
+#endif
+	
+	psSwapChain = (OMAPLFB_SWAPCHAIN*)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_SWAPCHAIN));
+	if(!psSwapChain)
+	{
+		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto ExitUnLock;
+	}
+
+	psBuffer = (OMAPLFB_BUFFER*)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_BUFFER) * ui32BufferCount);
+	if(!psBuffer)
+	{
+		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto ErrorFreeSwapChain;
+	}
+
+	psSwapChain->ulBufferCount = (unsigned long)ui32BufferCount;
+	psSwapChain->psBuffer = psBuffer;
+	psSwapChain->bNotVSynced = OMAPLFB_TRUE;
+	psSwapChain->uiFBDevID = psDevInfo->uiFBDevID;
+
+	
+	for(i=0; i<ui32BufferCount-1; i++)
+	{
+		psBuffer[i].psNext = &psBuffer[i+1];
+	}
+	
+	psBuffer[i].psNext = &psBuffer[0];
+
+	
+	for(i=0; i<ui32BufferCount; i++)
+	{
+		IMG_UINT32 ui32SwapBuffer = i + ui32BuffersToSkip;
+		IMG_UINT32 ui32BufferOffset = ui32SwapBuffer * (IMG_UINT32)psDevInfo->sFBInfo.ulRoundedBufferSize;
+
+		psBuffer[i].psSyncData = ppsSyncData[i];
+
+		psBuffer[i].sSysAddr.uiAddr = psDevInfo->sFBInfo.sSysAddr.uiAddr + ui32BufferOffset;
+		psBuffer[i].sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr + ui32BufferOffset;
+		psBuffer[i].ulYOffset = ui32BufferOffset / psDevInfo->sFBInfo.ulByteStride;
+		psBuffer[i].psDevInfo = psDevInfo;
+
+		OMAPLFBInitBufferForSwap(&psBuffer[i]);
+	}
+
+	if (OMAPLFBCreateSwapQueue(psSwapChain) != OMAPLFB_OK)
+	{ 
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Failed to create workqueue\n", __FUNCTION__, psDevInfo->uiFBDevID);
+		eError = PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR;
+		goto ErrorFreeBuffers;
+	}
+
+	if (OMAPLFBEnableLFBEventNotification(psDevInfo)!= OMAPLFB_OK)
+	{
+		eError = PVRSRV_ERROR_UNABLE_TO_ENABLE_EVENT;
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't enable framebuffer event notification\n", __FUNCTION__, psDevInfo->uiFBDevID);
+		goto ErrorDestroySwapQueue;
+	}
+
+	psDevInfo->uiSwapChainID++;
+	if (psDevInfo->uiSwapChainID == 0)
+	{
+		psDevInfo->uiSwapChainID++;
+	}
+
+	psSwapChain->uiSwapChainID = psDevInfo->uiSwapChainID;
+
+	psDevInfo->psSwapChain = psSwapChain;
+
+	*pui32SwapChainID = psDevInfo->uiSwapChainID;
+
+	*phSwapChain = (IMG_HANDLE)psSwapChain;
+
+	eError = PVRSRV_OK;
+	goto ExitUnLock;
+
+ErrorDestroySwapQueue:
+	OMAPLFBDestroySwapQueue(psSwapChain);
+ErrorFreeBuffers:
+	OMAPLFBFreeKernelMem(psBuffer);
+ErrorFreeSwapChain:
+	OMAPLFBFreeKernelMem(psSwapChain);
+ExitUnLock:
+	OMAPLFBCreateSwapChainUnLock(psDevInfo);
+	return eError;
+}
+
+static PVRSRV_ERROR DestroyDCSwapChain(IMG_HANDLE hDevice,
+	IMG_HANDLE hSwapChain)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+	OMAPLFB_ERROR eError;
+
+	
+	if(!hDevice || !hSwapChain)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+	
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
+
+	OMAPLFBCreateSwapChainLock(psDevInfo);
+
+	if (SwapChainHasChanged(psDevInfo, psSwapChain))
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: Swap chain mismatch\n", __FUNCTION__, psDevInfo->uiFBDevID);
+
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto ExitUnLock;
+	}
+
+	
+	OMAPLFBDestroySwapQueue(psSwapChain);
+
+	eError = OMAPLFBDisableLFBEventNotification(psDevInfo);
+	if (eError != OMAPLFB_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't disable framebuffer event notification\n", __FUNCTION__, psDevInfo->uiFBDevID);
+	}
+
+	
+	OMAPLFBFreeKernelMem(psSwapChain->psBuffer);
+	OMAPLFBFreeKernelMem(psSwapChain);
+
+	psDevInfo->psSwapChain = NULL;
+
+	OMAPLFBFlip(psDevInfo, &psDevInfo->sSystemBuffer);
+	(void) OMAPLFBCheckModeAndSync(psDevInfo);
+
+	eError = PVRSRV_OK;
+
+ExitUnLock:
+	OMAPLFBCreateSwapChainUnLock(psDevInfo);
+
+	return eError;
+}
+
+static PVRSRV_ERROR SetDCDstRect(IMG_HANDLE hDevice,
+	IMG_HANDLE hSwapChain,
+	IMG_RECT *psRect)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	UNREFERENCED_PARAMETER(psRect);
+
+	
+	
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+static PVRSRV_ERROR SetDCSrcRect(IMG_HANDLE hDevice,
+                                 IMG_HANDLE hSwapChain,
+                                 IMG_RECT *psRect)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	UNREFERENCED_PARAMETER(psRect);
+
+	
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+static PVRSRV_ERROR SetDCDstColourKey(IMG_HANDLE hDevice,
+                                      IMG_HANDLE hSwapChain,
+                                      IMG_UINT32 ui32CKColour)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	UNREFERENCED_PARAMETER(ui32CKColour);
+
+	
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+static PVRSRV_ERROR SetDCSrcColourKey(IMG_HANDLE hDevice,
+                                      IMG_HANDLE hSwapChain,
+                                      IMG_UINT32 ui32CKColour)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	UNREFERENCED_PARAMETER(ui32CKColour);
+
+	
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+static PVRSRV_ERROR GetDCBuffers(IMG_HANDLE hDevice,
+                                 IMG_HANDLE hSwapChain,
+                                 IMG_UINT32 *pui32BufferCount,
+                                 IMG_HANDLE *phBuffer)
+{
+	OMAPLFB_DEVINFO   *psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+	PVRSRV_ERROR eError;
+	unsigned i;
+	
+	
+	if(!hDevice 
+	|| !hSwapChain
+	|| !pui32BufferCount
+	|| !phBuffer)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+	
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
+
+	OMAPLFBCreateSwapChainLock(psDevInfo);
+
+	if (SwapChainHasChanged(psDevInfo, psSwapChain))
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: Swap chain mismatch\n", __FUNCTION__, psDevInfo->uiFBDevID);
+
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto Exit;
+	}
+	
+	
+	*pui32BufferCount = (IMG_UINT32)psSwapChain->ulBufferCount;
+	
+	
+	for(i=0; i<psSwapChain->ulBufferCount; i++)
+	{
+		phBuffer[i] = (IMG_HANDLE)&psSwapChain->psBuffer[i];
+	}
+	
+	eError = PVRSRV_OK;
+
+Exit:
+	OMAPLFBCreateSwapChainUnLock(psDevInfo);
+
+	return eError;
+}
+
+static PVRSRV_ERROR SwapToDCBuffer(IMG_HANDLE hDevice,
+                                   IMG_HANDLE hBuffer,
+                                   IMG_UINT32 ui32SwapInterval,
+                                   IMG_HANDLE hPrivateTag,
+                                   IMG_UINT32 ui32ClipRectCount,
+                                   IMG_RECT *psClipRect)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hBuffer);
+	UNREFERENCED_PARAMETER(ui32SwapInterval);
+	UNREFERENCED_PARAMETER(hPrivateTag);
+	UNREFERENCED_PARAMETER(ui32ClipRectCount);
+	UNREFERENCED_PARAMETER(psClipRect);
+	
+	
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR SwapToDCSystem(IMG_HANDLE hDevice,
+                                   IMG_HANDLE hSwapChain)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	
+	
+	return PVRSRV_OK;
+}
+
+static OMAPLFB_BOOL WaitForVSyncSettle(OMAPLFB_DEVINFO *psDevInfo)
+{
+		unsigned i;
+		for(i = 0; i < OMAPLFB_VSYNC_SETTLE_COUNT; i++)
+		{
+			if (DontWaitForVSync(psDevInfo) || !OMAPLFBWaitForVSync(psDevInfo))
+			{
+				return OMAPLFB_FALSE;
+			}
+		}
+
+		return OMAPLFB_TRUE;
+}
+
+void OMAPLFBSwapHandler(OMAPLFB_BUFFER *psBuffer)
+{
+	OMAPLFB_DEVINFO *psDevInfo = psBuffer->psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
+	OMAPLFB_BOOL bPreviouslyNotVSynced;
+#if defined(SUPPORT_DRI_DRM)
+	if (!OMAPLFBAtomicBoolRead(&psDevInfo->sLeaveVT))
+#endif
+	{
+		OMAPLFBFlip(psDevInfo, psBuffer);
+	}
+
+	bPreviouslyNotVSynced = psSwapChain->bNotVSynced;
+	psSwapChain->bNotVSynced = OMAPLFB_TRUE;
+
+
+	if (!DontWaitForVSync(psDevInfo))
+	{
+		OMAPLFB_UPDATE_MODE eMode = OMAPLFBGetUpdateMode(psDevInfo);
+		int iBlankEvents = OMAPLFBAtomicIntRead(&psDevInfo->sBlankEvents);
+
+		switch(eMode)
+		{
+			case OMAPLFB_UPDATE_MODE_AUTO:
+				psSwapChain->bNotVSynced = OMAPLFB_FALSE;
+
+				if (bPreviouslyNotVSynced || psSwapChain->iBlankEvents != iBlankEvents)
+				{
+					psSwapChain->iBlankEvents = iBlankEvents;
+					psSwapChain->bNotVSynced = !WaitForVSyncSettle(psDevInfo);
+				} else if (psBuffer->ulSwapInterval != 0)
+				{
+					psSwapChain->bNotVSynced = !OMAPLFBWaitForVSync(psDevInfo);
+				}
+				break;
+#if defined(PVR_OMAPFB3_MANUAL_UPDATE_SYNC_IN_SWAP)
+			case OMAPLFB_UPDATE_MODE_MANUAL:
+				if (psBuffer->ulSwapInterval != 0)
+				{
+					(void) OMAPLFBManualSync(psDevInfo);
+				}
+				break;
+#endif
+			default:
+				break;
+		}
+	}
+	psDevInfo->sPVRJTable.pfnPVRSRVCmdComplete((IMG_HANDLE)psBuffer->hCmdComplete, IMG_TRUE);
+}
+
+static IMG_BOOL ProcessFlip(IMG_HANDLE  hCmdCookie,
+                            IMG_UINT32  ui32DataSize,
+                            IMG_VOID   *pvData)
+{
+	DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
+	OMAPLFB_DEVINFO *psDevInfo;
+	OMAPLFB_BUFFER *psBuffer;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+
+	
+	if(!hCmdCookie || !pvData)
+	{
+		return IMG_FALSE;
+	}
+
+	
+	psFlipCmd = (DISPLAYCLASS_FLIP_COMMAND*)pvData;
+
+	if (psFlipCmd == IMG_NULL || sizeof(DISPLAYCLASS_FLIP_COMMAND) != ui32DataSize)
+	{
+		return IMG_FALSE;
+	}
+
+	
+	psDevInfo = (OMAPLFB_DEVINFO*)psFlipCmd->hExtDevice;
+	psBuffer = (OMAPLFB_BUFFER*)psFlipCmd->hExtBuffer;
+	psSwapChain = (OMAPLFB_SWAPCHAIN*) psFlipCmd->hExtSwapChain;
+
+	OMAPLFBCreateSwapChainLock(psDevInfo);
+
+	if (SwapChainHasChanged(psDevInfo, psSwapChain))
+	{
+		
+		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u (PVR Device ID %u): The swap chain has been destroyed\n",
+			__FUNCTION__, psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID));
+	}
+	else
+	{
+		psBuffer->hCmdComplete = (OMAPLFB_HANDLE)hCmdCookie;
+		psBuffer->ulSwapInterval = (unsigned long)psFlipCmd->ui32SwapInterval;
+
+		OMAPLFBQueueBufferForSwap(psSwapChain, psBuffer);
+	}
+
+	OMAPLFBCreateSwapChainUnLock(psDevInfo);
+
+	return IMG_TRUE;
+}
+
+
+static OMAPLFB_ERROR OMAPLFBInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
+{
+	struct fb_info *psLINFBInfo;
+	struct module *psLINFBOwner;
+	OMAPLFB_FBINFO *psPVRFBInfo = &psDevInfo->sFBInfo;
+	OMAPLFB_ERROR eError = OMAPLFB_ERROR_GENERIC;
+	unsigned long FBSize;
+	unsigned long ulLCM;
+	unsigned uiFBDevID = psDevInfo->uiFBDevID;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_lock();
+#else
+	acquire_console_sem();
+#endif
+
+	psLINFBInfo = registered_fb[uiFBDevID];
+	if (psLINFBInfo == NULL)
+	{
+		eError = OMAPLFB_ERROR_INVALID_DEVICE;
+		goto ErrorRelSem;
+	}
+
+	FBSize = (psLINFBInfo->screen_size) != 0 ?
+					psLINFBInfo->screen_size :
+					psLINFBInfo->fix.smem_len;
+
+	
+	if (FBSize == 0 || psLINFBInfo->fix.line_length == 0)
+	{
+		eError = OMAPLFB_ERROR_INVALID_DEVICE;
+		goto ErrorRelSem;
+	}
+
+	psLINFBOwner = psLINFBInfo->fbops->owner;
+	if (!try_module_get(psLINFBOwner))
+	{
+		printk(KERN_INFO DRIVER_PREFIX
+			": %s: Device %u: Couldn't get framebuffer module\n", __FUNCTION__, uiFBDevID);
+
+		goto ErrorRelSem;
+	}
+
+	if (psLINFBInfo->fbops->fb_open != NULL)
+	{
+		int res;
+
+		res = psLINFBInfo->fbops->fb_open(psLINFBInfo, 0);
+		if (res != 0)
+		{
+			printk(KERN_INFO DRIVER_PREFIX
+				" %s: Device %u: Couldn't open framebuffer(%d)\n", __FUNCTION__, uiFBDevID, res);
+
+			goto ErrorModPut;
+		}
+	}
+
+	psDevInfo->psLINFBInfo = psLINFBInfo;
+
+	ulLCM = LCM(psLINFBInfo->fix.line_length, OMAPLFB_PAGE_SIZE);
+
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer physical address: 0x%lx\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->fix.smem_start));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer virtual address: 0x%lx\n",
+			psDevInfo->uiFBDevID, (unsigned long)psLINFBInfo->screen_base));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer size: %lu\n",
+			psDevInfo->uiFBDevID, FBSize));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer virtual width: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->var.xres_virtual));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer virtual height: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->var.yres_virtual));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer width: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->var.xres));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer height: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->var.yres));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer stride: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->fix.line_length));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: LCM of stride and page size: %lu\n",
+			psDevInfo->uiFBDevID, ulLCM));
+
+	
+	psPVRFBInfo->sSysAddr.uiAddr = psLINFBInfo->fix.smem_start;
+	psPVRFBInfo->sCPUVAddr = psLINFBInfo->screen_base;
+
+	psPVRFBInfo->ulWidth = psLINFBInfo->var.xres;
+	psPVRFBInfo->ulHeight = psLINFBInfo->var.yres;
+	psPVRFBInfo->ulByteStride =  psLINFBInfo->fix.line_length;
+	psPVRFBInfo->ulFBSize = FBSize;
+	psPVRFBInfo->ulBufferSize = psPVRFBInfo->ulHeight * psPVRFBInfo->ulByteStride;
+	
+	psPVRFBInfo->ulRoundedBufferSize = RoundUpToMultiple(psPVRFBInfo->ulBufferSize, ulLCM);
+
+	if(psLINFBInfo->var.bits_per_pixel == 16)
+	{
+		if((psLINFBInfo->var.red.length == 5) &&
+			(psLINFBInfo->var.green.length == 6) && 
+			(psLINFBInfo->var.blue.length == 5) && 
+			(psLINFBInfo->var.red.offset == 11) &&
+			(psLINFBInfo->var.green.offset == 5) && 
+			(psLINFBInfo->var.blue.offset == 0) && 
+			(psLINFBInfo->var.red.msb_right == 0))
+		{
+			psPVRFBInfo->ePixelFormat = PVRSRV_PIXEL_FORMAT_RGB565;
+		}
+		else
+		{
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown FB format\n", __FUNCTION__, uiFBDevID);
+		}
+	}
+	else if(psLINFBInfo->var.bits_per_pixel == 32)
+	{
+		if((psLINFBInfo->var.red.length == 8) &&
+			(psLINFBInfo->var.green.length == 8) && 
+			(psLINFBInfo->var.blue.length == 8) && 
+			(psLINFBInfo->var.red.offset == 16) &&
+			(psLINFBInfo->var.green.offset == 8) && 
+			(psLINFBInfo->var.blue.offset == 0) && 
+			(psLINFBInfo->var.red.msb_right == 0))
+		{
+			psPVRFBInfo->ePixelFormat = PVRSRV_PIXEL_FORMAT_ARGB8888;
+		}
+		else
+		{
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown FB format\n", __FUNCTION__, uiFBDevID);
+		}
+	}	
+	else
+	{
+		printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown FB format\n", __FUNCTION__, uiFBDevID);
+	}
+
+	psDevInfo->sFBInfo.ulPhysicalWidthmm =
+		((int)psLINFBInfo->var.width  > 0) ? psLINFBInfo->var.width  : 90;
+
+	psDevInfo->sFBInfo.ulPhysicalHeightmm =
+		((int)psLINFBInfo->var.height > 0) ? psLINFBInfo->var.height : 54;
+
+	
+	psDevInfo->sFBInfo.sSysAddr.uiAddr = psPVRFBInfo->sSysAddr.uiAddr;
+	psDevInfo->sFBInfo.sCPUVAddr = psPVRFBInfo->sCPUVAddr;
+
+	eError = OMAPLFB_OK;
+	goto ErrorRelSem;
+
+ErrorModPut:
+	module_put(psLINFBOwner);
+ErrorRelSem:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_unlock();
+#else
+	release_console_sem();
+#endif
+
+	return eError;
+}
+
+static void OMAPLFBDeInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
+{
+	struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
+	struct module *psLINFBOwner;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_lock();
+#else
+	acquire_console_sem();
+#endif
+
+	psLINFBOwner = psLINFBInfo->fbops->owner;
+
+	if (psLINFBInfo->fbops->fb_release != NULL) 
+	{
+		(void) psLINFBInfo->fbops->fb_release(psLINFBInfo, 0);
+	}
+
+	module_put(psLINFBOwner);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_unlock();
+#else
+	release_console_sem();
+#endif
+}
+
+static OMAPLFB_DEVINFO *OMAPLFBInitDev(unsigned uiFBDevID)
+{
+	PFN_CMD_PROC	 	pfnCmdProcList[OMAPLFB_COMMAND_COUNT];
+	IMG_UINT32		aui32SyncCountList[OMAPLFB_COMMAND_COUNT][2];
+	OMAPLFB_DEVINFO		*psDevInfo = NULL;
+
+	
+	psDevInfo = (OMAPLFB_DEVINFO *)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_DEVINFO));
+
+	if(psDevInfo == NULL)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: Couldn't allocate device information structure\n", __FUNCTION__, uiFBDevID);
+
+		goto ErrorExit;
+	}
+
+	
+	memset(psDevInfo, 0, sizeof(OMAPLFB_DEVINFO));
+
+	psDevInfo->uiFBDevID = uiFBDevID;
+
+	
+	if(!(*gpfnGetPVRJTable)(&psDevInfo->sPVRJTable))
+	{
+		goto ErrorFreeDevInfo;
+	}
+
+	
+	if(OMAPLFBInitFBDev(psDevInfo) != OMAPLFB_OK)
+	{
+		
+		goto ErrorFreeDevInfo;
+	}
+
+	psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = (IMG_UINT32)(psDevInfo->sFBInfo.ulFBSize / psDevInfo->sFBInfo.ulRoundedBufferSize);
+	if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers != 0)
+	{
+		psDevInfo->sDisplayInfo.ui32MaxSwapChains = 1;
+		psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 1;
+	}
+
+	psDevInfo->sDisplayInfo.ui32PhysicalWidthmm = psDevInfo->sFBInfo.ulPhysicalWidthmm;
+	psDevInfo->sDisplayInfo.ui32PhysicalHeightmm = psDevInfo->sFBInfo.ulPhysicalHeightmm;
+
+	strncpy(psDevInfo->sDisplayInfo.szDisplayName, DISPLAY_DEVICE_NAME, MAX_DISPLAY_NAME_SIZE);
+
+	psDevInfo->sDisplayFormat.pixelformat = psDevInfo->sFBInfo.ePixelFormat;
+	psDevInfo->sDisplayDim.ui32Width      = (IMG_UINT32)psDevInfo->sFBInfo.ulWidth;
+	psDevInfo->sDisplayDim.ui32Height     = (IMG_UINT32)psDevInfo->sFBInfo.ulHeight;
+	psDevInfo->sDisplayDim.ui32ByteStride = (IMG_UINT32)psDevInfo->sFBInfo.ulByteStride;
+
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+		": Device %u: Maximum number of swap chain buffers: %u\n",
+		psDevInfo->uiFBDevID, psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers));
+
+	
+	psDevInfo->sSystemBuffer.sSysAddr = psDevInfo->sFBInfo.sSysAddr;
+	psDevInfo->sSystemBuffer.sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr;
+	psDevInfo->sSystemBuffer.psDevInfo = psDevInfo;
+
+	OMAPLFBInitBufferForSwap(&psDevInfo->sSystemBuffer);
+
+	
+
+	psDevInfo->sDCJTable.ui32TableSize = sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE);
+	psDevInfo->sDCJTable.pfnOpenDCDevice = OpenDCDevice;
+	psDevInfo->sDCJTable.pfnCloseDCDevice = CloseDCDevice;
+	psDevInfo->sDCJTable.pfnEnumDCFormats = EnumDCFormats;
+	psDevInfo->sDCJTable.pfnEnumDCDims = EnumDCDims;
+	psDevInfo->sDCJTable.pfnGetDCSystemBuffer = GetDCSystemBuffer;
+	psDevInfo->sDCJTable.pfnGetDCInfo = GetDCInfo;
+	psDevInfo->sDCJTable.pfnGetBufferAddr = GetDCBufferAddr;
+	psDevInfo->sDCJTable.pfnCreateDCSwapChain = CreateDCSwapChain;
+	psDevInfo->sDCJTable.pfnDestroyDCSwapChain = DestroyDCSwapChain;
+	psDevInfo->sDCJTable.pfnSetDCDstRect = SetDCDstRect;
+	psDevInfo->sDCJTable.pfnSetDCSrcRect = SetDCSrcRect;
+	psDevInfo->sDCJTable.pfnSetDCDstColourKey = SetDCDstColourKey;
+	psDevInfo->sDCJTable.pfnSetDCSrcColourKey = SetDCSrcColourKey;
+	psDevInfo->sDCJTable.pfnGetDCBuffers = GetDCBuffers;
+	psDevInfo->sDCJTable.pfnSwapToDCBuffer = SwapToDCBuffer;
+	psDevInfo->sDCJTable.pfnSwapToDCSystem = SwapToDCSystem;
+	psDevInfo->sDCJTable.pfnSetDCState = SetDCState;
+
+	
+	if(psDevInfo->sPVRJTable.pfnPVRSRVRegisterDCDevice(
+		&psDevInfo->sDCJTable,
+		&psDevInfo->uiPVRDevID) != PVRSRV_OK)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: PVR Services device registration failed\n", __FUNCTION__, uiFBDevID);
+
+		goto ErrorDeInitFBDev;
+	}
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+		": Device %u: PVR Device ID: %u\n",
+		psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID));
+	
+	
+	pfnCmdProcList[DC_FLIP_COMMAND] = ProcessFlip;
+
+	
+	aui32SyncCountList[DC_FLIP_COMMAND][0] = 0; 
+	aui32SyncCountList[DC_FLIP_COMMAND][1] = 2; 
+
+	
+
+
+
+	if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterCmdProcList(psDevInfo->uiPVRDevID,
+															&pfnCmdProcList[0],
+															aui32SyncCountList,
+															OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: Couldn't register command processing functions with PVR Services\n", __FUNCTION__, uiFBDevID);
+		goto ErrorUnregisterDevice;
+	}
+
+	OMAPLFBCreateSwapChainLockInit(psDevInfo);
+
+	OMAPLFBAtomicBoolInit(&psDevInfo->sBlanked, OMAPLFB_FALSE);
+	OMAPLFBAtomicIntInit(&psDevInfo->sBlankEvents, 0);
+	OMAPLFBAtomicBoolInit(&psDevInfo->sFlushCommands, OMAPLFB_FALSE);
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	OMAPLFBAtomicBoolInit(&psDevInfo->sEarlySuspendFlag, OMAPLFB_FALSE);
+#endif
+#if defined(SUPPORT_DRI_DRM)
+	OMAPLFBAtomicBoolInit(&psDevInfo->sLeaveVT, OMAPLFB_FALSE);
+#endif
+	return psDevInfo;
+
+ErrorUnregisterDevice:
+	(void)psDevInfo->sPVRJTable.pfnPVRSRVRemoveDCDevice(psDevInfo->uiPVRDevID);
+ErrorDeInitFBDev:
+	OMAPLFBDeInitFBDev(psDevInfo);
+ErrorFreeDevInfo:
+	OMAPLFBFreeKernelMem(psDevInfo);
+ErrorExit:
+	return NULL;
+}
+
+OMAPLFB_ERROR OMAPLFBInit(void)
+{
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+	unsigned uiDevicesFound = 0;
+
+	if(OMAPLFBGetLibFuncAddr ("PVRGetDisplayClassJTable", &gpfnGetPVRJTable) != OMAPLFB_OK)
+	{
+		return OMAPLFB_ERROR_INIT_FAILURE;
+	}
+
+	
+	for(i = uiMaxFBDevIDPlusOne; i-- != 0;)
+	{
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBInitDev(i);
+
+		if (psDevInfo != NULL)
+		{
+			
+			OMAPLFBSetDevInfoPtr(psDevInfo->uiFBDevID, psDevInfo);
+			uiDevicesFound++;
+		}
+	}
+
+	return (uiDevicesFound != 0) ? OMAPLFB_OK : OMAPLFB_ERROR_INIT_FAILURE;
+}
+
+static OMAPLFB_BOOL OMAPLFBDeInitDev(OMAPLFB_DEVINFO *psDevInfo)
+{
+	PVRSRV_DC_DISP2SRV_KMJTABLE *psPVRJTable = &psDevInfo->sPVRJTable;
+
+	OMAPLFBCreateSwapChainLockDeInit(psDevInfo);
+
+	OMAPLFBAtomicBoolDeInit(&psDevInfo->sBlanked);
+	OMAPLFBAtomicIntDeInit(&psDevInfo->sBlankEvents);
+	OMAPLFBAtomicBoolDeInit(&psDevInfo->sFlushCommands);
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	OMAPLFBAtomicBoolDeInit(&psDevInfo->sEarlySuspendFlag);
+#endif
+#if defined(SUPPORT_DRI_DRM)
+	OMAPLFBAtomicBoolDeInit(&psDevInfo->sLeaveVT);
+#endif
+	psPVRJTable = &psDevInfo->sPVRJTable;
+
+	if (psPVRJTable->pfnPVRSRVRemoveCmdProcList (psDevInfo->uiPVRDevID, OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: PVR Device %u: Couldn't unregister command processing functions\n", __FUNCTION__, psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID);
+		return OMAPLFB_FALSE;
+	}
+
+	
+	if (psPVRJTable->pfnPVRSRVRemoveDCDevice(psDevInfo->uiPVRDevID) != PVRSRV_OK)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: PVR Device %u: Couldn't remove device from PVR Services\n", __FUNCTION__, psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID);
+		return OMAPLFB_FALSE;
+	}
+	
+	OMAPLFBDeInitFBDev(psDevInfo);
+
+	OMAPLFBSetDevInfoPtr(psDevInfo->uiFBDevID, NULL);
+
+	
+	OMAPLFBFreeKernelMem(psDevInfo);
+
+	return OMAPLFB_TRUE;
+}
+
+OMAPLFB_ERROR OMAPLFBDeInit(void)
+{
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+	OMAPLFB_BOOL bError = OMAPLFB_FALSE;
+
+	for(i = 0; i < uiMaxFBDevIDPlusOne; i++)
+	{
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBGetDevInfoPtr(i);
+
+		if (psDevInfo != NULL)
+		{
+			bError |= !OMAPLFBDeInitDev(psDevInfo);
+		}
+	}
+
+	return (bError) ? OMAPLFB_ERROR_INIT_FAILURE : OMAPLFB_OK;
+}
+
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_linux.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_linux.c
new file mode 100644
index 0000000..248e964
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_linux.c
@@ -0,0 +1,781 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+#ifndef AUTOCONF_INCLUDED
+#include <linux/config.h>
+#endif
+#endif
+
+
+#include <asm/atomic.h>
+
+#if defined(SUPPORT_DRI_DRM)
+#include <drm/drmP.h>
+#else
+#include <linux/module.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/hardirq.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/omapfb.h>
+#include <linux/mutex.h>
+
+# include <plat/vrfb.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+#define PVR_OMAPFB3_NEEDS_PLAT_VRFB_H
+#endif
+
+#if defined(PVR_OMAPFB3_NEEDS_PLAT_VRFB_H)
+# include <plat/vrfb.h>
+#else
+# if defined(PVR_OMAPFB3_NEEDS_MACH_VRFB_H)
+#  include <mach/vrfb.h>
+# endif
+#endif
+
+#if defined(DEBUG)
+#define	PVR_DEBUG DEBUG
+#undef DEBUG
+#endif
+#include <omapfb/omapfb.h>
+#if defined(DEBUG)
+#undef DEBUG
+#endif
+#if defined(PVR_DEBUG)
+#define	DEBUG PVR_DEBUG
+#undef PVR_DEBUG
+#endif
+
+#include "img_defs.h"
+#include "servicesext.h"
+#include "kerneldisplay.h"
+#include "omaplfb.h"
+#include "pvrmodule.h"
+#if defined(SUPPORT_DRI_DRM)
+#include "pvr_drm.h"
+#include "3rdparty_dc_drm_shared.h"
+#endif
+
+#if !defined(PVR_LINUX_USING_WORKQUEUES)
+#error "PVR_LINUX_USING_WORKQUEUES must be defined"
+#endif
+
+MODULE_SUPPORTED_DEVICE(DEVNAME);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+#define OMAP_DSS_DRIVER(drv, dev) struct omap_dss_driver *drv = (dev) != NULL ? (dev)->driver : NULL
+#define OMAP_DSS_MANAGER(man, dev) struct omap_overlay_manager *man = (dev) != NULL ? (dev)->manager : NULL
+#define	WAIT_FOR_VSYNC(man)	((man)->wait_for_vsync)
+#else
+#define OMAP_DSS_DRIVER(drv, dev) struct omap_dss_device *drv = (dev)
+#define OMAP_DSS_MANAGER(man, dev) struct omap_dss_device *man = (dev)
+#define	WAIT_FOR_VSYNC(man)	((man)->wait_vsync)
+#endif
+
+
+void *OMAPLFBAllocKernelMem(unsigned long ulSize)
+{
+	return kmalloc(ulSize, GFP_KERNEL);
+}
+
+void OMAPLFBFreeKernelMem(void *pvMem)
+{
+	kfree(pvMem);
+}
+
+void OMAPLFBCreateSwapChainLockInit(OMAPLFB_DEVINFO *psDevInfo)
+{
+	mutex_init(&psDevInfo->sCreateSwapChainMutex);
+}
+
+void OMAPLFBCreateSwapChainLockDeInit(OMAPLFB_DEVINFO *psDevInfo)
+{
+	mutex_destroy(&psDevInfo->sCreateSwapChainMutex);
+}
+
+void OMAPLFBCreateSwapChainLock(OMAPLFB_DEVINFO *psDevInfo)
+{
+	mutex_lock(&psDevInfo->sCreateSwapChainMutex);
+}
+
+void OMAPLFBCreateSwapChainUnLock(OMAPLFB_DEVINFO *psDevInfo)
+{
+	mutex_unlock(&psDevInfo->sCreateSwapChainMutex);
+}
+
+void OMAPLFBAtomicBoolInit(OMAPLFB_ATOMIC_BOOL *psAtomic, OMAPLFB_BOOL bVal)
+{
+	atomic_set(psAtomic, (int)bVal);
+}
+
+void OMAPLFBAtomicBoolDeInit(OMAPLFB_ATOMIC_BOOL *psAtomic)
+{
+}
+
+void OMAPLFBAtomicBoolSet(OMAPLFB_ATOMIC_BOOL *psAtomic, OMAPLFB_BOOL bVal)
+{
+	atomic_set(psAtomic, (int)bVal);
+}
+
+OMAPLFB_BOOL OMAPLFBAtomicBoolRead(OMAPLFB_ATOMIC_BOOL *psAtomic)
+{
+	return (OMAPLFB_BOOL)atomic_read(psAtomic);
+}
+
+void OMAPLFBAtomicIntInit(OMAPLFB_ATOMIC_INT *psAtomic, int iVal)
+{
+	atomic_set(psAtomic, iVal);
+}
+
+void OMAPLFBAtomicIntDeInit(OMAPLFB_ATOMIC_INT *psAtomic)
+{
+}
+
+void OMAPLFBAtomicIntSet(OMAPLFB_ATOMIC_INT *psAtomic, int iVal)
+{
+	atomic_set(psAtomic, iVal);
+}
+
+int OMAPLFBAtomicIntRead(OMAPLFB_ATOMIC_INT *psAtomic)
+{
+	return atomic_read(psAtomic);
+}
+
+void OMAPLFBAtomicIntInc(OMAPLFB_ATOMIC_INT *psAtomic)
+{
+	atomic_inc(psAtomic);
+}
+
+OMAPLFB_ERROR OMAPLFBGetLibFuncAddr (char *szFunctionName, PFN_DC_GET_PVRJTABLE *ppfnFuncTable)
+{
+	if(strcmp("PVRGetDisplayClassJTable", szFunctionName) != 0)
+	{
+		return (OMAPLFB_ERROR_INVALID_PARAMS);
+	}
+
+	
+	*ppfnFuncTable = PVRGetDisplayClassJTable;
+
+	return (OMAPLFB_OK);
+}
+
+void OMAPLFBQueueBufferForSwap(OMAPLFB_SWAPCHAIN *psSwapChain, OMAPLFB_BUFFER *psBuffer)
+{
+	int res = queue_work(psSwapChain->psWorkQueue, &psBuffer->sWork);
+
+	if (res == 0)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Buffer already on work queue\n", __FUNCTION__, psSwapChain->uiFBDevID);
+	}
+}
+
+static void WorkQueueHandler(struct work_struct *psWork)
+{
+	OMAPLFB_BUFFER *psBuffer = container_of(psWork, OMAPLFB_BUFFER, sWork);
+
+	OMAPLFBSwapHandler(psBuffer);
+}
+
+OMAPLFB_ERROR OMAPLFBCreateSwapQueue(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34))
+        psSwapChain->psWorkQueue = __create_workqueue(DEVNAME, 1, 1, 1);
+#else	
+	psSwapChain->psWorkQueue = create_workqueue(DEVNAME);
+#endif
+	if (psSwapChain->psWorkQueue == NULL)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: create_singlethreaded_workqueue failed\n", __FUNCTION__, psSwapChain->uiFBDevID);
+
+		return (OMAPLFB_ERROR_INIT_FAILURE);
+	}
+
+	return (OMAPLFB_OK);
+}
+
+void OMAPLFBInitBufferForSwap(OMAPLFB_BUFFER *psBuffer)
+{
+	INIT_WORK(&psBuffer->sWork, WorkQueueHandler);
+}
+
+void OMAPLFBDestroySwapQueue(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+	destroy_workqueue(psSwapChain->psWorkQueue);
+}
+
+void OMAPLFBFlip(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_BUFFER *psBuffer)
+{
+	struct fb_var_screeninfo sFBVar;
+	int res;
+	unsigned long ulYResVirtual;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_lock();
+#else
+	acquire_console_sem();
+#endif
+
+	sFBVar = psDevInfo->psLINFBInfo->var;
+
+	sFBVar.xoffset = 0;
+	sFBVar.yoffset = psBuffer->ulYOffset;
+
+	ulYResVirtual = psBuffer->ulYOffset + sFBVar.yres;
+
+	
+	if (sFBVar.xres_virtual != sFBVar.xres || sFBVar.yres_virtual < ulYResVirtual)
+	{
+		sFBVar.xres_virtual = sFBVar.xres;
+		sFBVar.yres_virtual = ulYResVirtual;
+
+		sFBVar.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
+
+		res = fb_set_var(psDevInfo->psLINFBInfo, &sFBVar);
+		if (res != 0)
+		{
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: fb_set_var failed (Y Offset: %lu, Error: %d)\n", __FUNCTION__, psDevInfo->uiFBDevID, psBuffer->ulYOffset, res);
+		}
+	}
+	else
+	{
+		res = fb_pan_display(psDevInfo->psLINFBInfo, &sFBVar);
+		if (res != 0)
+		{
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: fb_pan_display failed (Y Offset: %lu, Error: %d)\n", __FUNCTION__, psDevInfo->uiFBDevID, psBuffer->ulYOffset, res);
+		}
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_unlock();
+#else
+	release_console_sem();
+#endif
+}
+
+OMAPLFB_UPDATE_MODE OMAPLFBGetUpdateMode(OMAPLFB_DEVINFO *psDevInfo)
+{
+	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
+	OMAP_DSS_DRIVER(psDSSDrv, psDSSDev);
+        if (psDSSDrv == NULL || psDSSDev == NULL)
+        {
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: No DSS device\n", __FUNCTION__, psDevInfo->uiFBDevID));
+        }
+	enum omap_dss_update_mode eMode;
+
+	if (psDSSDrv->get_update_mode == NULL)
+	{
+//		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Can't get update mode\n", __FUNCTION__, psDevInfo->uiFBDevID));
+		return OMAPLFB_UPDATE_MODE_AUTO;
+//		return OMAPLFB_UPDATE_MODE_UNDEFINED;
+	}
+
+	eMode = psDSSDrv->get_update_mode(psDSSDev);
+	switch(eMode)
+	{
+		case OMAP_DSS_UPDATE_AUTO:
+			return OMAPLFB_UPDATE_MODE_AUTO;
+		case OMAP_DSS_UPDATE_MANUAL:
+			return OMAPLFB_UPDATE_MODE_MANUAL;
+		case OMAP_DSS_UPDATE_DISABLED:
+			return OMAPLFB_UPDATE_MODE_DISABLED;
+		default:
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown update mode (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eMode));
+			break;
+	}
+
+	return OMAPLFB_UPDATE_MODE_UNDEFINED;
+//return OMAPLFB_UPDATE_MODE_AUTO;
+}
+
+OMAPLFB_BOOL OMAPLFBSetUpdateMode(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_UPDATE_MODE eMode)
+{
+	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
+	OMAP_DSS_DRIVER(psDSSDrv, psDSSDev);
+	enum omap_dss_update_mode eDSSMode;
+	int res;
+
+	if (psDSSDrv == NULL || psDSSDrv->set_update_mode == NULL)
+	{
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Can't set update mode\n", __FUNCTION__, psDevInfo->uiFBDevID));
+		return OMAPLFB_FALSE;
+	}
+
+	switch(eMode)
+	{
+		case OMAPLFB_UPDATE_MODE_AUTO:
+			eDSSMode = OMAP_DSS_UPDATE_AUTO;
+			break;
+		case OMAPLFB_UPDATE_MODE_MANUAL:
+			eDSSMode = OMAP_DSS_UPDATE_MANUAL;
+			break;
+		case OMAPLFB_UPDATE_MODE_DISABLED:
+			eDSSMode = OMAP_DSS_UPDATE_DISABLED;
+			break;
+		default:
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown update mode (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eMode));
+			return OMAPLFB_FALSE;
+	}
+
+	res = psDSSDrv->set_update_mode(psDSSDev, eDSSMode);
+	if (res != 0)
+	{
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: set_update_mode failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res));
+	}
+
+	return (res == 0);
+//return 1;
+}
+
+OMAPLFB_BOOL OMAPLFBWaitForVSync(OMAPLFB_DEVINFO *psDevInfo)
+{
+	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
+	OMAP_DSS_MANAGER(psDSSMan, psDSSDev);
+
+	if (psDSSMan != NULL && WAIT_FOR_VSYNC(psDSSMan) != NULL)
+	{
+		int res = WAIT_FOR_VSYNC(psDSSMan)(psDSSMan);
+		if (res != 0)
+		{
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Wait for vsync failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res));
+			return OMAPLFB_FALSE;
+		}
+	}
+
+	return OMAPLFB_TRUE;
+}
+
+OMAPLFB_BOOL OMAPLFBManualSync(OMAPLFB_DEVINFO *psDevInfo)
+{
+	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
+	OMAP_DSS_DRIVER(psDSSDrv, psDSSDev);
+
+	if (psDSSDrv != NULL && psDSSDrv->sync != NULL)
+	{
+		int res = psDSSDrv->sync(psDSSDev);
+		if (res != 0)
+		{
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Sync failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res);
+			return OMAPLFB_FALSE;
+		}
+	}
+	return OMAPLFB_TRUE;
+}
+
+OMAPLFB_BOOL OMAPLFBCheckModeAndSync(OMAPLFB_DEVINFO *psDevInfo)
+{
+	OMAPLFB_UPDATE_MODE eMode = OMAPLFBGetUpdateMode(psDevInfo);
+
+	switch(eMode)
+	{
+		case OMAPLFB_UPDATE_MODE_AUTO:
+		case OMAPLFB_UPDATE_MODE_MANUAL:
+			return OMAPLFBManualSync(psDevInfo);
+		default:
+			break;
+	}
+
+	return OMAPLFB_TRUE;
+}
+
+static int OMAPLFBFrameBufferEvents(struct notifier_block *psNotif,
+                             unsigned long event, void *data)
+{
+	OMAPLFB_DEVINFO *psDevInfo;
+	struct fb_event *psFBEvent = (struct fb_event *)data;
+	struct fb_info *psFBInfo = psFBEvent->info;
+	OMAPLFB_BOOL bBlanked;
+
+	
+	if (event != FB_EVENT_BLANK)
+	{
+		return 0;
+	}
+
+	bBlanked = (*(IMG_INT *)psFBEvent->data != 0) ? OMAPLFB_TRUE: OMAPLFB_FALSE;
+
+	psDevInfo = OMAPLFBGetDevInfoPtr(psFBInfo->node);
+
+#if 0
+	if (psDevInfo != NULL)
+	{
+		if (bBlanked)
+		{
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Blank event received\n", __FUNCTION__, psDevInfo->uiFBDevID));
+		}
+		else
+		{
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unblank event received\n", __FUNCTION__, psDevInfo->uiFBDevID));
+		}
+	}
+	else
+	{
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Blank/Unblank event for unknown framebuffer\n", __FUNCTION__, psFBInfo->node));
+	}
+#endif
+
+	if (psDevInfo != NULL)
+	{
+		OMAPLFBAtomicBoolSet(&psDevInfo->sBlanked, bBlanked);
+		OMAPLFBAtomicIntInc(&psDevInfo->sBlankEvents);
+	}
+
+	return 0;
+}
+
+OMAPLFB_ERROR OMAPLFBUnblankDisplay(OMAPLFB_DEVINFO *psDevInfo)
+{
+	int res;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_lock();
+#else
+	acquire_console_sem();
+#endif
+	res = fb_blank(psDevInfo->psLINFBInfo, 0);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_unlock();
+#else
+	release_console_sem();
+#endif
+	if (res != 0 && res != -EINVAL)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: fb_blank failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res);
+		return (OMAPLFB_ERROR_GENERIC);
+	}
+
+	return (OMAPLFB_OK);
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+
+static void OMAPLFBBlankDisplay(OMAPLFB_DEVINFO *psDevInfo)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_lock();
+#else
+	acquire_console_sem();
+#endif
+	fb_blank(psDevInfo->psLINFBInfo, 1);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_unlock();
+#else
+	release_console_sem();
+#endif
+}
+
+static void OMAPLFBEarlySuspendHandler(struct early_suspend *h)
+{
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+
+	for (i=0; i < uiMaxFBDevIDPlusOne; i++)
+	{
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBGetDevInfoPtr(i);
+
+		if (psDevInfo != NULL)
+		{
+			OMAPLFBAtomicBoolSet(&psDevInfo->sEarlySuspendFlag, OMAPLFB_TRUE);
+			OMAPLFBBlankDisplay(psDevInfo);
+		}
+	}
+}
+
+static void OMAPLFBEarlyResumeHandler(struct early_suspend *h)
+{
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+
+	for (i=0; i < uiMaxFBDevIDPlusOne; i++)
+	{
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBGetDevInfoPtr(i);
+
+		if (psDevInfo != NULL)
+		{
+			OMAPLFBUnblankDisplay(psDevInfo);
+			OMAPLFBAtomicBoolSet(&psDevInfo->sEarlySuspendFlag, OMAPLFB_FALSE);
+		}
+	}
+}
+
+#endif 
+
+OMAPLFB_ERROR OMAPLFBEnableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
+{
+	int                res;
+	OMAPLFB_ERROR         eError;
+
+	
+	memset(&psDevInfo->sLINNotifBlock, 0, sizeof(psDevInfo->sLINNotifBlock));
+
+	psDevInfo->sLINNotifBlock.notifier_call = OMAPLFBFrameBufferEvents;
+
+	OMAPLFBAtomicBoolSet(&psDevInfo->sBlanked, OMAPLFB_FALSE);
+	OMAPLFBAtomicIntSet(&psDevInfo->sBlankEvents, 0);
+
+	res = fb_register_client(&psDevInfo->sLINNotifBlock);
+	if (res != 0)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: fb_register_client failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res);
+
+		return (OMAPLFB_ERROR_GENERIC);
+	}
+
+	eError = OMAPLFBUnblankDisplay(psDevInfo);
+	if (eError != OMAPLFB_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: UnblankDisplay failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eError);
+		return eError;
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	psDevInfo->sEarlySuspend.suspend = OMAPLFBEarlySuspendHandler;
+	psDevInfo->sEarlySuspend.resume = OMAPLFBEarlyResumeHandler;
+	psDevInfo->sEarlySuspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	register_early_suspend(&psDevInfo->sEarlySuspend);
+#endif
+
+	return (OMAPLFB_OK);
+}
+
+OMAPLFB_ERROR OMAPLFBDisableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
+{
+	int res;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&psDevInfo->sEarlySuspend);
+#endif
+
+	
+	res = fb_unregister_client(&psDevInfo->sLINNotifBlock);
+	if (res != 0)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: fb_unregister_client failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res);
+		return (OMAPLFB_ERROR_GENERIC);
+	}
+
+	OMAPLFBAtomicBoolSet(&psDevInfo->sBlanked, OMAPLFB_FALSE);
+
+	return (OMAPLFB_OK);
+}
+
+#if defined(SUPPORT_DRI_DRM) && defined(PVR_DISPLAY_CONTROLLER_DRM_IOCTL)
+static OMAPLFB_DEVINFO *OMAPLFBPVRDevIDToDevInfo(unsigned uiPVRDevID)
+{
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+
+	for (i=0; i < uiMaxFBDevIDPlusOne; i++)
+	{
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBGetDevInfoPtr(i);
+
+		if (psDevInfo->uiPVRDevID == uiPVRDevID)
+		{
+			return psDevInfo;
+		}
+	}
+
+	printk(KERN_WARNING DRIVER_PREFIX
+		": %s: PVR Device %u: Couldn't find device\n", __FUNCTION__, uiPVRDevID);
+
+	return NULL;
+}
+
+int PVR_DRM_MAKENAME(omaplfb, _Ioctl)(struct drm_device unref__ *dev, void *arg, struct drm_file unref__ *pFile)
+{
+	uint32_t *puiArgs;
+	uint32_t uiCmd;
+	unsigned uiPVRDevID;
+	int ret = 0;
+	OMAPLFB_DEVINFO *psDevInfo;
+
+	if (arg == NULL)
+	{
+		return -EFAULT;
+	}
+
+	puiArgs = (uint32_t *)arg;
+	uiCmd = puiArgs[PVR_DRM_DISP_ARG_CMD];
+	uiPVRDevID = puiArgs[PVR_DRM_DISP_ARG_DEV];
+
+	psDevInfo = OMAPLFBPVRDevIDToDevInfo(uiPVRDevID);
+	if (psDevInfo == NULL)
+	{
+		return -EINVAL;
+	}
+
+
+	switch (uiCmd)
+	{
+		case PVR_DRM_DISP_CMD_LEAVE_VT:
+		case PVR_DRM_DISP_CMD_ENTER_VT:
+		{
+			OMAPLFB_BOOL bLeaveVT = (uiCmd == PVR_DRM_DISP_CMD_LEAVE_VT);
+			DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: PVR Device %u: %s\n",
+				__FUNCTION__, uiPVRDevID,
+				bLeaveVT ? "Leave VT" : "Enter VT"));
+
+			OMAPLFBCreateSwapChainLock(psDevInfo);
+			
+			OMAPLFBAtomicBoolSet(&psDevInfo->sLeaveVT, bLeaveVT);
+			if (psDevInfo->psSwapChain != NULL)
+			{
+				flush_workqueue(psDevInfo->psSwapChain->psWorkQueue);
+
+				if (bLeaveVT)
+				{
+					OMAPLFBFlip(psDevInfo, &psDevInfo->sSystemBuffer);
+					(void) OMAPLFBCheckModeAndSync(psDevInfo);
+				}
+			}
+
+			OMAPLFBCreateSwapChainUnLock(psDevInfo);
+			(void) OMAPLFBUnblankDisplay(psDevInfo);
+			break;
+		}
+		case PVR_DRM_DISP_CMD_ON:
+		case PVR_DRM_DISP_CMD_STANDBY:
+		case PVR_DRM_DISP_CMD_SUSPEND:
+		case PVR_DRM_DISP_CMD_OFF:
+		{
+			int iFBMode;
+#if defined(DEBUG)
+			{
+				const char *pszMode;
+				switch(uiCmd)
+				{
+					case PVR_DRM_DISP_CMD_ON:
+						pszMode = "On";
+						break;
+					case PVR_DRM_DISP_CMD_STANDBY:
+						pszMode = "Standby";
+						break;
+					case PVR_DRM_DISP_CMD_SUSPEND:
+						pszMode = "Suspend";
+						break;
+					case PVR_DRM_DISP_CMD_OFF:
+						pszMode = "Off";
+						break;
+					default:
+						pszMode = "(Unknown Mode)";
+						break;
+				}
+				printk (KERN_WARNING DRIVER_PREFIX ": %s: PVR Device %u: Display %s\n",
+				__FUNCTION__, uiPVRDevID, pszMode);
+			}
+#endif
+			switch(uiCmd)
+			{
+				case PVR_DRM_DISP_CMD_ON:
+					iFBMode = FB_BLANK_UNBLANK;
+					break;
+				case PVR_DRM_DISP_CMD_STANDBY:
+					iFBMode = FB_BLANK_HSYNC_SUSPEND;
+					break;
+				case PVR_DRM_DISP_CMD_SUSPEND:
+					iFBMode = FB_BLANK_VSYNC_SUSPEND;
+					break;
+				case PVR_DRM_DISP_CMD_OFF:
+					iFBMode = FB_BLANK_POWERDOWN;
+					break;
+				default:
+					return -EINVAL;
+			}
+
+			OMAPLFBCreateSwapChainLock(psDevInfo);
+
+			if (psDevInfo->psSwapChain != NULL)
+			{
+				flush_workqueue(psDevInfo->psSwapChain->psWorkQueue);
+			}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        		console_lock();
+#else
+			acquire_console_sem();
+#endif
+			ret = fb_blank(psDevInfo->psLINFBInfo, iFBMode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        		console_unlock();
+#else
+			release_console_sem();
+#endif
+
+			OMAPLFBCreateSwapChainUnLock(psDevInfo);
+
+			break;
+		}
+		default:
+		{
+			ret = -EINVAL;
+			break;
+		}
+	}
+
+	return ret;
+}
+#endif
+
+#if defined(SUPPORT_DRI_DRM)
+int PVR_DRM_MAKENAME(omaplfb, _Init)(struct drm_device unref__ *dev)
+#else
+static int __init OMAPLFB_Init(void)
+#endif
+{
+	if(OMAPLFBInit() != OMAPLFB_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: OMAPLFBInit failed\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	return 0;
+
+}
+
+#if defined(SUPPORT_DRI_DRM)
+void PVR_DRM_MAKENAME(omaplfb, _Cleanup)(struct drm_device unref__ *dev)
+#else
+static void __exit OMAPLFB_Cleanup(void)
+#endif
+{    
+	if(OMAPLFBDeInit() != OMAPLFB_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: OMAPLFBDeInit failed\n", __FUNCTION__);
+	}
+}
+
+#if !defined(SUPPORT_DRI_DRM)
+late_initcall(OMAPLFB_Init);
+module_exit(OMAPLFB_Cleanup);
+#endif
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/3rdparty_dc_drm_shared.h b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/3rdparty_dc_drm_shared.h
new file mode 100644
index 0000000..9b6d240
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/3rdparty_dc_drm_shared.h
@@ -0,0 +1,45 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef __3RDPARTY_DC_DRM_SHARED_H__
+#define __3RDPARTY_DC_DRM_SHARED_H__
+#if defined(SUPPORT_DRI_DRM)
+
+#define	PVR_DRM_DISP_CMD_ENTER_VT	1
+#define	PVR_DRM_DISP_CMD_LEAVE_VT	2
+
+#define	PVR_DRM_DISP_CMD_ON		3
+#define	PVR_DRM_DISP_CMD_STANDBY	4
+#define	PVR_DRM_DISP_CMD_SUSPEND	5
+#define	PVR_DRM_DISP_CMD_OFF		6
+
+#define	PVR_DRM_DISP_ARG_CMD		0
+#define	PVR_DRM_DISP_ARG_DEV		1
+#define	PVR_DRM_DISP_NUM_ARGS		2
+
+#endif	
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/Kbuild b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/Kbuild
new file mode 100644
index 0000000..5e1cc8e
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/Kbuild
@@ -0,0 +1,32 @@
+SYS_USING_INTERRUPTS = 1
+SUPPORT_OMAP3430_OMAPFB3 =1
+SUPPORT_TI_DSS_FW = 0
+PVR_LINUX_USING_WORKQUEUES = 1
+
+SYS_CFLAGS.$(SYS_USING_INTERRUPTS)                      += -DSYS_USING_INTERRUPTS
+SYS_CFLAGS.$(SUPPORT_OMAP3430_OMAPFB3)                         += -DSUPPORT_OMAP3430_OMAPFB3
+SYS_CFLAGS.$(SUPPORT_TI_DSS_FW)                         += -DSUPPORT_TI_DSS_FW
+SYS_CFLAGS.$(PVR_LINUX_USING_WORKQUEUES)             += -DPVR_LINUX_USING_WORKQUEUES
+SYS_CFLAGS += -DDISPLAY_CONTROLLER=omaplfb
+
+ccflags-y += -DLINUX 
+ccflags-y += -DCONFIG_OMAP2_DSS
+ccflags-y += -Idrivers/staging/omap3-sgx/include4
+ccflags-y += -Idrivers/staging/omap3-sgx/services4/include
+ccflags-y += -Idrivers/staging/omap3-sgx/services4/system/$(PVR_SYSTEM)
+ccflags-y += -Idrivers/video/omap2
+ccflags-y += -Idrivers/staging/omap3-sgx/services4/system/include
+ccflags-y += $(SYS_CFLAGS.1)
+
+ifneq ($(FBDEV),no)
+EXTRA_CFLAGS += -DFBDEV_PRESENT
+endif
+
+ifeq ($(SUPPORT_XORG),1)
+EXTRA_CFLAGS += -DSUPPORT_DRI_DRM
+EXTRA_CFLAGS += -DPVR_DISPLAY_CONTROLLER_DRM_IOCTL
+endif
+
+
+obj-m := omaplfb.o
+omaplfb-y := omaplfb_displayclass.o omaplfb_linux.o
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/kbuild/Makefile b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/kbuild/Makefile
new file mode 100644
index 0000000..f52617a
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/kbuild/Makefile
@@ -0,0 +1,36 @@
+#
+# Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+# 
+# This program is distributed in the hope it will be useful but, except 
+# as otherwise stated in writing, without any warranty; without even the 
+# implied warranty of merchantability or fitness for a particular purpose. 
+# See the GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+# 
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Imagination Technologies Ltd. <gpl-support@imgtec.com>
+# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+# 
+#
+
+MODULE		= $(DISPLAY_CONTROLLER)
+
+INCLUDES =
+
+SOURCES	=
+
+SYM_VERS_DEPS = $(EURASIAROOT)/services4/srvkm/env/linux
+
+include $(EURASIAROOT)/services4/$(DISPLAY_CONTROLLER_DIR)/makefile.linux.common
+
+include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/omaplfb.h b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/omaplfb.h
new file mode 100644
index 0000000..f202e1e
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/omaplfb.h
@@ -0,0 +1,271 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef __OMAPLFB_H__
+#define __OMAPLFB_H__
+
+#include <linux/version.h>
+
+#include <asm/atomic.h>
+
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/fb.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/notifier.h>
+#include <linux/mutex.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#define unref__ __attribute__ ((unused))
+
+typedef void *       OMAPLFB_HANDLE;
+
+typedef bool OMAPLFB_BOOL, *OMAPLFB_PBOOL;
+#define	OMAPLFB_FALSE false
+#define OMAPLFB_TRUE true
+
+typedef	atomic_t	OMAPLFB_ATOMIC_BOOL;
+
+typedef atomic_t	OMAPLFB_ATOMIC_INT;
+
+typedef struct OMAPLFB_BUFFER_TAG
+{
+	struct OMAPLFB_BUFFER_TAG	*psNext;
+	struct OMAPLFB_DEVINFO_TAG	*psDevInfo;
+
+	struct work_struct sWork;
+
+	
+	unsigned long		     	ulYOffset;
+
+	
+	
+	IMG_SYS_PHYADDR              	sSysAddr;
+	IMG_CPU_VIRTADDR             	sCPUVAddr;
+	PVRSRV_SYNC_DATA            	*psSyncData;
+
+	OMAPLFB_HANDLE      		hCmdComplete;
+	unsigned long    		ulSwapInterval;
+} OMAPLFB_BUFFER;
+
+typedef struct OMAPLFB_SWAPCHAIN_TAG
+{
+	
+	unsigned int			uiSwapChainID;
+
+	
+	unsigned long       		ulBufferCount;
+
+	
+	OMAPLFB_BUFFER     		*psBuffer;
+
+	
+	struct workqueue_struct   	*psWorkQueue;
+
+	
+	OMAPLFB_BOOL			bNotVSynced;
+
+	
+	int				iBlankEvents;
+
+	
+	unsigned int            	uiFBDevID;
+} OMAPLFB_SWAPCHAIN;
+
+typedef struct OMAPLFB_FBINFO_TAG
+{
+	unsigned long       ulFBSize;
+	unsigned long       ulBufferSize;
+	unsigned long       ulRoundedBufferSize;
+	unsigned long       ulWidth;
+	unsigned long       ulHeight;
+	unsigned long       ulByteStride;
+	unsigned long       ulPhysicalWidthmm;
+	unsigned long       ulPhysicalHeightmm;
+
+	
+	
+	IMG_SYS_PHYADDR     sSysAddr;
+	IMG_CPU_VIRTADDR    sCPUVAddr;
+
+	
+	PVRSRV_PIXEL_FORMAT ePixelFormat;
+}OMAPLFB_FBINFO;
+
+typedef struct OMAPLFB_DEVINFO_TAG
+{
+	
+	unsigned int            uiFBDevID;
+
+	
+	unsigned int            uiPVRDevID;
+
+	
+	struct mutex		sCreateSwapChainMutex;
+
+	
+	OMAPLFB_BUFFER          sSystemBuffer;
+
+	
+	PVRSRV_DC_DISP2SRV_KMJTABLE	sPVRJTable;
+	
+	
+	PVRSRV_DC_SRV2DISP_KMJTABLE	sDCJTable;
+
+	
+	OMAPLFB_FBINFO          sFBInfo;
+
+	
+	OMAPLFB_SWAPCHAIN      *psSwapChain;
+
+	
+	unsigned int		uiSwapChainID;
+
+	
+	OMAPLFB_ATOMIC_BOOL     sFlushCommands;
+
+	
+	struct fb_info         *psLINFBInfo;
+
+	
+	struct notifier_block   sLINNotifBlock;
+
+	
+	
+
+	
+	IMG_DEV_VIRTADDR	sDisplayDevVAddr;
+
+	DISPLAY_INFO            sDisplayInfo;
+
+	
+	DISPLAY_FORMAT          sDisplayFormat;
+	
+	
+	DISPLAY_DIMS            sDisplayDim;
+
+	
+	OMAPLFB_ATOMIC_BOOL	sBlanked;
+
+	
+	OMAPLFB_ATOMIC_INT	sBlankEvents;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	
+	OMAPLFB_ATOMIC_BOOL	sEarlySuspendFlag;
+
+	struct early_suspend    sEarlySuspend;
+#endif
+
+#if defined(SUPPORT_DRI_DRM)
+	OMAPLFB_ATOMIC_BOOL     sLeaveVT;
+#endif
+
+}  OMAPLFB_DEVINFO;
+
+#define	OMAPLFB_PAGE_SIZE 4096
+
+//#define DEBUG
+
+#ifdef	DEBUG
+#define	DEBUG_PRINTK(x) printk x
+#else
+#define	DEBUG_PRINTK(x)
+#endif
+
+#define DISPLAY_DEVICE_NAME "PowerVR OMAP Linux Display Driver"
+#define	DRVNAME	"omaplfb"
+#define	DEVNAME	DRVNAME
+#define	DRIVER_PREFIX DRVNAME
+
+typedef enum _OMAPLFB_ERROR_
+{
+	OMAPLFB_OK                             =  0,
+	OMAPLFB_ERROR_GENERIC                  =  1,
+	OMAPLFB_ERROR_OUT_OF_MEMORY            =  2,
+	OMAPLFB_ERROR_TOO_FEW_BUFFERS          =  3,
+	OMAPLFB_ERROR_INVALID_PARAMS           =  4,
+	OMAPLFB_ERROR_INIT_FAILURE             =  5,
+	OMAPLFB_ERROR_CANT_REGISTER_CALLBACK   =  6,
+	OMAPLFB_ERROR_INVALID_DEVICE           =  7,
+	OMAPLFB_ERROR_DEVICE_REGISTER_FAILED   =  8,
+	OMAPLFB_ERROR_SET_UPDATE_MODE_FAILED   =  9
+} OMAPLFB_ERROR;
+
+typedef enum _OMAPLFB_UPDATE_MODE_
+{
+	OMAPLFB_UPDATE_MODE_UNDEFINED			= 0,
+	OMAPLFB_UPDATE_MODE_MANUAL			= 1,
+	OMAPLFB_UPDATE_MODE_AUTO			= 2,
+	OMAPLFB_UPDATE_MODE_DISABLED			= 3
+} OMAPLFB_UPDATE_MODE;
+
+#ifndef UNREFERENCED_PARAMETER
+#define	UNREFERENCED_PARAMETER(param) (param) = (param)
+#endif
+
+OMAPLFB_ERROR OMAPLFBInit(void);
+OMAPLFB_ERROR OMAPLFBDeInit(void);
+
+OMAPLFB_DEVINFO *OMAPLFBGetDevInfoPtr(unsigned uiFBDevID);
+unsigned OMAPLFBMaxFBDevIDPlusOne(void);
+void *OMAPLFBAllocKernelMem(unsigned long ulSize);
+void OMAPLFBFreeKernelMem(void *pvMem);
+OMAPLFB_ERROR OMAPLFBGetLibFuncAddr(char *szFunctionName, PFN_DC_GET_PVRJTABLE *ppfnFuncTable);
+OMAPLFB_ERROR OMAPLFBCreateSwapQueue (OMAPLFB_SWAPCHAIN *psSwapChain);
+void OMAPLFBDestroySwapQueue(OMAPLFB_SWAPCHAIN *psSwapChain);
+void OMAPLFBInitBufferForSwap(OMAPLFB_BUFFER *psBuffer);
+void OMAPLFBSwapHandler(OMAPLFB_BUFFER *psBuffer);
+void OMAPLFBQueueBufferForSwap(OMAPLFB_SWAPCHAIN *psSwapChain, OMAPLFB_BUFFER *psBuffer);
+void OMAPLFBFlip(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_BUFFER *psBuffer);
+OMAPLFB_UPDATE_MODE OMAPLFBGetUpdateMode(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_BOOL OMAPLFBSetUpdateMode(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_UPDATE_MODE eMode);
+OMAPLFB_BOOL OMAPLFBWaitForVSync(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_BOOL OMAPLFBManualSync(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_BOOL OMAPLFBCheckModeAndSync(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_ERROR OMAPLFBUnblankDisplay(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_ERROR OMAPLFBEnableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_ERROR OMAPLFBDisableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBCreateSwapChainLockInit(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBCreateSwapChainLockDeInit(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBCreateSwapChainLock(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBCreateSwapChainUnLock(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBAtomicBoolInit(OMAPLFB_ATOMIC_BOOL *psAtomic, OMAPLFB_BOOL bVal);
+void OMAPLFBAtomicBoolDeInit(OMAPLFB_ATOMIC_BOOL *psAtomic);
+void OMAPLFBAtomicBoolSet(OMAPLFB_ATOMIC_BOOL *psAtomic, OMAPLFB_BOOL bVal);
+OMAPLFB_BOOL OMAPLFBAtomicBoolRead(OMAPLFB_ATOMIC_BOOL *psAtomic);
+void OMAPLFBAtomicIntInit(OMAPLFB_ATOMIC_INT *psAtomic, int iVal);
+void OMAPLFBAtomicIntDeInit(OMAPLFB_ATOMIC_INT *psAtomic);
+void OMAPLFBAtomicIntSet(OMAPLFB_ATOMIC_INT *psAtomic, int iVal);
+int OMAPLFBAtomicIntRead(OMAPLFB_ATOMIC_INT *psAtomic);
+void OMAPLFBAtomicIntInc(OMAPLFB_ATOMIC_INT *psAtomic);
+
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/omaplfb_displayclass.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/omaplfb_displayclass.c
new file mode 100644
index 0000000..67564f7
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/omaplfb_displayclass.c
@@ -0,0 +1,1259 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/fb.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/notifier.h>
+
+#include "img_defs.h"
+#include "servicesext.h"
+#include "kerneldisplay.h"
+#include "omaplfb.h"
+
+#define OMAPLFB_COMMAND_COUNT		1
+
+#define	OMAPLFB_VSYNC_SETTLE_COUNT	5
+
+#define	OMAPLFB_MAX_NUM_DEVICES		1 // FB_MAX
+#if (OMAPLFB_MAX_NUM_DEVICES > FB_MAX)
+#error "OMAPLFB_MAX_NUM_DEVICES must not be greater than FB_MAX"
+#endif
+
+static OMAPLFB_DEVINFO *gapsDevInfo[OMAPLFB_MAX_NUM_DEVICES];
+
+static PFN_DC_GET_PVRJTABLE gpfnGetPVRJTable = NULL;
+
+static inline unsigned long RoundUpToMultiple(unsigned long x, unsigned long y)
+{
+	unsigned long div = x / y;
+	unsigned long rem = x % y;
+
+	return (div + ((rem == 0) ? 0 : 1)) * y;
+}
+
+static unsigned long GCD(unsigned long x, unsigned long y)
+{
+	while (y != 0)
+	{
+		unsigned long r = x % y;
+		x = y;
+		y = r;
+	}
+
+	return x;
+}
+
+static unsigned long LCM(unsigned long x, unsigned long y)
+{
+	unsigned long gcd = GCD(x, y);
+
+	return (gcd == 0) ? 0 : ((x / gcd) * y);
+}
+
+unsigned OMAPLFBMaxFBDevIDPlusOne(void)
+{
+	return OMAPLFB_MAX_NUM_DEVICES;
+}
+
+OMAPLFB_DEVINFO *OMAPLFBGetDevInfoPtr(unsigned uiFBDevID)
+{
+	WARN_ON(uiFBDevID >= OMAPLFBMaxFBDevIDPlusOne());
+
+	if (uiFBDevID >= OMAPLFB_MAX_NUM_DEVICES)
+	{
+		return NULL;
+	}
+
+	return gapsDevInfo[uiFBDevID];
+}
+
+static inline void OMAPLFBSetDevInfoPtr(unsigned uiFBDevID, OMAPLFB_DEVINFO *psDevInfo)
+{
+	WARN_ON(uiFBDevID >= OMAPLFB_MAX_NUM_DEVICES);
+
+	if (uiFBDevID < OMAPLFB_MAX_NUM_DEVICES)
+	{
+		gapsDevInfo[uiFBDevID] = psDevInfo;
+	}
+}
+
+static inline OMAPLFB_BOOL SwapChainHasChanged(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+	return (psDevInfo->psSwapChain != psSwapChain) ||
+		(psDevInfo->uiSwapChainID != psSwapChain->uiSwapChainID);
+}
+
+static inline OMAPLFB_BOOL DontWaitForVSync(OMAPLFB_DEVINFO *psDevInfo)
+{
+	OMAPLFB_BOOL bDontWait;
+
+	bDontWait = OMAPLFBAtomicBoolRead(&psDevInfo->sBlanked) ||
+			OMAPLFBAtomicBoolRead(&psDevInfo->sFlushCommands);
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	bDontWait = bDontWait || OMAPLFBAtomicBoolRead(&psDevInfo->sEarlySuspendFlag);
+#endif
+#if defined(SUPPORT_DRI_DRM)
+	bDontWait = bDontWait || OMAPLFBAtomicBoolRead(&psDevInfo->sLeaveVT);
+#endif
+	return bDontWait;
+}
+
+static IMG_VOID SetDCState(IMG_HANDLE hDevice, IMG_UINT32 ui32State)
+{
+	OMAPLFB_DEVINFO *psDevInfo = (OMAPLFB_DEVINFO *)hDevice;
+
+	switch (ui32State)
+	{
+		case DC_STATE_FLUSH_COMMANDS:
+			OMAPLFBAtomicBoolSet(&psDevInfo->sFlushCommands, OMAPLFB_TRUE);
+			break;
+		case DC_STATE_NO_FLUSH_COMMANDS:
+			OMAPLFBAtomicBoolSet(&psDevInfo->sFlushCommands, OMAPLFB_FALSE);
+			break;
+		default:
+			break;
+	}
+}
+
+static PVRSRV_ERROR OpenDCDevice(IMG_UINT32 uiPVRDevID,
+                                 IMG_HANDLE *phDevice,
+                                 PVRSRV_SYNC_DATA* psSystemBufferSyncData)
+{
+	OMAPLFB_DEVINFO *psDevInfo;
+	OMAPLFB_ERROR eError;
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+
+	for (i = 0; i < uiMaxFBDevIDPlusOne; i++)
+	{
+		psDevInfo = OMAPLFBGetDevInfoPtr(i);
+		if (psDevInfo != NULL && psDevInfo->uiPVRDevID == uiPVRDevID)
+		{
+			break;
+		}
+	}
+	if (i == uiMaxFBDevIDPlusOne)
+	{
+		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
+			": %s: PVR Device %u not found\n", __FUNCTION__, uiPVRDevID));
+		return PVRSRV_ERROR_INVALID_DEVICE;
+	}
+
+	
+	psDevInfo->sSystemBuffer.psSyncData = psSystemBufferSyncData;
+	
+	eError = OMAPLFBUnblankDisplay(psDevInfo);
+	if (eError != OMAPLFB_OK)
+	{
+		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: OMAPLFBUnblankDisplay failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eError));
+		return PVRSRV_ERROR_UNBLANK_DISPLAY_FAILED;
+	}
+
+	
+	*phDevice = (IMG_HANDLE)psDevInfo;
+	
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR CloseDCDevice(IMG_HANDLE hDevice)
+{
+#if defined(SUPPORT_DRI_DRM)
+	OMAPLFB_DEVINFO *psDevInfo = (OMAPLFB_DEVINFO *)hDevice;
+
+	OMAPLFBAtomicBoolSet(&psDevInfo->sLeaveVT, OMAPLFB_FALSE);
+	(void) OMAPLFBUnblankDisplay(psDevInfo);
+#else
+	UNREFERENCED_PARAMETER(hDevice);
+#endif
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR EnumDCFormats(IMG_HANDLE hDevice,
+                                  IMG_UINT32 *pui32NumFormats,
+                                  DISPLAY_FORMAT *psFormat)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	
+	if(!hDevice || !pui32NumFormats)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	
+	*pui32NumFormats = 1;
+	
+	if(psFormat)
+	{
+		psFormat[0] = psDevInfo->sDisplayFormat;
+	}
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR EnumDCDims(IMG_HANDLE hDevice, 
+                               DISPLAY_FORMAT *psFormat,
+                               IMG_UINT32 *pui32NumDims,
+                               DISPLAY_DIMS *psDim)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+
+	if(!hDevice || !psFormat || !pui32NumDims)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	*pui32NumDims = 1;
+
+	
+	if(psDim)
+	{
+		psDim[0] = psDevInfo->sDisplayDim;
+	}
+	
+	return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR GetDCSystemBuffer(IMG_HANDLE hDevice, IMG_HANDLE *phBuffer)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	
+	if(!hDevice || !phBuffer)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	*phBuffer = (IMG_HANDLE)&psDevInfo->sSystemBuffer;
+
+	return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR GetDCInfo(IMG_HANDLE hDevice, DISPLAY_INFO *psDCInfo)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	
+	if(!hDevice || !psDCInfo)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	*psDCInfo = psDevInfo->sDisplayInfo;
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE        hDevice,
+                                    IMG_HANDLE        hBuffer, 
+                                    IMG_SYS_PHYADDR   **ppsSysAddr,
+                                    IMG_UINT32        *pui32ByteSize,
+                                    IMG_VOID          **ppvCpuVAddr,
+                                    IMG_HANDLE        *phOSMapInfo,
+                                    IMG_BOOL          *pbIsContiguous,
+	                                IMG_UINT32		  *pui32TilingStride)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	OMAPLFB_BUFFER *psSystemBuffer;
+
+	UNREFERENCED_PARAMETER(pui32TilingStride);
+
+	if(!hDevice)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	if(!hBuffer)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	if (!ppsSysAddr)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	if (!pui32ByteSize)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	psSystemBuffer = (OMAPLFB_BUFFER *)hBuffer;
+
+	*ppsSysAddr = &psSystemBuffer->sSysAddr;
+
+	*pui32ByteSize = (IMG_UINT32)psDevInfo->sFBInfo.ulBufferSize;
+
+	if (ppvCpuVAddr)
+	{
+		*ppvCpuVAddr = psSystemBuffer->sCPUVAddr;
+	}
+
+	if (phOSMapInfo)
+	{
+		*phOSMapInfo = (IMG_HANDLE)0;
+	}
+
+	if (pbIsContiguous)
+	{
+		*pbIsContiguous = IMG_TRUE;
+	}
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
+                                      IMG_UINT32 ui32Flags,
+                                      DISPLAY_SURF_ATTRIBUTES *psDstSurfAttrib,
+                                      DISPLAY_SURF_ATTRIBUTES *psSrcSurfAttrib,
+                                      IMG_UINT32 ui32BufferCount,
+                                      PVRSRV_SYNC_DATA **ppsSyncData,
+                                      IMG_UINT32 ui32OEMFlags,
+                                      IMG_HANDLE *phSwapChain,
+                                      IMG_UINT32 *pui32SwapChainID)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+	OMAPLFB_BUFFER *psBuffer;
+	IMG_UINT32 i;
+	PVRSRV_ERROR eError;
+	IMG_UINT32 ui32BuffersToSkip;
+
+	UNREFERENCED_PARAMETER(ui32OEMFlags);
+	
+	
+	if(!hDevice
+	|| !psDstSurfAttrib
+	|| !psSrcSurfAttrib
+	|| !ppsSyncData
+	|| !phSwapChain)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	
+	
+	if (psDevInfo->sDisplayInfo.ui32MaxSwapChains == 0)
+	{
+		return PVRSRV_ERROR_NOT_SUPPORTED;
+	}
+
+	OMAPLFBCreateSwapChainLock(psDevInfo);
+
+	
+	if(psDevInfo->psSwapChain != NULL)
+	{
+		eError = PVRSRV_ERROR_FLIP_CHAIN_EXISTS;
+		goto ExitUnLock;
+	}
+	
+	
+	if(ui32BufferCount > psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers)
+	{
+		eError = PVRSRV_ERROR_TOOMANYBUFFERS;
+		goto ExitUnLock;
+	}
+	
+	if ((psDevInfo->sFBInfo.ulRoundedBufferSize * (unsigned long)ui32BufferCount) > psDevInfo->sFBInfo.ulFBSize)
+	{
+		eError = PVRSRV_ERROR_TOOMANYBUFFERS;
+		goto ExitUnLock;
+	}
+
+	
+	ui32BuffersToSkip = psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers - ui32BufferCount;
+
+	
+	if(psDstSurfAttrib->pixelformat != psDevInfo->sDisplayFormat.pixelformat
+	|| psDstSurfAttrib->sDims.ui32ByteStride != psDevInfo->sDisplayDim.ui32ByteStride
+	|| psDstSurfAttrib->sDims.ui32Width != psDevInfo->sDisplayDim.ui32Width
+	|| psDstSurfAttrib->sDims.ui32Height != psDevInfo->sDisplayDim.ui32Height)
+	{
+		
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto ExitUnLock;
+	}		
+
+	if(psDstSurfAttrib->pixelformat != psSrcSurfAttrib->pixelformat
+	|| psDstSurfAttrib->sDims.ui32ByteStride != psSrcSurfAttrib->sDims.ui32ByteStride
+	|| psDstSurfAttrib->sDims.ui32Width != psSrcSurfAttrib->sDims.ui32Width
+	|| psDstSurfAttrib->sDims.ui32Height != psSrcSurfAttrib->sDims.ui32Height)
+	{
+		
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto ExitUnLock;
+	}		
+
+	
+	UNREFERENCED_PARAMETER(ui32Flags);
+	
+#if defined(PVR_OMAPFB3_UPDATE_MODE)
+	if (!OMAPLFBSetUpdateMode(psDevInfo, PVR_OMAPFB3_UPDATE_MODE))
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't set frame buffer update mode %d\n", __FUNCTION__, psDevInfo->uiFBDevID, PVR_OMAPFB3_UPDATE_MODE);
+	}
+#endif
+	
+	psSwapChain = (OMAPLFB_SWAPCHAIN*)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_SWAPCHAIN));
+	if(!psSwapChain)
+	{
+		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto ExitUnLock;
+	}
+
+	psBuffer = (OMAPLFB_BUFFER*)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_BUFFER) * ui32BufferCount);
+	if(!psBuffer)
+	{
+		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto ErrorFreeSwapChain;
+	}
+
+	psSwapChain->ulBufferCount = (unsigned long)ui32BufferCount;
+	psSwapChain->psBuffer = psBuffer;
+	psSwapChain->bNotVSynced = OMAPLFB_TRUE;
+	psSwapChain->uiFBDevID = psDevInfo->uiFBDevID;
+
+	
+	for(i=0; i<ui32BufferCount-1; i++)
+	{
+		psBuffer[i].psNext = &psBuffer[i+1];
+	}
+	
+	psBuffer[i].psNext = &psBuffer[0];
+
+	
+	for(i=0; i<ui32BufferCount; i++)
+	{
+		IMG_UINT32 ui32SwapBuffer = i + ui32BuffersToSkip;
+		IMG_UINT32 ui32BufferOffset = ui32SwapBuffer * (IMG_UINT32)psDevInfo->sFBInfo.ulRoundedBufferSize;
+
+		psBuffer[i].psSyncData = ppsSyncData[i];
+
+		psBuffer[i].sSysAddr.uiAddr = psDevInfo->sFBInfo.sSysAddr.uiAddr + ui32BufferOffset;
+		psBuffer[i].sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr + ui32BufferOffset;
+		psBuffer[i].ulYOffset = ui32BufferOffset / psDevInfo->sFBInfo.ulByteStride;
+		psBuffer[i].psDevInfo = psDevInfo;
+
+		OMAPLFBInitBufferForSwap(&psBuffer[i]);
+	}
+
+	if (OMAPLFBCreateSwapQueue(psSwapChain) != OMAPLFB_OK)
+	{ 
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Failed to create workqueue\n", __FUNCTION__, psDevInfo->uiFBDevID);
+		eError = PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR;
+		goto ErrorFreeBuffers;
+	}
+
+	if (OMAPLFBEnableLFBEventNotification(psDevInfo)!= OMAPLFB_OK)
+	{
+		eError = PVRSRV_ERROR_UNABLE_TO_ENABLE_EVENT;
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't enable framebuffer event notification\n", __FUNCTION__, psDevInfo->uiFBDevID);
+		goto ErrorDestroySwapQueue;
+	}
+
+	psDevInfo->uiSwapChainID++;
+	if (psDevInfo->uiSwapChainID == 0)
+	{
+		psDevInfo->uiSwapChainID++;
+	}
+
+	psSwapChain->uiSwapChainID = psDevInfo->uiSwapChainID;
+
+	psDevInfo->psSwapChain = psSwapChain;
+
+	*pui32SwapChainID = psDevInfo->uiSwapChainID;
+
+	*phSwapChain = (IMG_HANDLE)psSwapChain;
+
+	eError = PVRSRV_OK;
+	goto ExitUnLock;
+
+ErrorDestroySwapQueue:
+	OMAPLFBDestroySwapQueue(psSwapChain);
+ErrorFreeBuffers:
+	OMAPLFBFreeKernelMem(psBuffer);
+ErrorFreeSwapChain:
+	OMAPLFBFreeKernelMem(psSwapChain);
+ExitUnLock:
+	OMAPLFBCreateSwapChainUnLock(psDevInfo);
+	return eError;
+}
+
+static PVRSRV_ERROR DestroyDCSwapChain(IMG_HANDLE hDevice,
+	IMG_HANDLE hSwapChain)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+	OMAPLFB_ERROR eError;
+
+	
+	if(!hDevice || !hSwapChain)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+	
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
+
+	OMAPLFBCreateSwapChainLock(psDevInfo);
+
+	if (SwapChainHasChanged(psDevInfo, psSwapChain))
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: Swap chain mismatch\n", __FUNCTION__, psDevInfo->uiFBDevID);
+
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto ExitUnLock;
+	}
+
+	
+	OMAPLFBDestroySwapQueue(psSwapChain);
+
+	eError = OMAPLFBDisableLFBEventNotification(psDevInfo);
+	if (eError != OMAPLFB_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't disable framebuffer event notification\n", __FUNCTION__, psDevInfo->uiFBDevID);
+	}
+
+	
+	OMAPLFBFreeKernelMem(psSwapChain->psBuffer);
+	OMAPLFBFreeKernelMem(psSwapChain);
+
+	psDevInfo->psSwapChain = NULL;
+
+	OMAPLFBFlip(psDevInfo, &psDevInfo->sSystemBuffer);
+	(void) OMAPLFBCheckModeAndSync(psDevInfo);
+
+	eError = PVRSRV_OK;
+
+ExitUnLock:
+	OMAPLFBCreateSwapChainUnLock(psDevInfo);
+
+	return eError;
+}
+
+static PVRSRV_ERROR SetDCDstRect(IMG_HANDLE hDevice,
+	IMG_HANDLE hSwapChain,
+	IMG_RECT *psRect)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	UNREFERENCED_PARAMETER(psRect);
+
+	
+	
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+static PVRSRV_ERROR SetDCSrcRect(IMG_HANDLE hDevice,
+                                 IMG_HANDLE hSwapChain,
+                                 IMG_RECT *psRect)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	UNREFERENCED_PARAMETER(psRect);
+
+	
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+static PVRSRV_ERROR SetDCDstColourKey(IMG_HANDLE hDevice,
+                                      IMG_HANDLE hSwapChain,
+                                      IMG_UINT32 ui32CKColour)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	UNREFERENCED_PARAMETER(ui32CKColour);
+
+	
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+static PVRSRV_ERROR SetDCSrcColourKey(IMG_HANDLE hDevice,
+                                      IMG_HANDLE hSwapChain,
+                                      IMG_UINT32 ui32CKColour)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	UNREFERENCED_PARAMETER(ui32CKColour);
+
+	
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+static PVRSRV_ERROR GetDCBuffers(IMG_HANDLE hDevice,
+                                 IMG_HANDLE hSwapChain,
+                                 IMG_UINT32 *pui32BufferCount,
+                                 IMG_HANDLE *phBuffer)
+{
+	OMAPLFB_DEVINFO   *psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+	PVRSRV_ERROR eError;
+	unsigned i;
+	
+	
+	if(!hDevice 
+	|| !hSwapChain
+	|| !pui32BufferCount
+	|| !phBuffer)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+	
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
+
+	OMAPLFBCreateSwapChainLock(psDevInfo);
+
+	if (SwapChainHasChanged(psDevInfo, psSwapChain))
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: Swap chain mismatch\n", __FUNCTION__, psDevInfo->uiFBDevID);
+
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto Exit;
+	}
+	
+	
+	*pui32BufferCount = (IMG_UINT32)psSwapChain->ulBufferCount;
+	
+	
+	for(i=0; i<psSwapChain->ulBufferCount; i++)
+	{
+		phBuffer[i] = (IMG_HANDLE)&psSwapChain->psBuffer[i];
+	}
+	
+	eError = PVRSRV_OK;
+
+Exit:
+	OMAPLFBCreateSwapChainUnLock(psDevInfo);
+
+	return eError;
+}
+
+static PVRSRV_ERROR SwapToDCBuffer(IMG_HANDLE hDevice,
+                                   IMG_HANDLE hBuffer,
+                                   IMG_UINT32 ui32SwapInterval,
+                                   IMG_HANDLE hPrivateTag,
+                                   IMG_UINT32 ui32ClipRectCount,
+                                   IMG_RECT *psClipRect)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hBuffer);
+	UNREFERENCED_PARAMETER(ui32SwapInterval);
+	UNREFERENCED_PARAMETER(hPrivateTag);
+	UNREFERENCED_PARAMETER(ui32ClipRectCount);
+	UNREFERENCED_PARAMETER(psClipRect);
+	
+	
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR SwapToDCSystem(IMG_HANDLE hDevice,
+                                   IMG_HANDLE hSwapChain)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	
+	
+	return PVRSRV_OK;
+}
+
+static OMAPLFB_BOOL WaitForVSyncSettle(OMAPLFB_DEVINFO *psDevInfo)
+{
+		unsigned i;
+		for(i = 0; i < OMAPLFB_VSYNC_SETTLE_COUNT; i++)
+		{
+			if (DontWaitForVSync(psDevInfo) || !OMAPLFBWaitForVSync(psDevInfo))
+			{
+				return OMAPLFB_FALSE;
+			}
+		}
+
+		return OMAPLFB_TRUE;
+}
+
+void OMAPLFBSwapHandler(OMAPLFB_BUFFER *psBuffer)
+{
+	OMAPLFB_DEVINFO *psDevInfo = psBuffer->psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
+	OMAPLFB_BOOL bPreviouslyNotVSynced;
+#if 1
+#if defined(SUPPORT_DRI_DRM)
+	if (!OMAPLFBAtomicBoolRead(&psDevInfo->sLeaveVT))
+#endif
+	{
+		OMAPLFBFlip(psDevInfo, psBuffer);
+	}
+#endif
+	bPreviouslyNotVSynced = psSwapChain->bNotVSynced;
+	psSwapChain->bNotVSynced = OMAPLFB_TRUE;
+
+
+	if (!DontWaitForVSync(psDevInfo))
+	{
+		OMAPLFB_UPDATE_MODE eMode = OMAPLFBGetUpdateMode(psDevInfo);
+		int iBlankEvents = OMAPLFBAtomicIntRead(&psDevInfo->sBlankEvents);
+
+		switch(eMode)
+		{
+			case OMAPLFB_UPDATE_MODE_AUTO:
+				psSwapChain->bNotVSynced = OMAPLFB_FALSE;
+
+				if (bPreviouslyNotVSynced || psSwapChain->iBlankEvents != iBlankEvents)
+				{
+					psSwapChain->iBlankEvents = iBlankEvents;
+					psSwapChain->bNotVSynced = !WaitForVSyncSettle(psDevInfo);
+				} else if (psBuffer->ulSwapInterval != 0)
+				{
+					psSwapChain->bNotVSynced = !OMAPLFBWaitForVSync(psDevInfo);
+				}
+				break;
+#if defined(PVR_OMAPFB3_MANUAL_UPDATE_SYNC_IN_SWAP)
+			case OMAPLFB_UPDATE_MODE_MANUAL:
+				if (psBuffer->ulSwapInterval != 0)
+				{
+					(void) OMAPLFBManualSync(psDevInfo);
+				}
+				break;
+#endif
+			default:
+				break;
+		}
+	}
+
+#if 0
+#if defined(SUPPORT_DRI_DRM)
+        if (!OMAPLFBAtomicBoolRead(&psDevInfo->sLeaveVT))
+#endif
+        {
+                OMAPLFBFlip(psDevInfo, psBuffer);
+        }
+#endif
+
+	psDevInfo->sPVRJTable.pfnPVRSRVCmdComplete((IMG_HANDLE)psBuffer->hCmdComplete, IMG_TRUE);
+}
+
+static IMG_BOOL ProcessFlip(IMG_HANDLE  hCmdCookie,
+                            IMG_UINT32  ui32DataSize,
+                            IMG_VOID   *pvData)
+{
+	DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
+	OMAPLFB_DEVINFO *psDevInfo;
+	OMAPLFB_BUFFER *psBuffer;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+
+	
+	if(!hCmdCookie || !pvData)
+	{
+		return IMG_FALSE;
+	}
+
+	
+	psFlipCmd = (DISPLAYCLASS_FLIP_COMMAND*)pvData;
+
+	if (psFlipCmd == IMG_NULL || sizeof(DISPLAYCLASS_FLIP_COMMAND) != ui32DataSize)
+	{
+		return IMG_FALSE;
+	}
+
+	
+	psDevInfo = (OMAPLFB_DEVINFO*)psFlipCmd->hExtDevice;
+	psBuffer = (OMAPLFB_BUFFER*)psFlipCmd->hExtBuffer;
+	psSwapChain = (OMAPLFB_SWAPCHAIN*) psFlipCmd->hExtSwapChain;
+
+	OMAPLFBCreateSwapChainLock(psDevInfo);
+
+	if (SwapChainHasChanged(psDevInfo, psSwapChain))
+	{
+		
+		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u (PVR Device ID %u): The swap chain has been destroyed\n",
+			__FUNCTION__, psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID));
+	}
+	else
+	{
+		psBuffer->hCmdComplete = (OMAPLFB_HANDLE)hCmdCookie;
+		psBuffer->ulSwapInterval = (unsigned long)psFlipCmd->ui32SwapInterval;
+
+		OMAPLFBQueueBufferForSwap(psSwapChain, psBuffer);
+	}
+
+	OMAPLFBCreateSwapChainUnLock(psDevInfo);
+
+	return IMG_TRUE;
+}
+
+
+static OMAPLFB_ERROR OMAPLFBInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
+{
+	struct fb_info *psLINFBInfo;
+	struct module *psLINFBOwner;
+	OMAPLFB_FBINFO *psPVRFBInfo = &psDevInfo->sFBInfo;
+	OMAPLFB_ERROR eError = OMAPLFB_ERROR_GENERIC;
+	unsigned long FBSize;
+	unsigned long ulLCM;
+	unsigned uiFBDevID = psDevInfo->uiFBDevID;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+	console_lock();
+#else
+	acquire_console_sem();
+#endif
+
+	psLINFBInfo = registered_fb[uiFBDevID];
+	if (psLINFBInfo == NULL)
+	{
+		eError = OMAPLFB_ERROR_INVALID_DEVICE;
+		goto ErrorRelSem;
+	}
+
+	FBSize = (psLINFBInfo->screen_size) != 0 ?
+					psLINFBInfo->screen_size :
+					psLINFBInfo->fix.smem_len;
+
+	
+	if (FBSize == 0 || psLINFBInfo->fix.line_length == 0)
+	{
+		eError = OMAPLFB_ERROR_INVALID_DEVICE;
+		goto ErrorRelSem;
+	}
+
+	psLINFBOwner = psLINFBInfo->fbops->owner;
+	if (!try_module_get(psLINFBOwner))
+	{
+		printk(KERN_INFO DRIVER_PREFIX
+			": %s: Device %u: Couldn't get framebuffer module\n", __FUNCTION__, uiFBDevID);
+
+		goto ErrorRelSem;
+	}
+
+	if (psLINFBInfo->fbops->fb_open != NULL)
+	{
+		int res;
+
+		res = psLINFBInfo->fbops->fb_open(psLINFBInfo, 0);
+		if (res != 0)
+		{
+			printk(KERN_INFO DRIVER_PREFIX
+				" %s: Device %u: Couldn't open framebuffer(%d)\n", __FUNCTION__, uiFBDevID, res);
+
+			goto ErrorModPut;
+		}
+	}
+
+	psDevInfo->psLINFBInfo = psLINFBInfo;
+
+	ulLCM = LCM(psLINFBInfo->fix.line_length, OMAPLFB_PAGE_SIZE);
+
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer physical address: 0x%lx\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->fix.smem_start));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer virtual address: 0x%lx\n",
+			psDevInfo->uiFBDevID, (unsigned long)psLINFBInfo->screen_base));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer size: %lu\n",
+			psDevInfo->uiFBDevID, FBSize));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer virtual width: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->var.xres_virtual));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer virtual height: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->var.yres_virtual));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer width: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->var.xres));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer height: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->var.yres));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Framebuffer stride: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->fix.line_length));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: LCM of stride and page size: %lu\n",
+			psDevInfo->uiFBDevID, ulLCM));
+
+	
+	psPVRFBInfo->sSysAddr.uiAddr = psLINFBInfo->fix.smem_start;
+	psPVRFBInfo->sCPUVAddr = psLINFBInfo->screen_base;
+
+	psPVRFBInfo->ulWidth = psLINFBInfo->var.xres;
+	psPVRFBInfo->ulHeight = psLINFBInfo->var.yres;
+	psPVRFBInfo->ulByteStride =  psLINFBInfo->fix.line_length;
+	psPVRFBInfo->ulFBSize = FBSize;
+	psPVRFBInfo->ulBufferSize = psPVRFBInfo->ulHeight * psPVRFBInfo->ulByteStride;
+	
+	psPVRFBInfo->ulRoundedBufferSize = RoundUpToMultiple(psPVRFBInfo->ulBufferSize, ulLCM);
+
+	if(psLINFBInfo->var.bits_per_pixel == 16)
+	{
+		if((psLINFBInfo->var.red.length == 5) &&
+			(psLINFBInfo->var.green.length == 6) && 
+			(psLINFBInfo->var.blue.length == 5) && 
+			(psLINFBInfo->var.red.offset == 11) &&
+			(psLINFBInfo->var.green.offset == 5) && 
+			(psLINFBInfo->var.blue.offset == 0) && 
+			(psLINFBInfo->var.red.msb_right == 0)) 
+		{
+			psPVRFBInfo->ePixelFormat = PVRSRV_PIXEL_FORMAT_RGB565;
+		}
+		else
+		{
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown FB format\n", __FUNCTION__, uiFBDevID);
+		}
+	}
+	else if(psLINFBInfo->var.bits_per_pixel == 32)
+	{
+		if((psLINFBInfo->var.red.length == 8) &&
+			(psLINFBInfo->var.green.length == 8) && 
+			(psLINFBInfo->var.blue.length == 8) && 
+			(psLINFBInfo->var.red.offset == 16) &&
+			(psLINFBInfo->var.green.offset == 8) && 
+			(psLINFBInfo->var.blue.offset == 0) && 
+			(psLINFBInfo->var.red.msb_right == 0)) 
+		{
+			psPVRFBInfo->ePixelFormat = PVRSRV_PIXEL_FORMAT_ARGB8888;
+		}
+		else
+		{
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown FB format\n", __FUNCTION__, uiFBDevID);
+		}
+	}	
+	else
+	{
+		printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown FB format\n", __FUNCTION__, uiFBDevID);
+	}
+
+	psDevInfo->sFBInfo.ulPhysicalWidthmm =
+		((int)psLINFBInfo->var.width  > 0) ? psLINFBInfo->var.width  : 90;
+
+	psDevInfo->sFBInfo.ulPhysicalHeightmm =
+		((int)psLINFBInfo->var.height > 0) ? psLINFBInfo->var.height : 54;
+
+	
+	psDevInfo->sFBInfo.sSysAddr.uiAddr = psPVRFBInfo->sSysAddr.uiAddr;
+	psDevInfo->sFBInfo.sCPUVAddr = psPVRFBInfo->sCPUVAddr;
+
+	eError = OMAPLFB_OK;
+	goto ErrorRelSem;
+
+ErrorModPut:
+	module_put(psLINFBOwner);
+ErrorRelSem:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+	console_unlock();
+#else
+	release_console_sem();
+#endif
+
+	return eError;
+}
+
+static void OMAPLFBDeInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
+{
+	struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
+	struct module *psLINFBOwner;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+	console_lock();
+#else
+	acquire_console_sem();
+#endif
+	psLINFBOwner = psLINFBInfo->fbops->owner;
+
+	if (psLINFBInfo->fbops->fb_release != NULL) 
+	{
+		(void) psLINFBInfo->fbops->fb_release(psLINFBInfo, 0);
+	}
+
+	module_put(psLINFBOwner);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_unlock();
+#else
+	release_console_sem();
+#endif
+}
+
+static OMAPLFB_DEVINFO *OMAPLFBInitDev(unsigned uiFBDevID)
+{
+	PFN_CMD_PROC	 	pfnCmdProcList[OMAPLFB_COMMAND_COUNT];
+	IMG_UINT32		aui32SyncCountList[OMAPLFB_COMMAND_COUNT][2];
+	OMAPLFB_DEVINFO		*psDevInfo = NULL;
+
+	
+	psDevInfo = (OMAPLFB_DEVINFO *)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_DEVINFO));
+
+	if(psDevInfo == NULL)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: Couldn't allocate device information structure\n", __FUNCTION__, uiFBDevID);
+
+		goto ErrorExit;
+	}
+
+	
+	memset(psDevInfo, 0, sizeof(OMAPLFB_DEVINFO));
+
+	psDevInfo->uiFBDevID = uiFBDevID;
+
+	
+	if(!(*gpfnGetPVRJTable)(&psDevInfo->sPVRJTable))
+	{
+		goto ErrorFreeDevInfo;
+	}
+#ifdef FBDEV_PRESENT
+	
+	if(OMAPLFBInitFBDev(psDevInfo) != OMAPLFB_OK)
+	{
+		
+		goto ErrorFreeDevInfo;
+	}
+
+	psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = (IMG_UINT32)(psDevInfo->sFBInfo.ulFBSize / psDevInfo->sFBInfo.ulRoundedBufferSize);
+	if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers != 0)
+	{
+		psDevInfo->sDisplayInfo.ui32MaxSwapChains = 1;
+		psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 1;
+	}
+
+	psDevInfo->sDisplayInfo.ui32PhysicalWidthmm = psDevInfo->sFBInfo.ulPhysicalWidthmm;
+	psDevInfo->sDisplayInfo.ui32PhysicalHeightmm = psDevInfo->sFBInfo.ulPhysicalHeightmm;
+
+	strncpy(psDevInfo->sDisplayInfo.szDisplayName, DISPLAY_DEVICE_NAME, MAX_DISPLAY_NAME_SIZE);
+
+	psDevInfo->sDisplayFormat.pixelformat = psDevInfo->sFBInfo.ePixelFormat;
+	psDevInfo->sDisplayDim.ui32Width      = (IMG_UINT32)psDevInfo->sFBInfo.ulWidth;
+	psDevInfo->sDisplayDim.ui32Height     = (IMG_UINT32)psDevInfo->sFBInfo.ulHeight;
+	psDevInfo->sDisplayDim.ui32ByteStride = (IMG_UINT32)psDevInfo->sFBInfo.ulByteStride;
+
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+		": Device %u: Maximum number of swap chain buffers: %u\n",
+		psDevInfo->uiFBDevID, psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers));
+
+               
+	
+	psDevInfo->sSystemBuffer.sSysAddr = psDevInfo->sFBInfo.sSysAddr;
+	psDevInfo->sSystemBuffer.sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr;
+	psDevInfo->sSystemBuffer.psDevInfo = psDevInfo;
+
+	OMAPLFBInitBufferForSwap(&psDevInfo->sSystemBuffer);
+#else
+                psDevInfo->sSystemBuffer.sCPUVAddr = 0x100;
+//                psDevInfo->sSystemBuffer.ulBufferSize = 600*3200;
+
+                psDevInfo->sDisplayFormat.pixelformat = 20;
+                psDevInfo->sFBInfo.ulWidth      =  800;
+                psDevInfo->sFBInfo.ulHeight     =  600;
+                psDevInfo->sFBInfo.ulByteStride =  3200;
+                psDevInfo->sFBInfo.ulFBSize     =  8388608;
+                psDevInfo->sFBInfo.ulBufferSize = 600*3200;
+#endif
+
+
+	psDevInfo->sDCJTable.ui32TableSize = sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE);
+	psDevInfo->sDCJTable.pfnOpenDCDevice = OpenDCDevice;
+	psDevInfo->sDCJTable.pfnCloseDCDevice = CloseDCDevice;
+	psDevInfo->sDCJTable.pfnEnumDCFormats = EnumDCFormats;
+	psDevInfo->sDCJTable.pfnEnumDCDims = EnumDCDims;
+	psDevInfo->sDCJTable.pfnGetDCSystemBuffer = GetDCSystemBuffer;
+	psDevInfo->sDCJTable.pfnGetDCInfo = GetDCInfo;
+	psDevInfo->sDCJTable.pfnGetBufferAddr = GetDCBufferAddr;
+	psDevInfo->sDCJTable.pfnCreateDCSwapChain = CreateDCSwapChain;
+	psDevInfo->sDCJTable.pfnDestroyDCSwapChain = DestroyDCSwapChain;
+	psDevInfo->sDCJTable.pfnSetDCDstRect = SetDCDstRect;
+	psDevInfo->sDCJTable.pfnSetDCSrcRect = SetDCSrcRect;
+	psDevInfo->sDCJTable.pfnSetDCDstColourKey = SetDCDstColourKey;
+	psDevInfo->sDCJTable.pfnSetDCSrcColourKey = SetDCSrcColourKey;
+	psDevInfo->sDCJTable.pfnGetDCBuffers = GetDCBuffers;
+	psDevInfo->sDCJTable.pfnSwapToDCBuffer = SwapToDCBuffer;
+	psDevInfo->sDCJTable.pfnSwapToDCSystem = SwapToDCSystem;
+	psDevInfo->sDCJTable.pfnSetDCState = SetDCState;
+
+	
+	if(psDevInfo->sPVRJTable.pfnPVRSRVRegisterDCDevice(
+		&psDevInfo->sDCJTable,
+		&psDevInfo->uiPVRDevID) != PVRSRV_OK)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: PVR Services device registration failed\n", __FUNCTION__, uiFBDevID);
+
+		goto ErrorDeInitFBDev;
+	}
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+		": Device %u: PVR Device ID: %u\n",
+		psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID));
+	
+	
+	pfnCmdProcList[DC_FLIP_COMMAND] = ProcessFlip;
+
+	
+	aui32SyncCountList[DC_FLIP_COMMAND][0] = 0; 
+	aui32SyncCountList[DC_FLIP_COMMAND][1] = 2; 
+
+	
+
+
+
+	if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterCmdProcList(psDevInfo->uiPVRDevID,
+															&pfnCmdProcList[0],
+															aui32SyncCountList,
+															OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: Couldn't register command processing functions with PVR Services\n", __FUNCTION__, uiFBDevID);
+		goto ErrorUnregisterDevice;
+	}
+
+	OMAPLFBCreateSwapChainLockInit(psDevInfo);
+
+	OMAPLFBAtomicBoolInit(&psDevInfo->sBlanked, OMAPLFB_FALSE);
+	OMAPLFBAtomicIntInit(&psDevInfo->sBlankEvents, 0);
+	OMAPLFBAtomicBoolInit(&psDevInfo->sFlushCommands, OMAPLFB_FALSE);
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	OMAPLFBAtomicBoolInit(&psDevInfo->sEarlySuspendFlag, OMAPLFB_FALSE);
+#endif
+#if defined(SUPPORT_DRI_DRM)
+	OMAPLFBAtomicBoolInit(&psDevInfo->sLeaveVT, OMAPLFB_FALSE);
+#endif
+	return psDevInfo;
+
+ErrorUnregisterDevice:
+	(void)psDevInfo->sPVRJTable.pfnPVRSRVRemoveDCDevice(psDevInfo->uiPVRDevID);
+ErrorDeInitFBDev:
+	OMAPLFBDeInitFBDev(psDevInfo);
+ErrorFreeDevInfo:
+	OMAPLFBFreeKernelMem(psDevInfo);
+ErrorExit:
+	return NULL;
+}
+
+OMAPLFB_ERROR OMAPLFBInit(void)
+{
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+	unsigned uiDevicesFound = 0;
+
+	if(OMAPLFBGetLibFuncAddr ("PVRGetDisplayClassJTable", &gpfnGetPVRJTable) != OMAPLFB_OK)
+	{
+		return OMAPLFB_ERROR_INIT_FAILURE;
+	}
+
+	
+	for(i = uiMaxFBDevIDPlusOne; i-- != 0;)
+	{
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBInitDev(i);
+
+		if (psDevInfo != NULL)
+		{
+			
+			OMAPLFBSetDevInfoPtr(psDevInfo->uiFBDevID, psDevInfo);
+			uiDevicesFound++;
+		}
+	}
+
+	return (uiDevicesFound != 0) ? OMAPLFB_OK : OMAPLFB_ERROR_INIT_FAILURE;
+}
+
+static OMAPLFB_BOOL OMAPLFBDeInitDev(OMAPLFB_DEVINFO *psDevInfo)
+{
+	PVRSRV_DC_DISP2SRV_KMJTABLE *psPVRJTable = &psDevInfo->sPVRJTable;
+
+	OMAPLFBCreateSwapChainLockDeInit(psDevInfo);
+
+	OMAPLFBAtomicBoolDeInit(&psDevInfo->sBlanked);
+	OMAPLFBAtomicIntDeInit(&psDevInfo->sBlankEvents);
+	OMAPLFBAtomicBoolDeInit(&psDevInfo->sFlushCommands);
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	OMAPLFBAtomicBoolDeInit(&psDevInfo->sEarlySuspendFlag);
+#endif
+#if defined(SUPPORT_DRI_DRM)
+	OMAPLFBAtomicBoolDeInit(&psDevInfo->sLeaveVT);
+#endif
+	psPVRJTable = &psDevInfo->sPVRJTable;
+
+	if (psPVRJTable->pfnPVRSRVRemoveCmdProcList (psDevInfo->uiPVRDevID, OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: PVR Device %u: Couldn't unregister command processing functions\n", __FUNCTION__, psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID);
+		return OMAPLFB_FALSE;
+	}
+
+	
+	if (psPVRJTable->pfnPVRSRVRemoveDCDevice(psDevInfo->uiPVRDevID) != PVRSRV_OK)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: PVR Device %u: Couldn't remove device from PVR Services\n", __FUNCTION__, psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID);
+		return OMAPLFB_FALSE;
+	}
+#ifdef FBDEV_PRESENT	
+	OMAPLFBDeInitFBDev(psDevInfo);
+#endif
+	OMAPLFBSetDevInfoPtr(psDevInfo->uiFBDevID, NULL);
+
+	
+	OMAPLFBFreeKernelMem(psDevInfo);
+
+	return OMAPLFB_TRUE;
+}
+
+OMAPLFB_ERROR OMAPLFBDeInit(void)
+{
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+	OMAPLFB_BOOL bError = OMAPLFB_FALSE;
+
+	for(i = 0; i < uiMaxFBDevIDPlusOne; i++)
+	{
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBGetDevInfoPtr(i);
+
+		if (psDevInfo != NULL)
+		{
+			bError |= !OMAPLFBDeInitDev(psDevInfo);
+		}
+	}
+
+	return (bError) ? OMAPLFB_ERROR_INIT_FAILURE : OMAPLFB_OK;
+}
+
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/omaplfb_linux.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/omaplfb_linux.c
new file mode 100644
index 0000000..c07ddf2
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti335x_linux/omaplfb_linux.c
@@ -0,0 +1,836 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+#ifndef AUTOCONF_INCLUDED
+#include <linux/config.h>
+#endif
+#endif
+
+
+#include <asm/atomic.h>
+
+#if defined(SUPPORT_DRI_DRM)
+#include <drm/drmP.h>
+#else
+#include <linux/module.h>
+#endif
+
+//#include <linux/time.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/hardirq.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/omapfb.h>
+#include <linux/mutex.h>
+
+#include <video/da8xx-fb.h>
+#include <plat/vrfb.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+#define PVR_OMAPFB3_NEEDS_PLAT_VRFB_H
+#endif
+
+#if defined(PVR_OMAPFB3_NEEDS_PLAT_VRFB_H)
+# include <plat/vrfb.h>
+#else
+# if defined(PVR_OMAPFB3_NEEDS_MACH_VRFB_H)
+#  include <mach/vrfb.h>
+# endif
+#endif
+
+#if defined(DEBUG)
+#define	PVR_DEBUG DEBUG
+#undef DEBUG
+#endif
+#include <omapfb/omapfb.h>
+#if defined(DEBUG)
+#undef DEBUG
+#endif
+#if defined(PVR_DEBUG)
+#define	DEBUG PVR_DEBUG
+#undef PVR_DEBUG
+#endif
+
+#include "img_defs.h"
+#include "servicesext.h"
+#include "kerneldisplay.h"
+#include "omaplfb.h"
+#include "pvrmodule.h"
+#if defined(SUPPORT_DRI_DRM)
+#include "pvr_drm.h"
+#include "3rdparty_dc_drm_shared.h"
+#endif
+
+#if 0
+#if !defined(PVR_LINUX_USING_WORKQUEUES)
+#error "PVR_LINUX_USING_WORKQUEUES must be defined"
+#endif
+#endif
+
+MODULE_SUPPORTED_DEVICE(DEVNAME);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+#define OMAP_DSS_DRIVER(drv, dev) struct omap_dss_driver *drv = (dev) != NULL ? (dev)->driver : NULL
+#define OMAP_DSS_MANAGER(man, dev) struct omap_overlay_manager *man = (dev) != NULL ? (dev)->manager : NULL
+#define	WAIT_FOR_VSYNC(man)	((man)->wait_for_vsync)
+#else
+#define OMAP_DSS_DRIVER(drv, dev) struct omap_dss_device *drv = (dev)
+#define OMAP_DSS_MANAGER(man, dev) struct omap_dss_device *man = (dev)
+#define	WAIT_FOR_VSYNC(man)	((man)->wait_vsync)
+#endif
+
+void *OMAPLFBAllocKernelMem(unsigned long ulSize)
+{
+	return kmalloc(ulSize, GFP_KERNEL);
+}
+
+void OMAPLFBFreeKernelMem(void *pvMem)
+{
+	kfree(pvMem);
+}
+
+void OMAPLFBCreateSwapChainLockInit(OMAPLFB_DEVINFO *psDevInfo)
+{
+	mutex_init(&psDevInfo->sCreateSwapChainMutex);
+}
+
+void OMAPLFBCreateSwapChainLockDeInit(OMAPLFB_DEVINFO *psDevInfo)
+{
+	mutex_destroy(&psDevInfo->sCreateSwapChainMutex);
+}
+
+void OMAPLFBCreateSwapChainLock(OMAPLFB_DEVINFO *psDevInfo)
+{
+	mutex_lock(&psDevInfo->sCreateSwapChainMutex);
+}
+
+void OMAPLFBCreateSwapChainUnLock(OMAPLFB_DEVINFO *psDevInfo)
+{
+	mutex_unlock(&psDevInfo->sCreateSwapChainMutex);
+}
+
+void OMAPLFBAtomicBoolInit(OMAPLFB_ATOMIC_BOOL *psAtomic, OMAPLFB_BOOL bVal)
+{
+	atomic_set(psAtomic, (int)bVal);
+}
+
+void OMAPLFBAtomicBoolDeInit(OMAPLFB_ATOMIC_BOOL *psAtomic)
+{
+}
+
+void OMAPLFBAtomicBoolSet(OMAPLFB_ATOMIC_BOOL *psAtomic, OMAPLFB_BOOL bVal)
+{
+	atomic_set(psAtomic, (int)bVal);
+}
+
+OMAPLFB_BOOL OMAPLFBAtomicBoolRead(OMAPLFB_ATOMIC_BOOL *psAtomic)
+{
+	return (OMAPLFB_BOOL)atomic_read(psAtomic);
+}
+
+void OMAPLFBAtomicIntInit(OMAPLFB_ATOMIC_INT *psAtomic, int iVal)
+{
+	atomic_set(psAtomic, iVal);
+}
+
+void OMAPLFBAtomicIntDeInit(OMAPLFB_ATOMIC_INT *psAtomic)
+{
+}
+
+void OMAPLFBAtomicIntSet(OMAPLFB_ATOMIC_INT *psAtomic, int iVal)
+{
+	atomic_set(psAtomic, iVal);
+}
+
+int OMAPLFBAtomicIntRead(OMAPLFB_ATOMIC_INT *psAtomic)
+{
+	return atomic_read(psAtomic);
+}
+
+void OMAPLFBAtomicIntInc(OMAPLFB_ATOMIC_INT *psAtomic)
+{
+	atomic_inc(psAtomic);
+}
+
+OMAPLFB_ERROR OMAPLFBGetLibFuncAddr (char *szFunctionName, PFN_DC_GET_PVRJTABLE *ppfnFuncTable)
+{
+	if(strcmp("PVRGetDisplayClassJTable", szFunctionName) != 0)
+	{
+		return (OMAPLFB_ERROR_INVALID_PARAMS);
+	}
+
+	
+	*ppfnFuncTable = PVRGetDisplayClassJTable;
+
+	return (OMAPLFB_OK);
+}
+
+void OMAPLFBQueueBufferForSwap(OMAPLFB_SWAPCHAIN *psSwapChain, OMAPLFB_BUFFER *psBuffer)
+{
+	int res = queue_work(psSwapChain->psWorkQueue, &psBuffer->sWork);
+
+	if (res == 0)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Buffer already on work queue\n", __FUNCTION__, psSwapChain->uiFBDevID);
+	}
+}
+
+static void WorkQueueHandler(struct work_struct *psWork)
+{
+	OMAPLFB_BUFFER *psBuffer = container_of(psWork, OMAPLFB_BUFFER, sWork);
+
+	OMAPLFBSwapHandler(psBuffer);
+}
+
+OMAPLFB_ERROR OMAPLFBCreateSwapQueue(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34))
+        psSwapChain->psWorkQueue = __create_workqueue(DEVNAME, 1, 1, 1);
+#else	
+	psSwapChain->psWorkQueue = create_workqueue(DEVNAME);
+#endif
+	if (psSwapChain->psWorkQueue == NULL)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: create_singlethreaded_workqueue failed\n", __FUNCTION__, psSwapChain->uiFBDevID);
+
+		return (OMAPLFB_ERROR_INIT_FAILURE);
+	}
+
+	return (OMAPLFB_OK);
+}
+
+void OMAPLFBInitBufferForSwap(OMAPLFB_BUFFER *psBuffer)
+{
+	INIT_WORK(&psBuffer->sWork, WorkQueueHandler);
+}
+
+void OMAPLFBDestroySwapQueue(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+	destroy_workqueue(psSwapChain->psWorkQueue);
+}
+
+void OMAPLFBFlip(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_BUFFER *psBuffer)
+{
+	struct fb_var_screeninfo sFBVar;
+	int res;
+	unsigned long ulYResVirtual;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+	console_lock();
+#else
+	acquire_console_sem();
+#endif
+
+	sFBVar = psDevInfo->psLINFBInfo->var;
+
+	sFBVar.xoffset = 0;
+	sFBVar.yoffset = psBuffer->ulYOffset;
+
+	ulYResVirtual = psBuffer->ulYOffset + sFBVar.yres;
+	
+	if (sFBVar.xres_virtual != sFBVar.xres || sFBVar.yres_virtual < ulYResVirtual)
+	{
+		sFBVar.xres_virtual = sFBVar.xres;
+		sFBVar.yres_virtual = ulYResVirtual;
+
+		sFBVar.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
+
+		res = fb_set_var(psDevInfo->psLINFBInfo, &sFBVar);
+		if (res != 0)
+		{
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: fb_set_var failed (Y Offset: %lu, Error: %d)\n", __FUNCTION__, psDevInfo->uiFBDevID, psBuffer->ulYOffset, res);
+		}
+	}
+	else
+	{
+		res = fb_pan_display(psDevInfo->psLINFBInfo, &sFBVar);
+		if (res != 0)
+		{
+                        printk (" fb_pan api failed \n");
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: fb_pan_display failed (Y Offset: %lu, Error: %d)\n", __FUNCTION__, psDevInfo->uiFBDevID, psBuffer->ulYOffset, res);
+		}
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+	console_unlock();
+#else
+	release_console_sem();
+#endif
+}
+
+OMAPLFB_UPDATE_MODE OMAPLFBGetUpdateMode(OMAPLFB_DEVINFO *psDevInfo)
+{
+#if 0
+	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
+	OMAP_DSS_DRIVER(psDSSDrv, psDSSDev);
+
+	enum omap_dss_update_mode eMode;
+
+	if (psDSSDrv == NULL || psDSSDrv->get_update_mode == NULL)
+	{
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Can't get update mode\n", __FUNCTION__, psDevInfo->uiFBDevID));
+		return OMAPLFB_UPDATE_MODE_UNDEFINED;
+	}
+
+	eMode = psDSSDrv->get_update_mode(psDSSDev);
+	switch(eMode)
+	{
+		case OMAP_DSS_UPDATE_AUTO:
+			return OMAPLFB_UPDATE_MODE_AUTO;
+		case OMAP_DSS_UPDATE_MANUAL:
+			return OMAPLFB_UPDATE_MODE_MANUAL;
+		case OMAP_DSS_UPDATE_DISABLED:
+			return OMAPLFB_UPDATE_MODE_DISABLED;
+		default:
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown update mode (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eMode));
+			break;
+	}
+
+	return OMAPLFB_UPDATE_MODE_UNDEFINED;
+#endif
+        return OMAPLFB_UPDATE_MODE_AUTO;
+}
+
+OMAPLFB_BOOL OMAPLFBSetUpdateMode(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_UPDATE_MODE eMode)
+{
+#if 0
+	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
+	OMAP_DSS_DRIVER(psDSSDrv, psDSSDev);
+	enum omap_dss_update_mode eDSSMode;
+	int res;
+
+	if (psDSSDrv == NULL || psDSSDrv->set_update_mode == NULL)
+	{
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Can't set update mode\n", __FUNCTION__, psDevInfo->uiFBDevID));
+		return OMAPLFB_FALSE;
+	}
+
+	switch(eMode)
+	{
+		case OMAPLFB_UPDATE_MODE_AUTO:
+			eDSSMode = OMAP_DSS_UPDATE_AUTO;
+			break;
+		case OMAPLFB_UPDATE_MODE_MANUAL:
+			eDSSMode = OMAP_DSS_UPDATE_MANUAL;
+			break;
+		case OMAPLFB_UPDATE_MODE_DISABLED:
+			eDSSMode = OMAP_DSS_UPDATE_DISABLED;
+			break;
+		default:
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown update mode (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eMode));
+			return OMAPLFB_FALSE;
+	}
+
+	res = psDSSDrv->set_update_mode(psDSSDev, eDSSMode);
+	if (res != 0)
+	{
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: set_update_mode failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res));
+	}
+
+	return (res == 0);
+#endif
+        return 1;
+}
+
+OMAPLFB_BOOL OMAPLFBWaitForVSync(OMAPLFB_DEVINFO *psDevInfo)
+{
+//struct timeval tv;
+//static time_t curtime,curtime1;
+//	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
+//	OMAP_DSS_MANAGER(psDSSMan, psDSSDev);
+//        printk("Testing vsync\n");
+/*	if (psDSSMan != NULL && WAIT_FOR_VSYNC(psDSSMan) != NULL)
+	{
+		printk("Vsync call\n");
+		do_gettimeofday(&tv);
+		curtime=tv.tv_usec;
+		printk("The time is %ld\n",curtime);
+		int res = WAIT_FOR_VSYNC(psDSSMan)(psDSSMan);
+		do_gettimeofday(&tv);
+                curtime1=tv.tv_usec;
+		printk("The time is %ld\n",curtime1);
+		if (res != 0)
+		{
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Wait for vsync failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res));
+			return OMAPLFB_FALSE;
+		}
+	}*/
+#if 0
+        struct vps_grpx_ctrl *gctrl;
+        int r;
+        gctrl = vps_grpx_get_ctrl(psDevInfo->uiFBDevID); 
+        printk (" BVSYNC \n");
+        r = gctrl->wait_for_vsync(gctrl);
+        printk (" AVSYNC: %d\n", vsync_num++);
+        return OMAPLFB_TRUE;
+#endif
+//    unsigned long timeout = msecs_to_jiffies(500);
+
+#if FBDEV_PRESENT
+      int r;
+
+      void grpx_irq_wait_handler(void *data)
+      {
+          complete((struct completion *)data);
+//	do_gettimeofday(&tv);
+  //      curtime=tv.tv_usec;
+//printk("The time in handler is %ld\n",curtime);
+      }
+      DECLARE_COMPLETION_ONSTACK(completion);
+
+      if (register_vsync_cb((vsync_callback_t)grpx_irq_wait_handler, &completion, psDevInfo->uiFBDevID) != 0)
+      {
+          printk (KERN_WARNING DRIVER_PREFIX ": Failed to register for vsync call back\n");
+          return OMAPLFB_FALSE;
+      }
+//do_gettimeofday(&tv);
+//curtime=tv.tv_usec;
+//printk("The time is %ld\n",curtime);
+//    timeout = wait_for_completion_interruptible_timeout(&completion, timeout);
+      r = wait_for_completion_interruptible(&completion);
+      if (unregister_vsync_cb((vsync_callback_t)grpx_irq_wait_handler , &completion, psDevInfo->uiFBDevID) != 0)
+      {
+          printk (KERN_WARNING DRIVER_PREFIX ": Failed to un-register for vsync call back\n");
+          return OMAPLFB_FALSE;
+      }
+#endif
+      return OMAPLFB_TRUE;
+}
+
+OMAPLFB_BOOL OMAPLFBManualSync(OMAPLFB_DEVINFO *psDevInfo)
+{
+#if 0
+	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
+	OMAP_DSS_DRIVER(psDSSDrv, psDSSDev);
+
+	if (psDSSDrv != NULL && psDSSDrv->sync != NULL)
+	{
+		int res = psDSSDrv->sync(psDSSDev);
+		if (res != 0)
+		{
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Sync failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res);
+			return OMAPLFB_FALSE;
+		}
+	}
+#endif
+
+	return OMAPLFB_TRUE;
+}
+
+OMAPLFB_BOOL OMAPLFBCheckModeAndSync(OMAPLFB_DEVINFO *psDevInfo)
+{
+	OMAPLFB_UPDATE_MODE eMode = OMAPLFBGetUpdateMode(psDevInfo);
+
+	switch(eMode)
+	{
+		case OMAPLFB_UPDATE_MODE_AUTO:
+		case OMAPLFB_UPDATE_MODE_MANUAL:
+			return OMAPLFBManualSync(psDevInfo);
+		default:
+			break;
+	}
+
+	return OMAPLFB_TRUE;
+}
+
+static int OMAPLFBFrameBufferEvents(struct notifier_block *psNotif,
+                             unsigned long event, void *data)
+{
+	OMAPLFB_DEVINFO *psDevInfo;
+	struct fb_event *psFBEvent = (struct fb_event *)data;
+	struct fb_info *psFBInfo = psFBEvent->info;
+	OMAPLFB_BOOL bBlanked;
+
+	
+	if (event != FB_EVENT_BLANK)
+	{
+		return 0;
+	}
+
+	bBlanked = (*(IMG_INT *)psFBEvent->data != 0) ? OMAPLFB_TRUE: OMAPLFB_FALSE;
+
+	psDevInfo = OMAPLFBGetDevInfoPtr(psFBInfo->node);
+
+#if 0
+	if (psDevInfo != NULL)
+	{
+		if (bBlanked)
+		{
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Blank event received\n", __FUNCTION__, psDevInfo->uiFBDevID));
+		}
+		else
+		{
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unblank event received\n", __FUNCTION__, psDevInfo->uiFBDevID));
+		}
+	}
+	else
+	{
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Blank/Unblank event for unknown framebuffer\n", __FUNCTION__, psFBInfo->node));
+	}
+#endif
+
+	if (psDevInfo != NULL)
+	{
+		OMAPLFBAtomicBoolSet(&psDevInfo->sBlanked, bBlanked);
+		OMAPLFBAtomicIntInc(&psDevInfo->sBlankEvents);
+	}
+
+	return 0;
+}
+
+OMAPLFB_ERROR OMAPLFBUnblankDisplay(OMAPLFB_DEVINFO *psDevInfo)
+{
+	int res;
+#ifdef FBDEV_PRESENT
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+	console_lock();
+#else
+	acquire_console_sem();
+#endif
+	res = fb_blank(psDevInfo->psLINFBInfo, 0);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+	console_unlock();
+#else
+	release_console_sem();
+#endif
+	if (res != 0 && res != -EINVAL)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: fb_blank failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res);
+		return (OMAPLFB_ERROR_GENERIC);
+	}
+#endif
+
+	return (OMAPLFB_OK);
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+
+static void OMAPLFBBlankDisplay(OMAPLFB_DEVINFO *psDevInfo)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+	console_lock();
+#else
+	acquire_console_sem();
+#endif
+	fb_blank(psDevInfo->psLINFBInfo, 1);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+	console_unlock();
+#else
+	release_console_sem();
+#endif
+}
+
+static void OMAPLFBEarlySuspendHandler(struct early_suspend *h)
+{
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+
+	for (i=0; i < uiMaxFBDevIDPlusOne; i++)
+	{
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBGetDevInfoPtr(i);
+
+		if (psDevInfo != NULL)
+		{
+			OMAPLFBAtomicBoolSet(&psDevInfo->sEarlySuspendFlag, OMAPLFB_TRUE);
+			OMAPLFBBlankDisplay(psDevInfo);
+		}
+	}
+}
+
+static void OMAPLFBEarlyResumeHandler(struct early_suspend *h)
+{
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+
+	for (i=0; i < uiMaxFBDevIDPlusOne; i++)
+	{
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBGetDevInfoPtr(i);
+
+		if (psDevInfo != NULL)
+		{
+			OMAPLFBUnblankDisplay(psDevInfo);
+			OMAPLFBAtomicBoolSet(&psDevInfo->sEarlySuspendFlag, OMAPLFB_FALSE);
+		}
+	}
+}
+
+#endif 
+
+OMAPLFB_ERROR OMAPLFBEnableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
+{
+	int                res;
+	OMAPLFB_ERROR         eError;
+
+	
+	memset(&psDevInfo->sLINNotifBlock, 0, sizeof(psDevInfo->sLINNotifBlock));
+
+	psDevInfo->sLINNotifBlock.notifier_call = OMAPLFBFrameBufferEvents;
+
+	OMAPLFBAtomicBoolSet(&psDevInfo->sBlanked, OMAPLFB_FALSE);
+	OMAPLFBAtomicIntSet(&psDevInfo->sBlankEvents, 0);
+
+	res = fb_register_client(&psDevInfo->sLINNotifBlock);
+	if (res != 0)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: fb_register_client failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res);
+
+		return (OMAPLFB_ERROR_GENERIC);
+	}
+
+	eError = OMAPLFBUnblankDisplay(psDevInfo);
+	if (eError != OMAPLFB_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: UnblankDisplay failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eError);
+		return eError;
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	psDevInfo->sEarlySuspend.suspend = OMAPLFBEarlySuspendHandler;
+	psDevInfo->sEarlySuspend.resume = OMAPLFBEarlyResumeHandler;
+	psDevInfo->sEarlySuspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	register_early_suspend(&psDevInfo->sEarlySuspend);
+#endif
+
+	return (OMAPLFB_OK);
+}
+
+OMAPLFB_ERROR OMAPLFBDisableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
+{
+	int res;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&psDevInfo->sEarlySuspend);
+#endif
+
+	
+	res = fb_unregister_client(&psDevInfo->sLINNotifBlock);
+	if (res != 0)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: fb_unregister_client failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res);
+		return (OMAPLFB_ERROR_GENERIC);
+	}
+
+	OMAPLFBAtomicBoolSet(&psDevInfo->sBlanked, OMAPLFB_FALSE);
+
+	return (OMAPLFB_OK);
+}
+
+#if defined(SUPPORT_DRI_DRM) && defined(PVR_DISPLAY_CONTROLLER_DRM_IOCTL)
+static OMAPLFB_DEVINFO *OMAPLFBPVRDevIDToDevInfo(unsigned uiPVRDevID)
+{
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+
+	for (i=0; i < uiMaxFBDevIDPlusOne; i++)
+	{
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBGetDevInfoPtr(i);
+
+		if (psDevInfo->uiPVRDevID == uiPVRDevID)
+		{
+			return psDevInfo;
+		}
+	}
+
+	printk(KERN_WARNING DRIVER_PREFIX
+		": %s: PVR Device %u: Couldn't find device\n", __FUNCTION__, uiPVRDevID);
+
+	return NULL;
+}
+
+int PVR_DRM_MAKENAME(omaplfb, _Ioctl)(struct drm_device unref__ *dev, void *arg, struct drm_file unref__ *pFile)
+{
+	uint32_t *puiArgs;
+	uint32_t uiCmd;
+	unsigned uiPVRDevID;
+	int ret = 0;
+	OMAPLFB_DEVINFO *psDevInfo;
+
+	if (arg == NULL)
+	{
+		return -EFAULT;
+	}
+
+	puiArgs = (uint32_t *)arg;
+	uiCmd = puiArgs[PVR_DRM_DISP_ARG_CMD];
+	uiPVRDevID = puiArgs[PVR_DRM_DISP_ARG_DEV];
+
+	psDevInfo = OMAPLFBPVRDevIDToDevInfo(uiPVRDevID);
+	if (psDevInfo == NULL)
+	{
+		return -EINVAL;
+	}
+
+
+	switch (uiCmd)
+	{
+		case PVR_DRM_DISP_CMD_LEAVE_VT:
+		case PVR_DRM_DISP_CMD_ENTER_VT:
+		{
+			OMAPLFB_BOOL bLeaveVT = (uiCmd == PVR_DRM_DISP_CMD_LEAVE_VT);
+			DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: PVR Device %u: %s\n",
+				__FUNCTION__, uiPVRDevID,
+				bLeaveVT ? "Leave VT" : "Enter VT"));
+
+			OMAPLFBCreateSwapChainLock(psDevInfo);
+			
+			OMAPLFBAtomicBoolSet(&psDevInfo->sLeaveVT, bLeaveVT);
+			if (psDevInfo->psSwapChain != NULL)
+			{
+				flush_workqueue(psDevInfo->psSwapChain->psWorkQueue);
+
+				if (bLeaveVT)
+				{
+					OMAPLFBFlip(psDevInfo, &psDevInfo->sSystemBuffer);
+					(void) OMAPLFBCheckModeAndSync(psDevInfo);
+				}
+			}
+
+			OMAPLFBCreateSwapChainUnLock(psDevInfo);
+			(void) OMAPLFBUnblankDisplay(psDevInfo);
+			break;
+		}
+		case PVR_DRM_DISP_CMD_ON:
+		case PVR_DRM_DISP_CMD_STANDBY:
+		case PVR_DRM_DISP_CMD_SUSPEND:
+		case PVR_DRM_DISP_CMD_OFF:
+		{
+			int iFBMode;
+#if defined(DEBUG)
+			{
+				const char *pszMode;
+				switch(uiCmd)
+				{
+					case PVR_DRM_DISP_CMD_ON:
+						pszMode = "On";
+						break;
+					case PVR_DRM_DISP_CMD_STANDBY:
+						pszMode = "Standby";
+						break;
+					case PVR_DRM_DISP_CMD_SUSPEND:
+						pszMode = "Suspend";
+						break;
+					case PVR_DRM_DISP_CMD_OFF:
+						pszMode = "Off";
+						break;
+					default:
+						pszMode = "(Unknown Mode)";
+						break;
+				}
+				printk (KERN_WARNING DRIVER_PREFIX ": %s: PVR Device %u: Display %s\n",
+				__FUNCTION__, uiPVRDevID, pszMode);
+			}
+#endif
+			switch(uiCmd)
+			{
+				case PVR_DRM_DISP_CMD_ON:
+					iFBMode = FB_BLANK_UNBLANK;
+					break;
+				case PVR_DRM_DISP_CMD_STANDBY:
+					iFBMode = FB_BLANK_HSYNC_SUSPEND;
+					break;
+				case PVR_DRM_DISP_CMD_SUSPEND:
+					iFBMode = FB_BLANK_VSYNC_SUSPEND;
+					break;
+				case PVR_DRM_DISP_CMD_OFF:
+					iFBMode = FB_BLANK_POWERDOWN;
+					break;
+				default:
+					return -EINVAL;
+			}
+
+			OMAPLFBCreateSwapChainLock(psDevInfo);
+
+			if (psDevInfo->psSwapChain != NULL)
+			{
+				flush_workqueue(psDevInfo->psSwapChain->psWorkQueue);
+			}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+			console_lock();
+#else
+			acquire_console_sem();
+#endif
+			ret = fb_blank(psDevInfo->psLINFBInfo, iFBMode);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+			console_unlock();
+#else
+			release_console_sem();
+#endif
+
+			OMAPLFBCreateSwapChainUnLock(psDevInfo);
+
+			break;
+		}
+		default:
+		{
+			ret = -EINVAL;
+			break;
+		}
+	}
+
+	return ret;
+}
+#endif
+
+#if defined(SUPPORT_DRI_DRM)
+int PVR_DRM_MAKENAME(omaplfb, _Init)(struct drm_device unref__ *dev)
+#else
+static int __init OMAPLFB_Init(void)
+#endif
+{
+
+	if(OMAPLFBInit() != OMAPLFB_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: OMAPLFBInit failed\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	return 0;
+
+}
+
+#if defined(SUPPORT_DRI_DRM)
+void PVR_DRM_MAKENAME(omaplfb, _Cleanup)(struct drm_device unref__ *dev)
+#else
+static void __exit OMAPLFB_Cleanup(void)
+#endif
+{    
+	if(OMAPLFBDeInit() != OMAPLFB_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: OMAPLFBDeInit failed\n", __FUNCTION__);
+	}
+}
+
+#if !defined(SUPPORT_DRI_DRM)
+late_initcall(OMAPLFB_Init);
+module_exit(OMAPLFB_Cleanup);
+#endif
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/3rdparty_dc_drm_shared.h b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/3rdparty_dc_drm_shared.h
new file mode 100644
index 0000000..9b6d240
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/3rdparty_dc_drm_shared.h
@@ -0,0 +1,45 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef __3RDPARTY_DC_DRM_SHARED_H__
+#define __3RDPARTY_DC_DRM_SHARED_H__
+#if defined(SUPPORT_DRI_DRM)
+
+#define	PVR_DRM_DISP_CMD_ENTER_VT	1
+#define	PVR_DRM_DISP_CMD_LEAVE_VT	2
+
+#define	PVR_DRM_DISP_CMD_ON		3
+#define	PVR_DRM_DISP_CMD_STANDBY	4
+#define	PVR_DRM_DISP_CMD_SUSPEND	5
+#define	PVR_DRM_DISP_CMD_OFF		6
+
+#define	PVR_DRM_DISP_ARG_CMD		0
+#define	PVR_DRM_DISP_ARG_DEV		1
+#define	PVR_DRM_DISP_NUM_ARGS		2
+
+#endif	
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/Kbuild b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/Kbuild
index 8c3bad3..4707e16 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/Kbuild
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/Kbuild
@@ -1,22 +1,31 @@
 SYS_USING_INTERRUPTS = 1
 SUPPORT_OMAP3430_OMAPFB3 =1
 SUPPORT_TI_DSS_FW = 0
+PVR_LINUX_USING_WORKQUEUES = 1
 
 SYS_CFLAGS.$(SYS_USING_INTERRUPTS)                      += -DSYS_USING_INTERRUPTS
 SYS_CFLAGS.$(SUPPORT_OMAP3430_OMAPFB3)                         += -DSUPPORT_OMAP3430_OMAPFB3
 SYS_CFLAGS.$(SUPPORT_TI_DSS_FW)                         += -DSUPPORT_TI_DSS_FW
+SYS_CFLAGS.$(PVR_LINUX_USING_WORKQUEUES)             += -DPVR_LINUX_USING_WORKQUEUES
+SYS_CFLAGS += -DDISPLAY_CONTROLLER=omaplfb
 
-EXTRA_CFLAGS =	-DLINUX \
-		-DCONFIG_OMAP2_DSS \
-		-I$(PVR_BUILD_DIR)/include4 \
-		-I$(PVR_BUILD_DIR)/services4/include \
-		-I$(PVR_BUILD_DIR)/services4/system/$(PVR_SYSTEM) \
-		-I$(PVR_BUILD_DIR)/services4/system/include \
-		$(SYS_CFLAGS.1) \
+ccflags-y += -DLINUX
+ccflags-y += -DCONFIG_OMAP2_DSS
+ccflags-y += -Idrivers/staging/omap3-sgx/include4
+ccflags-y += -Idrivers/staging/omap3-sgx/services4/include
+ccflags-y += -Idrivers/staging/omap3-sgx/services4/system/$(PVR_SYSTEM)
+ccflags-y += -Idrivers/staging/omap3-sgx/services4/system/include
+ccflags-y += $(SYS_CFLAGS.1)
 
 ifneq ($(FBDEV),no)
 EXTRA_CFLAGS += -DFBDEV_PRESENT
 endif
 
+ifeq ($(SUPPORT_XORG),1)
+EXTRA_CFLAGS += -DSUPPORT_DRI_DRM
+EXTRA_CFLAGS += -DPVR_DISPLAY_CONTROLLER_DRM_IOCTL
+endif
+
+
 obj-m := omaplfb.o
 omaplfb-y := omaplfb_displayclass.o omaplfb_linux.o
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/kbuild/Makefile b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/kbuild/Makefile
index 0b37436..f52617a 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/kbuild/Makefile
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/kbuild/Makefile
@@ -22,18 +22,15 @@
 # Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
 # 
 #
-#
 
-MODULE		= omaplfb
+MODULE		= $(DISPLAY_CONTROLLER)
 
-INCLUDES = 	-I$(EURASIAROOT)/include4 \
-		-I$(EURASIAROOT)/services4/include \
-		-I$(EURASIAROOT)/services4/system/$(PVR_SYSTEM) \
-		-I$(EURASIAROOT)/services4/system/include \
+INCLUDES =
 
-SOURCES	=	../omaplfb_displayclass.c \
-			../omaplfb_linux.c
+SOURCES	=
 
 SYM_VERS_DEPS = $(EURASIAROOT)/services4/srvkm/env/linux
 
+include $(EURASIAROOT)/services4/$(DISPLAY_CONTROLLER_DIR)/makefile.linux.common
+
 include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb.h b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb.h
index d3ae4bc..881a49d 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb.h
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb.h
@@ -27,119 +27,76 @@
 #ifndef __OMAPLFB_H__
 #define __OMAPLFB_H__
 
-#define OMAPLCD_IRQ			25
-
-#define OMAPLCD_SYSCONFIG           0x0410
-#define OMAPLCD_CONFIG              0x0444
-#define OMAPLCD_DEFAULT_COLOR0      0x044C
-#define OMAPLCD_TIMING_H            0x0464
-#define OMAPLCD_TIMING_V            0x0468
-#define OMAPLCD_POL_FREQ            0x046C
-#define OMAPLCD_DIVISOR             0x0470
-#define OMAPLCD_SIZE_DIG            0x0478
-#define OMAPLCD_SIZE_LCD            0x047C
-#define OMAPLCD_GFX_POSITION        0x0488
-#define OMAPLCD_GFX_SIZE            0x048C
-#define OMAPLCD_GFX_ATTRIBUTES      0x04a0
-#define OMAPLCD_GFX_FIFO_THRESHOLD  0x04a4
-#define OMAPLCD_GFX_WINDOW_SKIP     0x04b4
-
-#define OMAPLCD_IRQSTATUS       0x0418
-#define OMAPLCD_IRQENABLE       0x041c
-#define OMAPLCD_CONTROL         0x0440
-#define OMAPLCD_GFX_BA0         0x0480
-#define OMAPLCD_GFX_BA1         0x0484
-#define OMAPLCD_GFX_ROW_INC     0x04ac
-#define OMAPLCD_GFX_PIX_INC     0x04b0
-#define OMAPLCD_VID1_BA0        0x04bc
-#define OMAPLCD_VID1_BA1        0x04c0
-#define OMAPLCD_VID1_ROW_INC    0x04d8
-#define OMAPLCD_VID1_PIX_INC    0x04dc
-
-#define	OMAP_CONTROL_GODIGITAL      (1 << 6)
-#define	OMAP_CONTROL_GOLCD          (1 << 5)
-#define	OMAP_CONTROL_DIGITALENABLE  (1 << 1)
-#define	OMAP_CONTROL_LCDENABLE      (1 << 0)
-
-#define OMAPLCD_INTMASK_VSYNC       (1 << 1)
-#define OMAPLCD_INTMASK_OFF		0
-
-typedef void *       OMAP_HANDLE;
-
-typedef enum tag_omap_bool
-{
-	OMAP_FALSE = 0,
-	OMAP_TRUE  = 1,
-} OMAP_BOOL, *OMAP_PBOOL;
+#include <linux/version.h>
 
-typedef struct OMAPLFB_BUFFER_TAG
-{
-	unsigned long                ulBufferSize;
+#include <asm/atomic.h>
 
-	
-	
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/fb.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/notifier.h>
+#include <linux/mutex.h>
 
-	IMG_SYS_PHYADDR              sSysAddr;
-	IMG_CPU_VIRTADDR             sCPUVAddr;
-	PVRSRV_SYNC_DATA            *psSyncData;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
 
-	struct OMAPLFB_BUFFER_TAG	*psNext;
-} OMAPLFB_BUFFER;
+#define unref__ __attribute__ ((unused))
+
+typedef void *       OMAPLFB_HANDLE;
+
+typedef bool OMAPLFB_BOOL, *OMAPLFB_PBOOL;
+#define	OMAPLFB_FALSE false
+#define OMAPLFB_TRUE true
+
+typedef	atomic_t	OMAPLFB_ATOMIC_BOOL;
 
-typedef struct OMAPLFB_VSYNC_FLIP_ITEM_TAG
+typedef atomic_t	OMAPLFB_ATOMIC_INT;
+
+typedef struct OMAPLFB_BUFFER_TAG
 {
-	
+	struct OMAPLFB_BUFFER_TAG	*psNext;
+	struct OMAPLFB_DEVINFO_TAG	*psDevInfo;
 
+	struct work_struct sWork;
 
-	OMAP_HANDLE      hCmdComplete;
-	
-	unsigned long    ulSwapInterval;
-	
-	OMAP_BOOL        bValid;
-	
-	OMAP_BOOL        bFlipped;
 	
-	OMAP_BOOL        bCmdCompleted;
+	unsigned long		     	ulYOffset;
 
 	
 	
+	IMG_SYS_PHYADDR              	sSysAddr;
+	IMG_CPU_VIRTADDR             	sCPUVAddr;
+	PVRSRV_SYNC_DATA            	*psSyncData;
 
-	
-	IMG_SYS_PHYADDR* sSysAddr;
-} OMAPLFB_VSYNC_FLIP_ITEM;
+	OMAPLFB_HANDLE      		hCmdComplete;
+	unsigned long    		ulSwapInterval;
+} OMAPLFB_BUFFER;
 
-typedef struct PVRPDP_SWAPCHAIN_TAG
+typedef struct OMAPLFB_SWAPCHAIN_TAG
 {
 	
-	unsigned long       ulBufferCount;
-	
-	OMAPLFB_BUFFER     *psBuffer;
-	
-	OMAPLFB_VSYNC_FLIP_ITEM	*psVSyncFlips;
-
-	
-	unsigned long       ulInsertIndex;
-	
-	
-	unsigned long       ulRemoveIndex;
+	unsigned int			uiSwapChainID;
 
 	
-	void *pvRegs;
+	unsigned long       		ulBufferCount;
 
 	
-	PVRSRV_DC_DISP2SRV_KMJTABLE	*psPVRJTable;
+	OMAPLFB_BUFFER     		*psBuffer;
 
 	
-	OMAP_BOOL           bFlushCommands;
+	struct workqueue_struct   	*psWorkQueue;
 
 	
-	unsigned long       ulSetFlushStateRefCount;
+	OMAPLFB_BOOL			bNotVSynced;
 
 	
-	OMAP_BOOL           bBlanked;
+	int				iBlankEvents;
 
 	
-	spinlock_t         *psSwapChainLock;
+	unsigned int            	uiFBDevID;
 } OMAPLFB_SWAPCHAIN;
 
 typedef struct OMAPLFB_FBINFO_TAG
@@ -164,7 +121,14 @@ typedef struct OMAPLFB_FBINFO_TAG
 
 typedef struct OMAPLFB_DEVINFO_TAG
 {
-	unsigned int            uiDeviceID;
+	
+	unsigned int            uiFBDevID;
+
+	
+	unsigned int            uiPVRDevID;
+
+	
+	struct mutex		sCreateSwapChainMutex;
 
 	
 	OMAPLFB_BUFFER          sSystemBuffer;
@@ -179,13 +143,13 @@ typedef struct OMAPLFB_DEVINFO_TAG
 	OMAPLFB_FBINFO          sFBInfo;
 
 	
-	unsigned long           ulRefCount;
+	OMAPLFB_SWAPCHAIN      *psSwapChain;
 
 	
-	OMAPLFB_SWAPCHAIN      *psSwapChain;
+	unsigned int		uiSwapChainID;
 
 	
-	OMAP_BOOL               bFlushCommands;
+	OMAPLFB_ATOMIC_BOOL     sFlushCommands;
 
 	
 	struct fb_info         *psLINFBInfo;
@@ -194,16 +158,10 @@ typedef struct OMAPLFB_DEVINFO_TAG
 	struct notifier_block   sLINNotifBlock;
 
 	
-	OMAP_BOOL               bDeviceSuspended;
-
-	
-	spinlock_t             sSwapChainLock;
-
-	
 	
 
 	
-	IMG_DEV_VIRTADDR		sDisplayDevVAddr;
+	IMG_DEV_VIRTADDR	sDisplayDevVAddr;
 
 	DISPLAY_INFO            sDisplayInfo;
 
@@ -213,13 +171,26 @@ typedef struct OMAPLFB_DEVINFO_TAG
 	
 	DISPLAY_DIMS            sDisplayDim;
 
+	
+	OMAPLFB_ATOMIC_BOOL	sBlanked;
+
+	
+	OMAPLFB_ATOMIC_INT	sBlankEvents;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	
+	OMAPLFB_ATOMIC_BOOL	sEarlySuspendFlag;
+
+	struct early_suspend    sEarlySuspend;
+#endif
+
+#if defined(SUPPORT_DRI_DRM)
+	OMAPLFB_ATOMIC_BOOL     sLeaveVT;
+#endif
+
 }  OMAPLFB_DEVINFO;
 
 #define	OMAPLFB_PAGE_SIZE 4096
-#define	OMAPLFB_PAGE_MASK (OMAPLFB_PAGE_SIZE - 1)
-#define	OMAPLFB_PAGE_TRUNC (~OMAPLFB_PAGE_MASK)
-
-#define	OMAPLFB_PAGE_ROUNDUP(x) (((x) + OMAPLFB_PAGE_MASK) & OMAPLFB_PAGE_TRUNC)
 
 #ifdef	DEBUG
 #define	DEBUG_PRINTK(x) printk x
@@ -232,51 +203,67 @@ typedef struct OMAPLFB_DEVINFO_TAG
 #define	DEVNAME	DRVNAME
 #define	DRIVER_PREFIX DRVNAME
 
-typedef enum _OMAP_ERROR_
+typedef enum _OMAPLFB_ERROR_
 {
-	OMAP_OK                             =  0,
-	OMAP_ERROR_GENERIC                  =  1,
-	OMAP_ERROR_OUT_OF_MEMORY            =  2,
-	OMAP_ERROR_TOO_FEW_BUFFERS          =  3,
-	OMAP_ERROR_INVALID_PARAMS           =  4,
-	OMAP_ERROR_INIT_FAILURE             =  5,
-	OMAP_ERROR_CANT_REGISTER_CALLBACK   =  6,
-	OMAP_ERROR_INVALID_DEVICE           =  7,
-	OMAP_ERROR_DEVICE_REGISTER_FAILED   =  8
-} OMAP_ERROR;
-
+	OMAPLFB_OK                             =  0,
+	OMAPLFB_ERROR_GENERIC                  =  1,
+	OMAPLFB_ERROR_OUT_OF_MEMORY            =  2,
+	OMAPLFB_ERROR_TOO_FEW_BUFFERS          =  3,
+	OMAPLFB_ERROR_INVALID_PARAMS           =  4,
+	OMAPLFB_ERROR_INIT_FAILURE             =  5,
+	OMAPLFB_ERROR_CANT_REGISTER_CALLBACK   =  6,
+	OMAPLFB_ERROR_INVALID_DEVICE           =  7,
+	OMAPLFB_ERROR_DEVICE_REGISTER_FAILED   =  8,
+	OMAPLFB_ERROR_SET_UPDATE_MODE_FAILED   =  9
+} OMAPLFB_ERROR;
+
+typedef enum _OMAPLFB_UPDATE_MODE_
+{
+	OMAPLFB_UPDATE_MODE_UNDEFINED			= 0,
+	OMAPLFB_UPDATE_MODE_MANUAL			= 1,
+	OMAPLFB_UPDATE_MODE_AUTO			= 2,
+	OMAPLFB_UPDATE_MODE_DISABLED			= 3
+} OMAPLFB_UPDATE_MODE;
 
 #ifndef UNREFERENCED_PARAMETER
 #define	UNREFERENCED_PARAMETER(param) (param) = (param)
 #endif
 
-OMAP_ERROR OMAPLFBInit(void);
-OMAP_ERROR OMAPLFBDeinit(void);
-
-#ifdef	LDM_PLATFORM
-void OMAPLFBDriverSuspend(void);
-void OMAPLFBDriverResume(void);
-#endif
+OMAPLFB_ERROR OMAPLFBInit(void);
+OMAPLFB_ERROR OMAPLFBDeInit(void);
 
+OMAPLFB_DEVINFO *OMAPLFBGetDevInfoPtr(unsigned uiFBDevID);
+unsigned OMAPLFBMaxFBDevIDPlusOne(void);
 void *OMAPLFBAllocKernelMem(unsigned long ulSize);
 void OMAPLFBFreeKernelMem(void *pvMem);
-OMAP_ERROR OMAPLFBGetLibFuncAddr(char *szFunctionName, PFN_DC_GET_PVRJTABLE *ppfnFuncTable);
-OMAP_ERROR OMAPLFBInstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain);
-OMAP_ERROR OMAPLFBUninstallVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain);
-OMAP_BOOL OMAPLFBVSyncIHandler(OMAPLFB_SWAPCHAIN *psSwapChain);
-void OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain);
-void OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain);
-#if defined (SUPPORT_TI_DSS_FW)
-void OMAPLFBEnableDisplayRegisterAccess(void);
-void OMAPLFBDisableDisplayRegisterAccess(void);
-void OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long aPhyAddr);
-#endif
-#if defined (CONFIG_OMAP2_DSS)
-IMG_VOID OMAPLFBFlipDSS2(OMAPLFB_SWAPCHAIN *psSwapChain,
-                                                  IMG_UINT32 aPhyAddr);
-#endif
+OMAPLFB_ERROR OMAPLFBGetLibFuncAddr(char *szFunctionName, PFN_DC_GET_PVRJTABLE *ppfnFuncTable);
+OMAPLFB_ERROR OMAPLFBCreateSwapQueue (OMAPLFB_SWAPCHAIN *psSwapChain);
+void OMAPLFBDestroySwapQueue(OMAPLFB_SWAPCHAIN *psSwapChain);
+void OMAPLFBInitBufferForSwap(OMAPLFB_BUFFER *psBuffer);
+void OMAPLFBSwapHandler(OMAPLFB_BUFFER *psBuffer);
+void OMAPLFBQueueBufferForSwap(OMAPLFB_SWAPCHAIN *psSwapChain, OMAPLFB_BUFFER *psBuffer);
+void OMAPLFBFlip(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_BUFFER *psBuffer);
+OMAPLFB_UPDATE_MODE OMAPLFBGetUpdateMode(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_BOOL OMAPLFBSetUpdateMode(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_UPDATE_MODE eMode);
+OMAPLFB_BOOL OMAPLFBWaitForVSync(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_BOOL OMAPLFBManualSync(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_BOOL OMAPLFBCheckModeAndSync(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_ERROR OMAPLFBUnblankDisplay(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_ERROR OMAPLFBEnableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo);
+OMAPLFB_ERROR OMAPLFBDisableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBCreateSwapChainLockInit(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBCreateSwapChainLockDeInit(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBCreateSwapChainLock(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBCreateSwapChainUnLock(OMAPLFB_DEVINFO *psDevInfo);
+void OMAPLFBAtomicBoolInit(OMAPLFB_ATOMIC_BOOL *psAtomic, OMAPLFB_BOOL bVal);
+void OMAPLFBAtomicBoolDeInit(OMAPLFB_ATOMIC_BOOL *psAtomic);
+void OMAPLFBAtomicBoolSet(OMAPLFB_ATOMIC_BOOL *psAtomic, OMAPLFB_BOOL bVal);
+OMAPLFB_BOOL OMAPLFBAtomicBoolRead(OMAPLFB_ATOMIC_BOOL *psAtomic);
+void OMAPLFBAtomicIntInit(OMAPLFB_ATOMIC_INT *psAtomic, int iVal);
+void OMAPLFBAtomicIntDeInit(OMAPLFB_ATOMIC_INT *psAtomic);
+void OMAPLFBAtomicIntSet(OMAPLFB_ATOMIC_INT *psAtomic, int iVal);
+int OMAPLFBAtomicIntRead(OMAPLFB_ATOMIC_INT *psAtomic);
+void OMAPLFBAtomicIntInc(OMAPLFB_ATOMIC_INT *psAtomic);
 
-IMG_VOID OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain,
-                                                  IMG_UINT32 aPhyAddr);
 #endif 
 
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_displayclass.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_displayclass.c
index 62cef27a..b1bb8df 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_displayclass.c
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_displayclass.c
@@ -31,146 +31,99 @@
 #include <linux/module.h>
 #include <linux/string.h>
 #include <linux/notifier.h>
-#include <linux/spinlock.h>
 
 #include "img_defs.h"
 #include "servicesext.h"
 #include "kerneldisplay.h"
 #include "omaplfb.h"
 
-static void *gpvAnchor;
+#define OMAPLFB_COMMAND_COUNT		1
 
-static int fb_idx = 0;
+#define	OMAPLFB_VSYNC_SETTLE_COUNT	5
 
-#define OMAPLFB_COMMAND_COUNT		1
+#define	OMAPLFB_MAX_NUM_DEVICES		1 // FB_MAX
+#if (OMAPLFB_MAX_NUM_DEVICES > FB_MAX)
+#error "OMAPLFB_MAX_NUM_DEVICES must not be greater than FB_MAX"
+#endif
 
-static PFN_DC_GET_PVRJTABLE pfnGetPVRJTable = 0;
+static OMAPLFB_DEVINFO *gapsDevInfo[OMAPLFB_MAX_NUM_DEVICES];
 
-static OMAPLFB_DEVINFO * GetAnchorPtr(void)
-{
-	return (OMAPLFB_DEVINFO *)gpvAnchor;
-}
+static PFN_DC_GET_PVRJTABLE gpfnGetPVRJTable = NULL;
 
-static void SetAnchorPtr(OMAPLFB_DEVINFO *psDevInfo)
+static inline unsigned long RoundUpToMultiple(unsigned long x, unsigned long y)
 {
-	gpvAnchor = (void*)psDevInfo;
+	unsigned long div = x / y;
+	unsigned long rem = x % y;
+
+	return (div + ((rem == 0) ? 0 : 1)) * y;
 }
 
-	
-static void FlushInternalVSyncQueue(OMAPLFB_SWAPCHAIN *psSwapChain)
+static unsigned long GCD(unsigned long x, unsigned long y)
 {
-	OMAPLFB_VSYNC_FLIP_ITEM *psFlipItem;
-	unsigned long            ulMaxIndex;
-	unsigned long            i;
-
-	
-	psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulRemoveIndex];
-	ulMaxIndex = psSwapChain->ulBufferCount - 1;
-
-	for(i = 0; i < psSwapChain->ulBufferCount; i++)
+	while (y != 0)
 	{
-		if (psFlipItem->bValid == OMAP_FALSE)
-		{
-			continue;
-		}
-
-		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": FlushInternalVSyncQueue: Flushing swap buffer (index %lu)\n", psSwapChain->ulRemoveIndex));
-
-		if(psFlipItem->bFlipped == OMAP_FALSE)
-		{
-			
-			OMAPLFBFlip(psSwapChain, (unsigned long)psFlipItem->sSysAddr);
-		}
-		
-		if(psFlipItem->bCmdCompleted == OMAP_FALSE)
-		{
-			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": FlushInternalVSyncQueue: Calling command complete for swap buffer (index %lu)\n", psSwapChain->ulRemoveIndex));
+		unsigned long r = x % y;
+		x = y;
+		y = r;
+	}
 
-			psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete((IMG_HANDLE)psFlipItem->hCmdComplete, IMG_TRUE);
-		}
+	return x;
+}
 
-		
-		psSwapChain->ulRemoveIndex++;
-		
-		if(psSwapChain->ulRemoveIndex > ulMaxIndex)
-		{
-			psSwapChain->ulRemoveIndex = 0;
-		}
+static unsigned long LCM(unsigned long x, unsigned long y)
+{
+	unsigned long gcd = GCD(x, y);
 
-		
-		psFlipItem->bFlipped = OMAP_FALSE;
-		psFlipItem->bCmdCompleted = OMAP_FALSE;
-		psFlipItem->bValid = OMAP_FALSE;
-		
-		
-		psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulRemoveIndex];
-	}
+	return (gcd == 0) ? 0 : ((x / gcd) * y);
+}
 
-	psSwapChain->ulInsertIndex = 0;
-	psSwapChain->ulRemoveIndex = 0;
+unsigned OMAPLFBMaxFBDevIDPlusOne(void)
+{
+	return OMAPLFB_MAX_NUM_DEVICES;
 }
 
-static void SetFlushStateInternalNoLock(OMAPLFB_DEVINFO* psDevInfo,
-                                        OMAP_BOOL bFlushState)
+OMAPLFB_DEVINFO *OMAPLFBGetDevInfoPtr(unsigned uiFBDevID)
 {
-	OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
+	WARN_ON(uiFBDevID >= OMAPLFBMaxFBDevIDPlusOne());
 
-	if (psSwapChain == NULL)
+	if (uiFBDevID >= OMAPLFB_MAX_NUM_DEVICES)
 	{
-		return;
+		return NULL;
 	}
 
-	if (bFlushState)
-	{
-		if (psSwapChain->ulSetFlushStateRefCount == 0)
-		{
-			OMAPLFBDisableVSyncInterrupt(psSwapChain);
-			psSwapChain->bFlushCommands = OMAP_TRUE;
-			FlushInternalVSyncQueue(psSwapChain);
-		}
-		psSwapChain->ulSetFlushStateRefCount++;
-	}
-	else
-	{
-		if (psSwapChain->ulSetFlushStateRefCount != 0)
-		{
-			psSwapChain->ulSetFlushStateRefCount--;
-			if (psSwapChain->ulSetFlushStateRefCount == 0)
-			{
-				psSwapChain->bFlushCommands = OMAP_FALSE;
-				OMAPLFBEnableVSyncInterrupt(psSwapChain);
-			}
-		}
-	}
+	return gapsDevInfo[uiFBDevID];
 }
 
-static IMG_VOID SetFlushStateInternal(OMAPLFB_DEVINFO* psDevInfo,
-                                      OMAP_BOOL bFlushState)
+static inline void OMAPLFBSetDevInfoPtr(unsigned uiFBDevID, OMAPLFB_DEVINFO *psDevInfo)
 {
-	unsigned long ulLockFlags;
-
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
+	WARN_ON(uiFBDevID >= OMAPLFB_MAX_NUM_DEVICES);
 
-	SetFlushStateInternalNoLock(psDevInfo, bFlushState);
-
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+	if (uiFBDevID < OMAPLFB_MAX_NUM_DEVICES)
+	{
+		gapsDevInfo[uiFBDevID] = psDevInfo;
+	}
 }
 
-static void SetFlushStateExternal(OMAPLFB_DEVINFO* psDevInfo,
-                                  OMAP_BOOL bFlushState)
+static inline OMAPLFB_BOOL SwapChainHasChanged(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_SWAPCHAIN *psSwapChain)
 {
-	unsigned long ulLockFlags;
+	return (psDevInfo->psSwapChain != psSwapChain) ||
+		(psDevInfo->uiSwapChainID != psSwapChain->uiSwapChainID);
+}
 
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
+static inline OMAPLFB_BOOL DontWaitForVSync(OMAPLFB_DEVINFO *psDevInfo)
+{
+	OMAPLFB_BOOL bDontWait;
 
-	
-	if (psDevInfo->bFlushCommands != bFlushState)
-	{
-		psDevInfo->bFlushCommands = bFlushState;
-		SetFlushStateInternalNoLock(psDevInfo, bFlushState);
-	}
+	bDontWait = OMAPLFBAtomicBoolRead(&psDevInfo->sBlanked) ||
+			OMAPLFBAtomicBoolRead(&psDevInfo->sFlushCommands);
 
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	bDontWait = bDontWait || OMAPLFBAtomicBoolRead(&psDevInfo->sEarlySuspendFlag);
+#endif
+#if defined(SUPPORT_DRI_DRM)
+	bDontWait = bDontWait || OMAPLFBAtomicBoolRead(&psDevInfo->sLeaveVT);
+#endif
+	return bDontWait;
 }
 
 static IMG_VOID SetDCState(IMG_HANDLE hDevice, IMG_UINT32 ui32State)
@@ -180,196 +133,68 @@ static IMG_VOID SetDCState(IMG_HANDLE hDevice, IMG_UINT32 ui32State)
 	switch (ui32State)
 	{
 		case DC_STATE_FLUSH_COMMANDS:
-			SetFlushStateExternal(psDevInfo, OMAP_TRUE);
+			OMAPLFBAtomicBoolSet(&psDevInfo->sFlushCommands, OMAPLFB_TRUE);
 			break;
 		case DC_STATE_NO_FLUSH_COMMANDS:
-			SetFlushStateExternal(psDevInfo, OMAP_FALSE);
+			OMAPLFBAtomicBoolSet(&psDevInfo->sFlushCommands, OMAPLFB_FALSE);
 			break;
 		default:
 			break;
 	}
-
-	return;
 }
 
-static int FrameBufferEvents(struct notifier_block *psNotif,
-                             unsigned long event, void *data)
+static PVRSRV_ERROR OpenDCDevice(IMG_UINT32 uiPVRDevID,
+                                 IMG_HANDLE *phDevice,
+                                 PVRSRV_SYNC_DATA* psSystemBufferSyncData)
 {
 	OMAPLFB_DEVINFO *psDevInfo;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
-	struct fb_event *psFBEvent = (struct fb_event *)data;
-	OMAP_BOOL bBlanked;
-
-	
-	if (event != FB_EVENT_BLANK)
-	{
-		return 0;
-	}
-
-	psDevInfo = GetAnchorPtr();
-	psSwapChain = psDevInfo->psSwapChain;
+	OMAPLFB_ERROR eError;
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
 
-	bBlanked = (*(IMG_INT *)psFBEvent->data != 0) ? OMAP_TRUE: OMAP_FALSE;
-
-	if (bBlanked != psSwapChain->bBlanked)
+	for (i = 0; i < uiMaxFBDevIDPlusOne; i++)
 	{
-		psSwapChain->bBlanked = bBlanked;
-
-		if (bBlanked)
-		{
-			
-			SetFlushStateInternal(psDevInfo, OMAP_TRUE);
-		}
-		else
+		psDevInfo = OMAPLFBGetDevInfoPtr(i);
+		if (psDevInfo != NULL && psDevInfo->uiPVRDevID == uiPVRDevID)
 		{
-			
-			SetFlushStateInternal(psDevInfo, OMAP_FALSE);
+			break;
 		}
 	}
-
-	return 0;
-}
-
-
-static OMAP_ERROR UnblankDisplay(OMAPLFB_DEVINFO *psDevInfo)
-{
-	int res;
-#ifdef FBDEV_PRESENT
-
-	acquire_console_sem();
-	res = fb_blank(psDevInfo->psLINFBInfo, 0);
-	release_console_sem();
-#if !defined (CONFIG_OMAP2_DSS)
-	if (res != 0 && res != -EINVAL)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX
-			": fb_blank failed (%d)", res);
-		return (OMAP_ERROR_GENERIC);
-	}
-#endif
-#endif
-	return (OMAP_OK);
-}
-
-#if defined (CONFIG_OMAP2_DSS)
-#include <linux/workqueue.h>
-struct wq_flip {
-        struct fb_var_screeninfo var;
-            struct fb_info *psLINFBInfo;
-        struct work_struct work;
-};
-struct wq_flip wq_flipdss2;
-
-static void dss2_pan_display (struct work_struct *work)
-{
-    struct wq_flip *ptrwq_flip =
-            container_of(work, struct wq_flip, work);
-    if (ptrwq_flip->psLINFBInfo->fbops->fb_pan_display != NULL) {
-        ptrwq_flip->psLINFBInfo->fbops->fb_pan_display (&ptrwq_flip->var, ptrwq_flip->psLINFBInfo);
-
-    }
-
-}
-
-/*
- *          Flip implementation for DSS2 using fb_pan_display
- *          */
-IMG_VOID OMAPLFBFlipDSS2(OMAPLFB_SWAPCHAIN *psSwapChain,
-                                                  IMG_UINT32 aPhyAddr)
-{
-        OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr ();
-        struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
-        memcpy ( &wq_flipdss2.var, &psLINFBInfo->var, sizeof(struct fb_var_screeninfo));
-    wq_flipdss2.var.yoffset = (aPhyAddr-psLINFBInfo->fix.smem_start)/psLINFBInfo->fix.line_length;
-        wq_flipdss2.psLINFBInfo = psLINFBInfo;
-        schedule_work (&wq_flipdss2.work);
-}
-#endif
-
-
-
-static OMAP_ERROR EnableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
-{
-	int                res;
-	OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
-	OMAP_ERROR         eError;
-
-	
-	memset(&psDevInfo->sLINNotifBlock, 0, sizeof(psDevInfo->sLINNotifBlock));
-
-	psDevInfo->sLINNotifBlock.notifier_call = FrameBufferEvents;
-
-	psSwapChain->bBlanked = OMAP_FALSE;
-
-	res = fb_register_client(&psDevInfo->sLINNotifBlock);
-	if (res != 0)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX
-			": fb_register_client failed (%d)", res);
-
-		return (OMAP_ERROR_GENERIC);
-	}
-
-	eError = UnblankDisplay(psDevInfo);
-	if (eError != OMAP_OK)
+	if (i == uiMaxFBDevIDPlusOne)
 	{
 		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
-			": UnblankDisplay failed (%d)", eError));
-		return eError;
+			": %s: PVR Device %u not found\n", __FUNCTION__, uiPVRDevID));
+		return PVRSRV_ERROR_INVALID_DEVICE;
 	}
 
-	return (OMAP_OK);
-}
-
-static OMAP_ERROR DisableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
-{
-	int res;
-
-	
-	res = fb_unregister_client(&psDevInfo->sLINNotifBlock);
-	if (res != 0)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX
-			": fb_unregister_client failed (%d)", res);
-		return (OMAP_ERROR_GENERIC);
-	}
-
-	return (OMAP_OK);
-}
-
-static PVRSRV_ERROR OpenDCDevice(IMG_UINT32 ui32DeviceID,
-                                 IMG_HANDLE *phDevice,
-                                 PVRSRV_SYNC_DATA* psSystemBufferSyncData)
-{
-	OMAPLFB_DEVINFO *psDevInfo;
-	OMAP_ERROR eError;
-
-	UNREFERENCED_PARAMETER(ui32DeviceID);
-
-	psDevInfo = GetAnchorPtr();
-
 	
 	psDevInfo->sSystemBuffer.psSyncData = psSystemBufferSyncData;
 	
-	eError = UnblankDisplay(psDevInfo);
-	if (eError != OMAP_OK)
+	eError = OMAPLFBUnblankDisplay(psDevInfo);
+	if (eError != OMAPLFB_OK)
 	{
 		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
-			": UnblankDisplay failed (%d)", eError));
-		return (PVRSRV_ERROR_UNBLANK_DISPLAY_FAILED);
+			": %s: Device %u: OMAPLFBUnblankDisplay failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eError));
+		return PVRSRV_ERROR_UNBLANK_DISPLAY_FAILED;
 	}
 
 	
 	*phDevice = (IMG_HANDLE)psDevInfo;
 	
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
 
 static PVRSRV_ERROR CloseDCDevice(IMG_HANDLE hDevice)
 {
-	UNREFERENCED_PARAMETER(hDevice);
+#if defined(SUPPORT_DRI_DRM)
+	OMAPLFB_DEVINFO *psDevInfo = (OMAPLFB_DEVINFO *)hDevice;
 
-	return (PVRSRV_OK);
+	OMAPLFBAtomicBoolSet(&psDevInfo->sLeaveVT, OMAPLFB_FALSE);
+	(void) OMAPLFBUnblankDisplay(psDevInfo);
+#else
+	UNREFERENCED_PARAMETER(hDevice);
+#endif
+	return PVRSRV_OK;
 }
 
 static PVRSRV_ERROR EnumDCFormats(IMG_HANDLE hDevice,
@@ -380,7 +205,7 @@ static PVRSRV_ERROR EnumDCFormats(IMG_HANDLE hDevice,
 	
 	if(!hDevice || !pui32NumFormats)
 	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
@@ -392,7 +217,7 @@ static PVRSRV_ERROR EnumDCFormats(IMG_HANDLE hDevice,
 		psFormat[0] = psDevInfo->sDisplayFormat;
 	}
 
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
 
 static PVRSRV_ERROR EnumDCDims(IMG_HANDLE hDevice, 
@@ -404,7 +229,7 @@ static PVRSRV_ERROR EnumDCDims(IMG_HANDLE hDevice,
 
 	if(!hDevice || !psFormat || !pui32NumDims)
 	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
@@ -417,7 +242,7 @@ static PVRSRV_ERROR EnumDCDims(IMG_HANDLE hDevice,
 		psDim[0] = psDevInfo->sDisplayDim;
 	}
 	
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
 
 
@@ -427,14 +252,14 @@ static PVRSRV_ERROR GetDCSystemBuffer(IMG_HANDLE hDevice, IMG_HANDLE *phBuffer)
 	
 	if(!hDevice || !phBuffer)
 	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
 
 	*phBuffer = (IMG_HANDLE)&psDevInfo->sSystemBuffer;
 
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
 
 
@@ -444,14 +269,14 @@ static PVRSRV_ERROR GetDCInfo(IMG_HANDLE hDevice, DISPLAY_INFO *psDCInfo)
 	
 	if(!hDevice || !psDCInfo)
 	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
 
 	*psDCInfo = psDevInfo->sDisplayInfo;
 
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
 
 static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE        hDevice,
@@ -470,28 +295,30 @@ static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE        hDevice,
 
 	if(!hDevice)
 	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-	
+
 	if(!hBuffer)
 	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
-	psSystemBuffer = (OMAPLFB_BUFFER *)hBuffer;
 
 	if (!ppsSysAddr)
 	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	*ppsSysAddr = &psSystemBuffer->sSysAddr;
-
 	if (!pui32ByteSize)
 	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	psSystemBuffer = (OMAPLFB_BUFFER *)hBuffer;
+
+	*ppsSysAddr = &psSystemBuffer->sSysAddr;
+
 	*pui32ByteSize = (IMG_UINT32)psDevInfo->sFBInfo.ulBufferSize;
 
 	if (ppvCpuVAddr)
@@ -509,7 +336,7 @@ static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE        hDevice,
 		*pbIsContiguous = IMG_TRUE;
 	}
 
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
 
 static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
@@ -525,14 +352,11 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 	OMAPLFB_DEVINFO	*psDevInfo;
 	OMAPLFB_SWAPCHAIN *psSwapChain;
 	OMAPLFB_BUFFER *psBuffer;
-	OMAPLFB_VSYNC_FLIP_ITEM *psVSyncFlips;
 	IMG_UINT32 i;
-	PVRSRV_ERROR eError = PVRSRV_ERROR_NOT_SUPPORTED;
-	unsigned long ulLockFlags;
+	PVRSRV_ERROR eError;
 	IMG_UINT32 ui32BuffersToSkip;
 
 	UNREFERENCED_PARAMETER(ui32OEMFlags);
-	UNREFERENCED_PARAMETER(pui32SwapChainID);
 	
 	
 	if(!hDevice
@@ -541,7 +365,7 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 	|| !ppsSyncData
 	|| !phSwapChain)
 	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
@@ -549,24 +373,29 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 	
 	if (psDevInfo->sDisplayInfo.ui32MaxSwapChains == 0)
 	{
-		return (PVRSRV_ERROR_NOT_SUPPORTED);
+		return PVRSRV_ERROR_NOT_SUPPORTED;
 	}
 
+	OMAPLFBCreateSwapChainLock(psDevInfo);
+
 	
 	if(psDevInfo->psSwapChain != NULL)
 	{
-		return (PVRSRV_ERROR_FLIP_CHAIN_EXISTS);
+		eError = PVRSRV_ERROR_FLIP_CHAIN_EXISTS;
+		goto ExitUnLock;
 	}
 	
 	
 	if(ui32BufferCount > psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers)
 	{
-		return (PVRSRV_ERROR_TOOMANYBUFFERS);
+		eError = PVRSRV_ERROR_TOOMANYBUFFERS;
+		goto ExitUnLock;
 	}
 	
 	if ((psDevInfo->sFBInfo.ulRoundedBufferSize * (unsigned long)ui32BufferCount) > psDevInfo->sFBInfo.ulFBSize)
 	{
-		return (PVRSRV_ERROR_TOOMANYBUFFERS);
+		eError = PVRSRV_ERROR_TOOMANYBUFFERS;
+		goto ExitUnLock;
 	}
 
 	
@@ -579,7 +408,8 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 	|| psDstSurfAttrib->sDims.ui32Height != psDevInfo->sDisplayDim.ui32Height)
 	{
 		
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto ExitUnLock;
 	}		
 
 	if(psDstSurfAttrib->pixelformat != psSrcSurfAttrib->pixelformat
@@ -588,17 +418,25 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 	|| psDstSurfAttrib->sDims.ui32Height != psSrcSurfAttrib->sDims.ui32Height)
 	{
 		
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto ExitUnLock;
 	}		
 
 	
 	UNREFERENCED_PARAMETER(ui32Flags);
 	
+#if defined(PVR_OMAPFB3_UPDATE_MODE)
+	if (!OMAPLFBSetUpdateMode(psDevInfo, PVR_OMAPFB3_UPDATE_MODE))
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't set frame buffer update mode %d\n", __FUNCTION__, psDevInfo->uiFBDevID, PVR_OMAPFB3_UPDATE_MODE);
+	}
+#endif
 	
 	psSwapChain = (OMAPLFB_SWAPCHAIN*)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_SWAPCHAIN));
 	if(!psSwapChain)
 	{
-		return (PVRSRV_ERROR_OUT_OF_MEMORY);
+		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto ExitUnLock;
 	}
 
 	psBuffer = (OMAPLFB_BUFFER*)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_BUFFER) * ui32BufferCount);
@@ -608,20 +446,10 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 		goto ErrorFreeSwapChain;
 	}
 
-	psVSyncFlips = (OMAPLFB_VSYNC_FLIP_ITEM *)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_VSYNC_FLIP_ITEM) * ui32BufferCount);
-	if (!psVSyncFlips)
-	{
-		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-		goto ErrorFreeBuffers;
-	}
-
 	psSwapChain->ulBufferCount = (unsigned long)ui32BufferCount;
 	psSwapChain->psBuffer = psBuffer;
-	psSwapChain->psVSyncFlips = psVSyncFlips;
-	psSwapChain->ulInsertIndex = 0;
-	psSwapChain->ulRemoveIndex = 0;
-	psSwapChain->psPVRJTable = &psDevInfo->sPVRJTable;
-	psSwapChain->psSwapChainLock = &psDevInfo->sSwapChainLock;
+	psSwapChain->bNotVSynced = OMAPLFB_TRUE;
+	psSwapChain->uiFBDevID = psDevInfo->uiFBDevID;
 
 	
 	for(i=0; i<ui32BufferCount-1; i++)
@@ -641,84 +469,51 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 
 		psBuffer[i].sSysAddr.uiAddr = psDevInfo->sFBInfo.sSysAddr.uiAddr + ui32BufferOffset;
 		psBuffer[i].sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr + ui32BufferOffset;
-	}
+		psBuffer[i].ulYOffset = ui32BufferOffset / psDevInfo->sFBInfo.ulByteStride;
+		psBuffer[i].psDevInfo = psDevInfo;
 
-	
-	for(i=0; i<ui32BufferCount; i++)
-	{
-		psVSyncFlips[i].bValid = OMAP_FALSE;
-		psVSyncFlips[i].bFlipped = OMAP_FALSE;
-		psVSyncFlips[i].bCmdCompleted = OMAP_FALSE;
+		OMAPLFBInitBufferForSwap(&psBuffer[i]);
 	}
 
-#if defined (SUPPORT_TI_DSS_FW)
-	OMAPLFBEnableDisplayRegisterAccess();
-
-	
-	psSwapChain->pvRegs = ioremap(psDevInfo->psLINFBInfo->fix.mmio_start, psDevInfo->psLINFBInfo->fix.mmio_len);
-	if (psSwapChain->pvRegs == NULL)
-	{
-		eError = PVRSRV_ERROR_BAD_MAPPING;
-		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't map registers needed for flipping\n");
-		goto ErrorDisableDisplayRegisters;
-	}
-#endif
-	if (OMAPLFBInstallVSyncISR(psSwapChain) != OMAP_OK)
+	if (OMAPLFBCreateSwapQueue(psSwapChain) != OMAPLFB_OK)
 	{ 
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Failed to create workqueue\n", __FUNCTION__, psDevInfo->uiFBDevID);
 		eError = PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR;
-		printk(KERN_WARNING DRIVER_PREFIX ": ISR handler failed to register\n");
-		goto ErrorUnmapRegisters;
+		goto ErrorFreeBuffers;
 	}
 
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	
-	psDevInfo->psSwapChain = psSwapChain;
-
-	
-	psSwapChain->bFlushCommands = psDevInfo->bFlushCommands;
-
-	if (psSwapChain->bFlushCommands)
-	{
-		psSwapChain->ulSetFlushStateRefCount = 1;
-	}
-	else
+	if (OMAPLFBEnableLFBEventNotification(psDevInfo)!= OMAPLFB_OK)
 	{
-		psSwapChain->ulSetFlushStateRefCount = 0;
-		OMAPLFBEnableVSyncInterrupt(psSwapChain);
+		eError = PVRSRV_ERROR_UNABLE_TO_ENABLE_EVENT;
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't enable framebuffer event notification\n", __FUNCTION__, psDevInfo->uiFBDevID);
+		goto ErrorDestroySwapQueue;
 	}
-		
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
 
-	if (EnableLFBEventNotification(psDevInfo)!= OMAP_OK)
+	psDevInfo->uiSwapChainID++;
+	if (psDevInfo->uiSwapChainID == 0)
 	{
-		eError = PVRSRV_ERROR_UNABLE_TO_ENABLE_EVENT;
-		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't enable framebuffer event notification\n");
-		goto ErrorUninstallVSyncInterrupt;
+		psDevInfo->uiSwapChainID++;
 	}
 
-	
+	psSwapChain->uiSwapChainID = psDevInfo->uiSwapChainID;
+
+	psDevInfo->psSwapChain = psSwapChain;
+
+	*pui32SwapChainID = psDevInfo->uiSwapChainID;
+
 	*phSwapChain = (IMG_HANDLE)psSwapChain;
 
-	return (PVRSRV_OK);
+	eError = PVRSRV_OK;
+	goto ExitUnLock;
 
-ErrorUninstallVSyncInterrupt:
-	if(OMAPLFBUninstallVSyncISR(psSwapChain) != OMAP_OK)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't uninstall VSync ISR\n");
-	}
-ErrorUnmapRegisters:
-#if defined (SUPPORT_TI_DSS_FW)
-	iounmap(psSwapChain->pvRegs);
-ErrorDisableDisplayRegisters:
-	OMAPLFBDisableDisplayRegisterAccess();
-#endif
-	OMAPLFBFreeKernelMem(psVSyncFlips);
+ErrorDestroySwapQueue:
+	OMAPLFBDestroySwapQueue(psSwapChain);
 ErrorFreeBuffers:
 	OMAPLFBFreeKernelMem(psBuffer);
 ErrorFreeSwapChain:
 	OMAPLFBFreeKernelMem(psSwapChain);
-
+ExitUnLock:
+	OMAPLFBCreateSwapChainUnLock(psDevInfo);
 	return eError;
 }
 
@@ -727,59 +522,52 @@ static PVRSRV_ERROR DestroyDCSwapChain(IMG_HANDLE hDevice,
 {
 	OMAPLFB_DEVINFO	*psDevInfo;
 	OMAPLFB_SWAPCHAIN *psSwapChain;
-	unsigned long ulLockFlags;
-	OMAP_ERROR eError;
+	OMAPLFB_ERROR eError;
 
+	
 	if(!hDevice || !hSwapChain)
 	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 	
 	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
 	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
-	if (psSwapChain != psDevInfo->psSwapChain)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	eError = DisableLFBEventNotification(psDevInfo);
-	if (eError != OMAP_OK)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't disable framebuffer event notification\n");
-	}
-
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
 
-	OMAPLFBDisableVSyncInterrupt(psSwapChain);
+	OMAPLFBCreateSwapChainLock(psDevInfo);
 
-	
-	FlushInternalVSyncQueue(psSwapChain);
+	if (SwapChainHasChanged(psDevInfo, psSwapChain))
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: Swap chain mismatch\n", __FUNCTION__, psDevInfo->uiFBDevID);
 
-	
-	OMAPLFBFlip(psSwapChain, (unsigned long)psDevInfo->sFBInfo.sSysAddr.uiAddr);
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto ExitUnLock;
+	}
 
 	
-	psDevInfo->psSwapChain = NULL;
-
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+	OMAPLFBDestroySwapQueue(psSwapChain);
 
-	if(OMAPLFBUninstallVSyncISR(psSwapChain) != OMAP_OK)
+	eError = OMAPLFBDisableLFBEventNotification(psDevInfo);
+	if (eError != OMAPLFB_OK)
 	{
-		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't uninstall VSync ISR\n");
-		return (PVRSRV_ERROR_UNABLE_TO_UNINSTALL_ISR);
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't disable framebuffer event notification\n", __FUNCTION__, psDevInfo->uiFBDevID);
 	}
 
-#if defined (SUPPORT_TI_DSS_FW)	
-	iounmap(psSwapChain->pvRegs);
-
-	OMAPLFBDisableDisplayRegisterAccess();
-#endif
 	
-	OMAPLFBFreeKernelMem(psSwapChain->psVSyncFlips);
 	OMAPLFBFreeKernelMem(psSwapChain->psBuffer);
 	OMAPLFBFreeKernelMem(psSwapChain);
 
-	return (PVRSRV_OK);
+	psDevInfo->psSwapChain = NULL;
+
+	OMAPLFBFlip(psDevInfo, &psDevInfo->sSystemBuffer);
+	(void) OMAPLFBCheckModeAndSync(psDevInfo);
+
+	eError = PVRSRV_OK;
+
+ExitUnLock:
+	OMAPLFBCreateSwapChainUnLock(psDevInfo);
+
+	return eError;
 }
 
 static PVRSRV_ERROR SetDCDstRect(IMG_HANDLE hDevice,
@@ -792,7 +580,7 @@ static PVRSRV_ERROR SetDCDstRect(IMG_HANDLE hDevice,
 
 	
 	
-	return (PVRSRV_ERROR_NOT_SUPPORTED);
+	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
 static PVRSRV_ERROR SetDCSrcRect(IMG_HANDLE hDevice,
@@ -805,7 +593,7 @@ static PVRSRV_ERROR SetDCSrcRect(IMG_HANDLE hDevice,
 
 	
 
-	return (PVRSRV_ERROR_NOT_SUPPORTED);
+	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
 static PVRSRV_ERROR SetDCDstColourKey(IMG_HANDLE hDevice,
@@ -818,7 +606,7 @@ static PVRSRV_ERROR SetDCDstColourKey(IMG_HANDLE hDevice,
 
 	
 
-	return (PVRSRV_ERROR_NOT_SUPPORTED);
+	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
 static PVRSRV_ERROR SetDCSrcColourKey(IMG_HANDLE hDevice,
@@ -831,7 +619,7 @@ static PVRSRV_ERROR SetDCSrcColourKey(IMG_HANDLE hDevice,
 
 	
 
-	return (PVRSRV_ERROR_NOT_SUPPORTED);
+	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
 static PVRSRV_ERROR GetDCBuffers(IMG_HANDLE hDevice,
@@ -841,7 +629,8 @@ static PVRSRV_ERROR GetDCBuffers(IMG_HANDLE hDevice,
 {
 	OMAPLFB_DEVINFO   *psDevInfo;
 	OMAPLFB_SWAPCHAIN *psSwapChain;
-	unsigned long      i;
+	PVRSRV_ERROR eError;
+	unsigned i;
 	
 	
 	if(!hDevice 
@@ -849,14 +638,21 @@ static PVRSRV_ERROR GetDCBuffers(IMG_HANDLE hDevice,
 	|| !pui32BufferCount
 	|| !phBuffer)
 	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 	
 	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
 	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
-	if (psSwapChain != psDevInfo->psSwapChain)
+
+	OMAPLFBCreateSwapChainLock(psDevInfo);
+
+	if (SwapChainHasChanged(psDevInfo, psSwapChain))
 	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: Swap chain mismatch\n", __FUNCTION__, psDevInfo->uiFBDevID);
+
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto Exit;
 	}
 	
 	
@@ -868,7 +664,12 @@ static PVRSRV_ERROR GetDCBuffers(IMG_HANDLE hDevice,
 		phBuffer[i] = (IMG_HANDLE)&psSwapChain->psBuffer[i];
 	}
 	
-	return (PVRSRV_OK);
+	eError = PVRSRV_OK;
+
+Exit:
+	OMAPLFBCreateSwapChainUnLock(psDevInfo);
+
+	return eError;
 }
 
 static PVRSRV_ERROR SwapToDCBuffer(IMG_HANDLE hDevice,
@@ -878,137 +679,92 @@ static PVRSRV_ERROR SwapToDCBuffer(IMG_HANDLE hDevice,
                                    IMG_UINT32 ui32ClipRectCount,
                                    IMG_RECT *psClipRect)
 {
-	OMAPLFB_DEVINFO *psDevInfo;
-
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hBuffer);
 	UNREFERENCED_PARAMETER(ui32SwapInterval);
 	UNREFERENCED_PARAMETER(hPrivateTag);
+	UNREFERENCED_PARAMETER(ui32ClipRectCount);
 	UNREFERENCED_PARAMETER(psClipRect);
 	
-	if(!hDevice 
-	|| !hBuffer
-	|| (ui32ClipRectCount != 0))
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-
 	
-	return (PVRSRV_OK);
+
+	return PVRSRV_OK;
 }
 
 static PVRSRV_ERROR SwapToDCSystem(IMG_HANDLE hDevice,
                                    IMG_HANDLE hSwapChain)
 {
-	OMAPLFB_DEVINFO   *psDevInfo;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
-	unsigned long      ulLockFlags;
-
-	if(!hDevice || !hSwapChain)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
-	if (psSwapChain != psDevInfo->psSwapChain)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-	
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
-
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
 	
-	FlushInternalVSyncQueue(psSwapChain);
-
 	
-	OMAPLFBFlip(psSwapChain, (unsigned long)psDevInfo->sFBInfo.sSysAddr.uiAddr);
-
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
 
-OMAP_BOOL OMAPLFBVSyncIHandler(OMAPLFB_SWAPCHAIN *psSwapChain)
+static OMAPLFB_BOOL WaitForVSyncSettle(OMAPLFB_DEVINFO *psDevInfo)
 {
-	OMAP_BOOL bStatus = OMAP_FALSE;
-	OMAPLFB_VSYNC_FLIP_ITEM *psFlipItem;
-	unsigned long ulMaxIndex;
-	unsigned long ulLockFlags;
+		unsigned i;
+		for(i = 0; i < OMAPLFB_VSYNC_SETTLE_COUNT; i++)
+		{
+			if (DontWaitForVSync(psDevInfo) || !OMAPLFBWaitForVSync(psDevInfo))
+			{
+				return OMAPLFB_FALSE;
+			}
+		}
 
-	psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulRemoveIndex];
-	ulMaxIndex = psSwapChain->ulBufferCount - 1;
+		return OMAPLFB_TRUE;
+}
 
-	spin_lock_irqsave(psSwapChain->psSwapChainLock, ulLockFlags);
+void OMAPLFBSwapHandler(OMAPLFB_BUFFER *psBuffer)
+{
+	OMAPLFB_DEVINFO *psDevInfo = psBuffer->psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
+	OMAPLFB_BOOL bPreviouslyNotVSynced;
 
-	
-	if (psSwapChain->bFlushCommands)
+#if defined(SUPPORT_DRI_DRM)
+	if (!OMAPLFBAtomicBoolRead(&psDevInfo->sLeaveVT))
+#endif
 	{
-		goto ExitUnlock;
+		OMAPLFBFlip(psDevInfo, psBuffer);
 	}
 
-	while(psFlipItem->bValid)
-	{	
-		
-		if(psFlipItem->bFlipped)
-		{
-			
-			if(!psFlipItem->bCmdCompleted)
-			{
-				
-				psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete((IMG_HANDLE)psFlipItem->hCmdComplete, IMG_TRUE);
+	bPreviouslyNotVSynced = psSwapChain->bNotVSynced;
+	psSwapChain->bNotVSynced = OMAPLFB_TRUE;
 
-				
-				psFlipItem->bCmdCompleted = OMAP_TRUE;
-			}
 
-			
-			psFlipItem->ulSwapInterval--;
+	if (!DontWaitForVSync(psDevInfo))
+	{
+		OMAPLFB_UPDATE_MODE eMode = OMAPLFBGetUpdateMode(psDevInfo);
+		int iBlankEvents = OMAPLFBAtomicIntRead(&psDevInfo->sBlankEvents);
 
-			
-			if(psFlipItem->ulSwapInterval == 0)
-			{	
-				
-				psSwapChain->ulRemoveIndex++;
-				
-				if(psSwapChain->ulRemoveIndex > ulMaxIndex)
+		switch(eMode)
+		{
+			case OMAPLFB_UPDATE_MODE_AUTO:
+				psSwapChain->bNotVSynced = OMAPLFB_FALSE;
+
+				if (bPreviouslyNotVSynced || psSwapChain->iBlankEvents != iBlankEvents)
 				{
-					psSwapChain->ulRemoveIndex = 0;
+					psSwapChain->iBlankEvents = iBlankEvents;
+					psSwapChain->bNotVSynced = !WaitForVSyncSettle(psDevInfo);
+				} else if (psBuffer->ulSwapInterval != 0)
+				{
+					psSwapChain->bNotVSynced = !OMAPLFBWaitForVSync(psDevInfo);
 				}
-				
-				
-				psFlipItem->bCmdCompleted = OMAP_FALSE;
-				psFlipItem->bFlipped = OMAP_FALSE;
-	
-				
-				psFlipItem->bValid = OMAP_FALSE;
-			}
-			else
-			{
-				
 				break;
-			}
-		}
-		else
-		{
-			
-			OMAPLFBFlip(psSwapChain, (unsigned long)psFlipItem->sSysAddr);
-			
-			
-			psFlipItem->bFlipped = OMAP_TRUE;
-			
-			
-			break;
+#if defined(PVR_OMAPFB3_MANUAL_UPDATE_SYNC_IN_SWAP)
+			case OMAPLFB_UPDATE_MODE_MANUAL:
+				if (psBuffer->ulSwapInterval != 0)
+				{
+					(void) OMAPLFBManualSync(psDevInfo);
+				}
+				break;
+#endif
+			default:
+				break;
 		}
-		
-		
-		psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulRemoveIndex];
 	}
-		
-ExitUnlock:
-	spin_unlock_irqrestore(psSwapChain->psSwapChainLock, ulLockFlags);
 
-	return bStatus;
+	psDevInfo->sPVRJTable.pfnPVRSRVCmdComplete((IMG_HANDLE)psBuffer->hCmdComplete, IMG_TRUE);
 }
 
 static IMG_BOOL ProcessFlip(IMG_HANDLE  hCmdCookie,
@@ -1019,10 +775,6 @@ static IMG_BOOL ProcessFlip(IMG_HANDLE  hCmdCookie,
 	OMAPLFB_DEVINFO *psDevInfo;
 	OMAPLFB_BUFFER *psBuffer;
 	OMAPLFB_SWAPCHAIN *psSwapChain;
-#if defined(SYS_USING_INTERRUPTS)
-	OMAPLFB_VSYNC_FLIP_ITEM* psFlipItem;
-#endif
-	unsigned long ulLockFlags;
 
 	
 	if(!hCmdCookie || !pvData)
@@ -1040,102 +792,73 @@ static IMG_BOOL ProcessFlip(IMG_HANDLE  hCmdCookie,
 
 	
 	psDevInfo = (OMAPLFB_DEVINFO*)psFlipCmd->hExtDevice;
-	
 	psBuffer = (OMAPLFB_BUFFER*)psFlipCmd->hExtBuffer;
 	psSwapChain = (OMAPLFB_SWAPCHAIN*) psFlipCmd->hExtSwapChain;
 
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	
-	if (psDevInfo->bDeviceSuspended)
-	{
-		psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete(hCmdCookie, IMG_TRUE);
-		goto ExitTrueUnlock;
-	}
+	OMAPLFBCreateSwapChainLock(psDevInfo);
 
-#if defined(SYS_USING_INTERRUPTS)
-	
-	if(psFlipCmd->ui32SwapInterval == 0 || psSwapChain->bFlushCommands == OMAP_TRUE)
+	if (SwapChainHasChanged(psDevInfo, psSwapChain))
 	{
-#endif
-		
-		OMAPLFBFlip(psSwapChain, (unsigned long)psBuffer->sSysAddr.uiAddr);
-
 		
-		psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete(hCmdCookie, IMG_TRUE);
-
-#if defined(SYS_USING_INTERRUPTS)
-		goto ExitTrueUnlock;
+		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u (PVR Device ID %u): The swap chain has been destroyed\n",
+			__FUNCTION__, psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID));
 	}
-
-	psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulInsertIndex];
-
-	
-	if(psFlipItem->bValid == OMAP_FALSE)
+	else
 	{
-		unsigned long ulMaxIndex = psSwapChain->ulBufferCount - 1;
-		
-		if(psSwapChain->ulInsertIndex == psSwapChain->ulRemoveIndex)
-		{
-			
-			OMAPLFBFlip(psSwapChain, (unsigned long)psBuffer->sSysAddr.uiAddr);
+		psBuffer->hCmdComplete = (OMAPLFB_HANDLE)hCmdCookie;
+		psBuffer->ulSwapInterval = (unsigned long)psFlipCmd->ui32SwapInterval;
 
-			psFlipItem->bFlipped = OMAP_TRUE;
-		}
-		else
-		{
-			psFlipItem->bFlipped = OMAP_FALSE;
-		}
-
-		psFlipItem->hCmdComplete = (OMAP_HANDLE)hCmdCookie;
-		psFlipItem->ulSwapInterval = (unsigned long)psFlipCmd->ui32SwapInterval;
-		psFlipItem->sSysAddr = &psBuffer->sSysAddr;
-		psFlipItem->bValid = OMAP_TRUE;
-
-		psSwapChain->ulInsertIndex++;
-		if(psSwapChain->ulInsertIndex > ulMaxIndex)
-		{
-			psSwapChain->ulInsertIndex = 0;
-		}
-
-		goto ExitTrueUnlock;
+		OMAPLFBQueueBufferForSwap(psSwapChain, psBuffer);
 	}
-	
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-	return IMG_FALSE;
-#endif
 
-ExitTrueUnlock:
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+	OMAPLFBCreateSwapChainUnLock(psDevInfo);
+
 	return IMG_TRUE;
 }
 
 
-static OMAP_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
+static OMAPLFB_ERROR OMAPLFBInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
 {
 	struct fb_info *psLINFBInfo;
 	struct module *psLINFBOwner;
 	OMAPLFB_FBINFO *psPVRFBInfo = &psDevInfo->sFBInfo;
-	OMAP_ERROR eError = OMAP_ERROR_GENERIC;
+	OMAPLFB_ERROR eError = OMAPLFB_ERROR_GENERIC;
 	unsigned long FBSize;
+	unsigned long ulLCM;
+	unsigned uiFBDevID = psDevInfo->uiFBDevID;
 
-	acquire_console_sem();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_lock();
+#else
+        acquire_console_sem();
+#endif
 
-	if (fb_idx < 0 || fb_idx >= num_registered_fb)
+	psLINFBInfo = registered_fb[uiFBDevID];
+	if (psLINFBInfo == NULL)
 	{
-		eError = OMAP_ERROR_INVALID_DEVICE;
-		goto errRelSem;
+		eError = OMAPLFB_ERROR_INVALID_DEVICE;
+		goto ErrorRelSem;
 	}
 
-	psLINFBInfo = registered_fb[fb_idx];
+	FBSize = (psLINFBInfo->screen_size) != 0 ?
+					psLINFBInfo->screen_size :
+					psLINFBInfo->fix.smem_len;
+
+	
+	if (FBSize == 0 || psLINFBInfo->fix.line_length == 0)
+	{
+		eError = OMAPLFB_ERROR_INVALID_DEVICE;
+		goto ErrorRelSem;
+	}
 
 	psLINFBOwner = psLINFBInfo->fbops->owner;
 	if (!try_module_get(psLINFBOwner))
 	{
 		printk(KERN_INFO DRIVER_PREFIX
-			": Couldn't get framebuffer module\n");
+			": %s: Device %u: Couldn't get framebuffer module\n", __FUNCTION__, uiFBDevID);
 
-		goto errRelSem;
+		goto ErrorRelSem;
 	}
 
 	if (psLINFBInfo->fbops->fb_open != NULL)
@@ -1146,41 +869,43 @@ static OMAP_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
 		if (res != 0)
 		{
 			printk(KERN_INFO DRIVER_PREFIX
-				": Couldn't open framebuffer: %d\n", res);
+				" %s: Device %u: Couldn't open framebuffer(%d)\n", __FUNCTION__, uiFBDevID, res);
 
-			goto errModPut;
+			goto ErrorModPut;
 		}
 	}
 
 	psDevInfo->psLINFBInfo = psLINFBInfo;
 
-	FBSize = (psLINFBInfo->screen_size) != 0 ?
-					psLINFBInfo->screen_size :
-					psLINFBInfo->fix.smem_len;
+	ulLCM = LCM(psLINFBInfo->fix.line_length, OMAPLFB_PAGE_SIZE);
+
 	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer physical address: 0x%lx\n",
-			psLINFBInfo->fix.smem_start));
+			": Device %u: Framebuffer physical address: 0x%lx\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->fix.smem_start));
 	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer virtual address: 0x%lx\n",
-			(unsigned long)psLINFBInfo->screen_base));
+			": Device %u: Framebuffer virtual address: 0x%lx\n",
+			psDevInfo->uiFBDevID, (unsigned long)psLINFBInfo->screen_base));
 	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer size: %lu\n",
-			FBSize));
+			": Device %u: Framebuffer size: %lu\n",
+			psDevInfo->uiFBDevID, FBSize));
 	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer virtual width: %u\n",
-			psLINFBInfo->var.xres_virtual));
+			": Device %u: Framebuffer virtual width: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->var.xres_virtual));
 	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer virtual height: %u\n",
-			psLINFBInfo->var.yres_virtual));
+			": Device %u: Framebuffer virtual height: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->var.yres_virtual));
 	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer width: %u\n",
-			psLINFBInfo->var.xres));
+			": Device %u: Framebuffer width: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->var.xres));
 	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer height: %u\n",
-			psLINFBInfo->var.yres));
+			": Device %u: Framebuffer height: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->var.yres));
 	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer stride: %u\n",
-			psLINFBInfo->fix.line_length));
+			": Device %u: Framebuffer stride: %u\n",
+			psDevInfo->uiFBDevID, psLINFBInfo->fix.line_length));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: LCM of stride and page size: %lu\n",
+			psDevInfo->uiFBDevID, ulLCM));
 
 	
 	psPVRFBInfo->sSysAddr.uiAddr = psLINFBInfo->fix.smem_start;
@@ -1191,13 +916,9 @@ static OMAP_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
 	psPVRFBInfo->ulByteStride =  psLINFBInfo->fix.line_length;
 	psPVRFBInfo->ulFBSize = FBSize;
 	psPVRFBInfo->ulBufferSize = psPVRFBInfo->ulHeight * psPVRFBInfo->ulByteStride;
-
-#ifdef CONFIG_OMAP2_DSS
-    psPVRFBInfo->ulRoundedBufferSize = psPVRFBInfo->ulBufferSize;
-#else
 	
-	psPVRFBInfo->ulRoundedBufferSize = OMAPLFB_PAGE_ROUNDUP(psPVRFBInfo->ulBufferSize);
-#endif
+	psPVRFBInfo->ulRoundedBufferSize = RoundUpToMultiple(psPVRFBInfo->ulBufferSize, ulLCM);
+
 	if(psLINFBInfo->var.bits_per_pixel == 16)
 	{
 		if((psLINFBInfo->var.red.length == 5) &&
@@ -1212,7 +933,7 @@ static OMAP_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
 		}
 		else
 		{
-			printk("Unknown FB format\n");
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown FB format\n", __FUNCTION__, uiFBDevID);
 		}
 	}
 	else if(psLINFBInfo->var.bits_per_pixel == 32)
@@ -1229,12 +950,12 @@ static OMAP_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
 		}
 		else
 		{
-			printk("Unknown FB format\n");
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown FB format\n", __FUNCTION__, uiFBDevID);
 		}
 	}	
 	else
 	{
-		printk("Unknown FB format\n");
+		printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown FB format\n", __FUNCTION__, uiFBDevID);
 	}
 
 	psDevInfo->sFBInfo.ulPhysicalWidthmm =
@@ -1246,25 +967,31 @@ static OMAP_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
 	
 	psDevInfo->sFBInfo.sSysAddr.uiAddr = psPVRFBInfo->sSysAddr.uiAddr;
 	psDevInfo->sFBInfo.sCPUVAddr = psPVRFBInfo->sCPUVAddr;
-#ifdef CONFIG_OMAP2_DSS
-        INIT_WORK (&wq_flipdss2.work, dss2_pan_display);
-#endif
-	eError = OMAP_OK;
-	goto errRelSem;
 
-errModPut:
+	eError = OMAPLFB_OK;
+	goto ErrorRelSem;
+
+ErrorModPut:
 	module_put(psLINFBOwner);
-errRelSem:
-	release_console_sem();
+ErrorRelSem:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_unlock();
+#else
+        release_console_sem();
+#endif
 	return eError;
 }
 
-static void DeInitDev(OMAPLFB_DEVINFO *psDevInfo)
+static void OMAPLFBDeInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
 {
 	struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
 	struct module *psLINFBOwner;
 
-	acquire_console_sem();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_lock();
+#else
+        acquire_console_sem();
+#endif
 
 	psLINFBOwner = psLINFBInfo->fbops->owner;
 
@@ -1274,113 +1001,78 @@ static void DeInitDev(OMAPLFB_DEVINFO *psDevInfo)
 	}
 
 	module_put(psLINFBOwner);
-
-	release_console_sem();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_unlock();
+#else
+        release_console_sem();
+#endif
 }
 
-OMAP_ERROR OMAPLFBInit(void)
+static OMAPLFB_DEVINFO *OMAPLFBInitDev(unsigned uiFBDevID)
 {
-	OMAPLFB_DEVINFO		*psDevInfo;
+	PFN_CMD_PROC	 	pfnCmdProcList[OMAPLFB_COMMAND_COUNT];
+	IMG_UINT32		aui32SyncCountList[OMAPLFB_COMMAND_COUNT][2];
+	OMAPLFB_DEVINFO		*psDevInfo = NULL;
 
-	psDevInfo = GetAnchorPtr();
 	
-	if (psDevInfo == NULL)
-	{
-		PFN_CMD_PROC	 		pfnCmdProcList[OMAPLFB_COMMAND_COUNT];
-		IMG_UINT32				aui32SyncCountList[OMAPLFB_COMMAND_COUNT][2];
-		
-		psDevInfo = (OMAPLFB_DEVINFO *)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_DEVINFO));
-
-		if(!psDevInfo)
-		{
-			return (OMAP_ERROR_OUT_OF_MEMORY);
-		}
+	psDevInfo = (OMAPLFB_DEVINFO *)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_DEVINFO));
 
-		
-		memset(psDevInfo, 0, sizeof(OMAPLFB_DEVINFO));
+	if(psDevInfo == NULL)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: Couldn't allocate device information structure\n", __FUNCTION__, uiFBDevID);
 
-		
-		SetAnchorPtr((void*)psDevInfo);
+		goto ErrorExit;
+	}
 
-		
-		psDevInfo->ulRefCount = 0;
+	
+	memset(psDevInfo, 0, sizeof(OMAPLFB_DEVINFO));
 
-#ifdef FBDEV_PRESENT		
-		if(InitDev(psDevInfo) != OMAP_OK)
-		{
-			return (OMAP_ERROR_INIT_FAILURE);
-		}
-#endif
-		if(OMAPLFBGetLibFuncAddr ("PVRGetDisplayClassJTable", &pfnGetPVRJTable) != OMAP_OK)
-		{
-			return (OMAP_ERROR_INIT_FAILURE);
-		}
+	psDevInfo->uiFBDevID = uiFBDevID;
 
+	
+	if(!(*gpfnGetPVRJTable)(&psDevInfo->sPVRJTable))
+	{
+		goto ErrorFreeDevInfo;
+	}
+#ifdef FBDEV_PRESENT
+	
+	if(OMAPLFBInitFBDev(psDevInfo) != OMAPLFB_OK)
+	{
 		
-		if(!(*pfnGetPVRJTable)(&psDevInfo->sPVRJTable))
-		{
-			return (OMAP_ERROR_INIT_FAILURE);
-		}
+		goto ErrorFreeDevInfo;
+	}
 
-				
-		spin_lock_init(&psDevInfo->sSwapChainLock);
+	psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = (IMG_UINT32)(psDevInfo->sFBInfo.ulFBSize / psDevInfo->sFBInfo.ulRoundedBufferSize);
+	if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers != 0)
+	{
+		psDevInfo->sDisplayInfo.ui32MaxSwapChains = 1;
+		psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 1;
+	}
 
-		psDevInfo->psSwapChain = 0;
-		psDevInfo->bFlushCommands = OMAP_FALSE;
-		psDevInfo->bDeviceSuspended = OMAP_FALSE;
+	psDevInfo->sDisplayInfo.ui32PhysicalWidthmm = psDevInfo->sFBInfo.ulPhysicalWidthmm;
+	psDevInfo->sDisplayInfo.ui32PhysicalHeightmm = psDevInfo->sFBInfo.ulPhysicalHeightmm;
 
-#ifdef FBDEV_PRESENT
-		psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = (IMG_UINT32)(psDevInfo->sFBInfo.ulFBSize / psDevInfo->sFBInfo.ulRoundedBufferSize);
-#if !defined (SUPPORT_TI_DSS_FW)
-                /* DSS2 have trouble with ui32MaxSwapChainBuffers > 3 */
-                if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers > 3)
-                        psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = 3;
-#endif
-#if 1
-                /* for fb_pan_display to work, yres_virtual should be set to number of buffers multiplied yres */  
-                psDevInfo->psLINFBInfo->var.yres_virtual = psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers * psDevInfo->psLINFBInfo->var.yres;
-                if (fb_set_var(psDevInfo->psLINFBInfo, &psDevInfo->psLINFBInfo->var) != 0)
-                {
-                   printk(KERN_INFO DRIVER_PREFIX ": Couldn't set framebuffer paramter: ");
-
-                }
-#endif
+	strncpy(psDevInfo->sDisplayInfo.szDisplayName, DISPLAY_DEVICE_NAME, MAX_DISPLAY_NAME_SIZE);
 
+	psDevInfo->sDisplayFormat.pixelformat = psDevInfo->sFBInfo.ePixelFormat;
+	psDevInfo->sDisplayDim.ui32Width      = (IMG_UINT32)psDevInfo->sFBInfo.ulWidth;
+	psDevInfo->sDisplayDim.ui32Height     = (IMG_UINT32)psDevInfo->sFBInfo.ulHeight;
+	psDevInfo->sDisplayDim.ui32ByteStride = (IMG_UINT32)psDevInfo->sFBInfo.ulByteStride;
 
-		if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers == 0)
-		{
-			psDevInfo->sDisplayInfo.ui32MaxSwapChains = 0;
-			psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 0;
-		}
-		else
-		{
-			psDevInfo->sDisplayInfo.ui32MaxSwapChains = 1;
-			psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 3;
-		}
-		psDevInfo->sDisplayInfo.ui32MinSwapInterval = 0;
-
-		psDevInfo->sDisplayInfo.ui32PhysicalWidthmm = psDevInfo->sFBInfo.ulPhysicalWidthmm;
-		psDevInfo->sDisplayInfo.ui32PhysicalHeightmm = psDevInfo->sFBInfo.ulPhysicalHeightmm;
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+		": Device %u: Maximum number of swap chain buffers: %u\n",
+		psDevInfo->uiFBDevID, psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers));
 
-		strncpy(psDevInfo->sDisplayInfo.szDisplayName, DISPLAY_DEVICE_NAME, MAX_DISPLAY_NAME_SIZE);
 	
-		psDevInfo->sDisplayFormat.pixelformat = psDevInfo->sFBInfo.ePixelFormat;
-		psDevInfo->sDisplayDim.ui32Width      = (IMG_UINT32)psDevInfo->sFBInfo.ulWidth;
-		psDevInfo->sDisplayDim.ui32Height     = (IMG_UINT32)psDevInfo->sFBInfo.ulHeight;
-		psDevInfo->sDisplayDim.ui32ByteStride = (IMG_UINT32)psDevInfo->sFBInfo.ulByteStride;
-
-		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Maximum number of swap chain buffers: %u\n",
-			psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers));
-
-		
-		psDevInfo->sSystemBuffer.sSysAddr = psDevInfo->sFBInfo.sSysAddr;
-		psDevInfo->sSystemBuffer.sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr;
-		psDevInfo->sSystemBuffer.ulBufferSize = psDevInfo->sFBInfo.ulRoundedBufferSize;
+	psDevInfo->sSystemBuffer.sSysAddr = psDevInfo->sFBInfo.sSysAddr;
+	psDevInfo->sSystemBuffer.sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr;
+	psDevInfo->sSystemBuffer.psDevInfo = psDevInfo;
 
+	OMAPLFBInitBufferForSwap(&psDevInfo->sSystemBuffer);
 #else
                 psDevInfo->sSystemBuffer.sCPUVAddr = 0x100;
-                psDevInfo->sSystemBuffer.ulBufferSize = 600*3200;
+//                psDevInfo->sSystemBuffer.ulBufferSize = 600*3200;
 
                 psDevInfo->sDisplayFormat.pixelformat = 20;
                 psDevInfo->sFBInfo.ulWidth      =  800;
@@ -1388,166 +1080,171 @@ OMAP_ERROR OMAPLFBInit(void)
                 psDevInfo->sFBInfo.ulByteStride =  3200;
                 psDevInfo->sFBInfo.ulFBSize     =  8388608;
                 psDevInfo->sFBInfo.ulBufferSize = 600*3200;
-
 #endif
 
-		psDevInfo->sDCJTable.ui32TableSize = sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE);
-		psDevInfo->sDCJTable.pfnOpenDCDevice = OpenDCDevice;
-		psDevInfo->sDCJTable.pfnCloseDCDevice = CloseDCDevice;
-		psDevInfo->sDCJTable.pfnEnumDCFormats = EnumDCFormats;
-		psDevInfo->sDCJTable.pfnEnumDCDims = EnumDCDims;
-		psDevInfo->sDCJTable.pfnGetDCSystemBuffer = GetDCSystemBuffer;
-		psDevInfo->sDCJTable.pfnGetDCInfo = GetDCInfo;
-		psDevInfo->sDCJTable.pfnGetBufferAddr = GetDCBufferAddr;
-		psDevInfo->sDCJTable.pfnCreateDCSwapChain = CreateDCSwapChain;
-		psDevInfo->sDCJTable.pfnDestroyDCSwapChain = DestroyDCSwapChain;
-		psDevInfo->sDCJTable.pfnSetDCDstRect = SetDCDstRect;
-		psDevInfo->sDCJTable.pfnSetDCSrcRect = SetDCSrcRect;
-		psDevInfo->sDCJTable.pfnSetDCDstColourKey = SetDCDstColourKey;
-		psDevInfo->sDCJTable.pfnSetDCSrcColourKey = SetDCSrcColourKey;
-		psDevInfo->sDCJTable.pfnGetDCBuffers = GetDCBuffers;
-		psDevInfo->sDCJTable.pfnSwapToDCBuffer = SwapToDCBuffer;
-		psDevInfo->sDCJTable.pfnSwapToDCSystem = SwapToDCSystem;
-		psDevInfo->sDCJTable.pfnSetDCState = SetDCState;
 
-		
-		if(psDevInfo->sPVRJTable.pfnPVRSRVRegisterDCDevice (
-			&psDevInfo->sDCJTable,
-			&psDevInfo->uiDeviceID ) != PVRSRV_OK)
-		{
-			return (OMAP_ERROR_DEVICE_REGISTER_FAILED);
-		}
-		
-		
-		pfnCmdProcList[DC_FLIP_COMMAND] = ProcessFlip;
+	psDevInfo->sDCJTable.ui32TableSize = sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE);
+	psDevInfo->sDCJTable.pfnOpenDCDevice = OpenDCDevice;
+	psDevInfo->sDCJTable.pfnCloseDCDevice = CloseDCDevice;
+	psDevInfo->sDCJTable.pfnEnumDCFormats = EnumDCFormats;
+	psDevInfo->sDCJTable.pfnEnumDCDims = EnumDCDims;
+	psDevInfo->sDCJTable.pfnGetDCSystemBuffer = GetDCSystemBuffer;
+	psDevInfo->sDCJTable.pfnGetDCInfo = GetDCInfo;
+	psDevInfo->sDCJTable.pfnGetBufferAddr = GetDCBufferAddr;
+	psDevInfo->sDCJTable.pfnCreateDCSwapChain = CreateDCSwapChain;
+	psDevInfo->sDCJTable.pfnDestroyDCSwapChain = DestroyDCSwapChain;
+	psDevInfo->sDCJTable.pfnSetDCDstRect = SetDCDstRect;
+	psDevInfo->sDCJTable.pfnSetDCSrcRect = SetDCSrcRect;
+	psDevInfo->sDCJTable.pfnSetDCDstColourKey = SetDCDstColourKey;
+	psDevInfo->sDCJTable.pfnSetDCSrcColourKey = SetDCSrcColourKey;
+	psDevInfo->sDCJTable.pfnGetDCBuffers = GetDCBuffers;
+	psDevInfo->sDCJTable.pfnSwapToDCBuffer = SwapToDCBuffer;
+	psDevInfo->sDCJTable.pfnSwapToDCSystem = SwapToDCSystem;
+	psDevInfo->sDCJTable.pfnSetDCState = SetDCState;
 
-		
-		aui32SyncCountList[DC_FLIP_COMMAND][0] = 0; 
-		aui32SyncCountList[DC_FLIP_COMMAND][1] = 2; 
+	
+	if(psDevInfo->sPVRJTable.pfnPVRSRVRegisterDCDevice(
+		&psDevInfo->sDCJTable,
+		&psDevInfo->uiPVRDevID) != PVRSRV_OK)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: PVR Services device registration failed\n", __FUNCTION__, uiFBDevID);
 
-		
+		goto ErrorDeInitFBDev;
+	}
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+		": Device %u: PVR Device ID: %u\n",
+		psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID));
+	
+	
+	pfnCmdProcList[DC_FLIP_COMMAND] = ProcessFlip;
 
+	
+	aui32SyncCountList[DC_FLIP_COMMAND][0] = 0; 
+	aui32SyncCountList[DC_FLIP_COMMAND][1] = 2; 
 
+	
 
-		if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterCmdProcList (psDevInfo->uiDeviceID,
-																&pfnCmdProcList[0],
-																aui32SyncCountList,
-																OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
-		{
-			printk(KERN_WARNING DRIVER_PREFIX ": Can't register callback\n");
-			return (OMAP_ERROR_CANT_REGISTER_CALLBACK);
-		}
 
+
+	if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterCmdProcList(psDevInfo->uiPVRDevID,
+															&pfnCmdProcList[0],
+															aui32SyncCountList,
+															OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
+	{
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: Couldn't register command processing functions with PVR Services\n", __FUNCTION__, uiFBDevID);
+		goto ErrorUnregisterDevice;
 	}
 
-	
-	psDevInfo->ulRefCount++;
+	OMAPLFBCreateSwapChainLockInit(psDevInfo);
 
-	
-	return (OMAP_OK);
-	
-	}
+	OMAPLFBAtomicBoolInit(&psDevInfo->sBlanked, OMAPLFB_FALSE);
+	OMAPLFBAtomicIntInit(&psDevInfo->sBlankEvents, 0);
+	OMAPLFBAtomicBoolInit(&psDevInfo->sFlushCommands, OMAPLFB_FALSE);
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	OMAPLFBAtomicBoolInit(&psDevInfo->sEarlySuspendFlag, OMAPLFB_FALSE);
+#endif
+#if defined(SUPPORT_DRI_DRM)
+	OMAPLFBAtomicBoolInit(&psDevInfo->sLeaveVT, OMAPLFB_FALSE);
+#endif
+	return psDevInfo;
+
+ErrorUnregisterDevice:
+	(void)psDevInfo->sPVRJTable.pfnPVRSRVRemoveDCDevice(psDevInfo->uiPVRDevID);
+ErrorDeInitFBDev:
+	OMAPLFBDeInitFBDev(psDevInfo);
+ErrorFreeDevInfo:
+	OMAPLFBFreeKernelMem(psDevInfo);
+ErrorExit:
+	return NULL;
+}
 
-OMAP_ERROR OMAPLFBDeinit(void)
+OMAPLFB_ERROR OMAPLFBInit(void)
 {
-	OMAPLFB_DEVINFO *psDevInfo, *psDevFirst;
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+	unsigned uiDevicesFound = 0;
 
-	psDevFirst = GetAnchorPtr();
-	psDevInfo = psDevFirst;
-
-	
-	if (psDevInfo == NULL)
+	if(OMAPLFBGetLibFuncAddr ("PVRGetDisplayClassJTable", &gpfnGetPVRJTable) != OMAPLFB_OK)
 	{
-		return (OMAP_ERROR_GENERIC);
+		return OMAPLFB_ERROR_INIT_FAILURE;
 	}
 
 	
-	psDevInfo->ulRefCount--;
-
-	if (psDevInfo->ulRefCount == 0)
+	for(i = uiMaxFBDevIDPlusOne; i-- != 0;)
 	{
-		
-		PVRSRV_DC_DISP2SRV_KMJTABLE	*psJTable = &psDevInfo->sPVRJTable;
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBInitDev(i);
 
-		if (psDevInfo->sPVRJTable.pfnPVRSRVRemoveCmdProcList (psDevInfo->uiDeviceID, OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
+		if (psDevInfo != NULL)
 		{
-			return (OMAP_ERROR_GENERIC);
-		}
-
-		
-		if (psJTable->pfnPVRSRVRemoveDCDevice(psDevInfo->uiDeviceID) != PVRSRV_OK)
-		{
-			return (OMAP_ERROR_GENERIC);
+			
+			OMAPLFBSetDevInfoPtr(psDevInfo->uiFBDevID, psDevInfo);
+			uiDevicesFound++;
 		}
-#ifdef FBDEV_PRESENT		
-		DeInitDev(psDevInfo);
-#endif
-		
-		OMAPLFBFreeKernelMem(psDevInfo);
 	}
-	
-	
-	SetAnchorPtr(NULL);
 
-	
-	return (OMAP_OK);
+	return (uiDevicesFound != 0) ? OMAPLFB_OK : OMAPLFB_ERROR_INIT_FAILURE;
 }
 
-
-#if defined(LDM_PLATFORM)
-void OMAPLFBDriverSuspend(void)
+static OMAPLFB_BOOL OMAPLFBDeInitDev(OMAPLFB_DEVINFO *psDevInfo)
 {
-	OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr();
-	unsigned long    ulLockFlags;
+	PVRSRV_DC_DISP2SRV_KMJTABLE *psPVRJTable = &psDevInfo->sPVRJTable;
 
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
+	OMAPLFBCreateSwapChainLockDeInit(psDevInfo);
 
-	if (psDevInfo->bDeviceSuspended)
+	OMAPLFBAtomicBoolDeInit(&psDevInfo->sBlanked);
+	OMAPLFBAtomicIntDeInit(&psDevInfo->sBlankEvents);
+	OMAPLFBAtomicBoolDeInit(&psDevInfo->sFlushCommands);
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	OMAPLFBAtomicBoolDeInit(&psDevInfo->sEarlySuspendFlag);
+#endif
+#if defined(SUPPORT_DRI_DRM)
+	OMAPLFBAtomicBoolDeInit(&psDevInfo->sLeaveVT);
+#endif
+	psPVRJTable = &psDevInfo->sPVRJTable;
+
+	if (psPVRJTable->pfnPVRSRVRemoveCmdProcList (psDevInfo->uiPVRDevID, OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
 	{
-		goto ExitUnlock;
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: PVR Device %u: Couldn't unregister command processing functions\n", __FUNCTION__, psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID);
+		return OMAPLFB_FALSE;
 	}
-	psDevInfo->bDeviceSuspended = OMAP_TRUE;
 
 	
-	SetFlushStateInternalNoLock(psDevInfo, OMAP_TRUE);
-
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-#if defined (SUPPORT_TI_DSS_FW)	
-	if (psDevInfo->psSwapChain != NULL)
+	if (psPVRJTable->pfnPVRSRVRemoveDCDevice(psDevInfo->uiPVRDevID) != PVRSRV_OK)
 	{
-		OMAPLFBDisableDisplayRegisterAccess();
+		printk(KERN_ERR DRIVER_PREFIX
+			": %s: Device %u: PVR Device %u: Couldn't remove device from PVR Services\n", __FUNCTION__, psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID);
+		return OMAPLFB_FALSE;
 	}
+#ifdef FBDEV_PRESENT	
+	OMAPLFBDeInitFBDev(psDevInfo);
 #endif
-	return;
+	OMAPLFBSetDevInfoPtr(psDevInfo->uiFBDevID, NULL);
+
+	
+	OMAPLFBFreeKernelMem(psDevInfo);
 
-ExitUnlock:
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+	return OMAPLFB_TRUE;
 }
 
-void OMAPLFBDriverResume(void)
+OMAPLFB_ERROR OMAPLFBDeInit(void)
 {
-	OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr();
-	unsigned long    ulLockFlags;
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+	OMAPLFB_BOOL bError = OMAPLFB_FALSE;
 
-	if (psDevInfo->bDeviceSuspended == OMAP_FALSE)
+	for(i = 0; i < uiMaxFBDevIDPlusOne; i++)
 	{
-		return;
-	}
-#if defined (SUPPORT_TI_DSS_FW)
-	if (psDevInfo->psSwapChain != NULL)
-	{
-		OMAPLFBEnableDisplayRegisterAccess();
-	}
-#endif
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBGetDevInfoPtr(i);
 
-	
-	SetFlushStateInternalNoLock(psDevInfo, OMAP_FALSE);
-
-	psDevInfo->bDeviceSuspended = OMAP_FALSE;
+		if (psDevInfo != NULL)
+		{
+			bError |= !OMAPLFBDeInitDev(psDevInfo);
+		}
+	}
 
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+	return (bError) ? OMAPLFB_ERROR_INIT_FAILURE : OMAPLFB_OK;
 }
-#endif
 
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_linux.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_linux.c
index dc219cd..74134c6 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_linux.c
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_linux.c
@@ -24,63 +24,89 @@
  *
  ******************************************************************************/
 
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
+#endif
 
-#include <linux/version.h>
-#include <linux/module.h>
-
-#include <linux/pci.h>
-#include <asm/uaccess.h>
-#include <linux/slab.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
 
-#include <plat/ti81xx-vpss.h>
+#include <asm/atomic.h>
 
-#if defined(LDM_PLATFORM)
-#include <linux/platform_device.h>
-#endif 
+#if defined(SUPPORT_DRI_DRM)
+#include <drm/drmP.h>
+#else
+#include <linux/module.h>
+#endif
 
-#if defined (SUPPORT_TI_DSS_FW)
-#include <asm/io.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/hardirq.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+// #include <linux/omapfb.h>
+#include <linux/mutex.h>
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
-#include <plat/display.h>
-#else 
-#include <mach/display.h>
-#endif 
-#else 
-#include <asm/arch-omap/display.h>
-#endif 
+# include <plat/ti81xx-vpss.h>
+# include <plat/vrfb.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+#define PVR_OMAPFB3_NEEDS_PLAT_VRFB_H
+#endif
 
+#if defined(PVR_OMAPFB3_NEEDS_PLAT_VRFB_H)
+# include <plat/vrfb.h>
 #else
-#if !defined (CONFIG_OMAP2_DSS)
-#define DISPC_IRQ_VSYNC 0x0002
-extern int omap_dispc_request_irq(unsigned long, void (*)(void *), void *);
-extern void omap_dispc_free_irq(unsigned long, void (*)(void *), void *);
-extern void omap_dispc_set_plane_base(int plane, IMG_UINT32 phys_addr);
-#else
-#include <plat/display.h>
-#include <linux/console.h>
-#include <linux/fb.h>
-static omap_dispc_isr_t *pOMAPLFBVSyncISRHandle = NULL;
-#endif
+# if defined(PVR_OMAPFB3_NEEDS_MACH_VRFB_H)
+#  include <mach/vrfb.h>
+# endif
 #endif
 
-
+#if defined(DEBUG)
+#define	PVR_DEBUG DEBUG
+#undef DEBUG
+#endif
+//#include <omapfb/omapfb.h>
+#if defined(DEBUG)
+#undef DEBUG
+#endif
+#if defined(PVR_DEBUG)
+#define	DEBUG PVR_DEBUG
+#undef PVR_DEBUG
+#endif
 
 #include "img_defs.h"
 #include "servicesext.h"
 #include "kerneldisplay.h"
 #include "omaplfb.h"
 #include "pvrmodule.h"
+#if defined(SUPPORT_DRI_DRM)
+#include "pvr_drm.h"
+#include "3rdparty_dc_drm_shared.h"
+#endif
+
+#if 0
+#if !defined(PVR_LINUX_USING_WORKQUEUES)
+#error "PVR_LINUX_USING_WORKQUEUES must be defined"
+#endif
+#endif
 
 MODULE_SUPPORTED_DEVICE(DEVNAME);
 
-#define unref__ __attribute__ ((unused))
+#if 0
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+#define OMAP_DSS_DRIVER(drv, dev) struct omap_dss_driver *drv = (dev) != NULL ? (dev)->driver : NULL
+#define OMAP_DSS_MANAGER(man, dev) struct omap_overlay_manager *man = (dev) != NULL ? (dev)->manager : NULL
+#define	WAIT_FOR_VSYNC(man)	((man)->wait_for_vsync)
+#else
+#define OMAP_DSS_DRIVER(drv, dev) struct omap_dss_device *drv = (dev)
+#define OMAP_DSS_MANAGER(man, dev) struct omap_dss_device *man = (dev)
+#define	WAIT_FOR_VSYNC(man)	((man)->wait_vsync)
+#endif
+#endif
 
 void *OMAPLFBAllocKernelMem(unsigned long ulSize)
 {
@@ -92,366 +118,709 @@ void OMAPLFBFreeKernelMem(void *pvMem)
 	kfree(pvMem);
 }
 
-
-OMAP_ERROR OMAPLFBGetLibFuncAddr (char *szFunctionName, PFN_DC_GET_PVRJTABLE *ppfnFuncTable)
+void OMAPLFBCreateSwapChainLockInit(OMAPLFB_DEVINFO *psDevInfo)
 {
-	if(strcmp("PVRGetDisplayClassJTable", szFunctionName) != 0)
-	{
-		return (OMAP_ERROR_INVALID_PARAMS);
-	}
-
-	
-	*ppfnFuncTable = PVRGetDisplayClassJTable;
-
-	return (OMAP_OK);
+	mutex_init(&psDevInfo->sCreateSwapChainMutex);
 }
 
-
-#if defined(SYS_USING_INTERRUPTS)
-
-#if defined(SUPPORT_OMAP3430_OMAPFB3)
-
-static void OMAPLFBVSyncISR(void *arg, u32 mask)
+void OMAPLFBCreateSwapChainLockDeInit(OMAPLFB_DEVINFO *psDevInfo)
 {
-	OMAPLFB_SWAPCHAIN *psSwapChain= (OMAPLFB_SWAPCHAIN *)arg;
-	(void) OMAPLFBVSyncIHandler(psSwapChain);
-     //   printk (" VSync ISR \n");
+	mutex_destroy(&psDevInfo->sCreateSwapChainMutex);
 }
 
-static inline int OMAPLFBRegisterVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+void OMAPLFBCreateSwapChainLock(OMAPLFB_DEVINFO *psDevInfo)
 {
-	return omap_dispc_register_isr(OMAPLFBVSyncISR, psSwapChain,
-								   DISPC_IRQ_VSYNC);
+	mutex_lock(&psDevInfo->sCreateSwapChainMutex);
 }
 
-static inline int OMAPLFBUnregisterVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+void OMAPLFBCreateSwapChainUnLock(OMAPLFB_DEVINFO *psDevInfo)
 {
-	return omap_dispc_unregister_isr(OMAPLFBVSyncISR, psSwapChain,
-									 DISPC_IRQ_VSYNC);
+	mutex_unlock(&psDevInfo->sCreateSwapChainMutex);
 }
 
-#else 
+void OMAPLFBAtomicBoolInit(OMAPLFB_ATOMIC_BOOL *psAtomic, OMAPLFB_BOOL bVal)
+{
+	atomic_set(psAtomic, (int)bVal);
+}
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
-static void OMAPLFBVSyncISR(void *arg)
-#else
-static void OMAPLFBVSyncISR(void *arg, struct pt_regs unref__ *regs)
-#endif
+void OMAPLFBAtomicBoolDeInit(OMAPLFB_ATOMIC_BOOL *psAtomic)
 {
-	OMAPLFB_SWAPCHAIN *psSwapChain= (OMAPLFB_SWAPCHAIN *)arg;
-	(void) OMAPLFBVSyncIHandler(psSwapChain);
 }
 
-static inline int OMAPLFBRegisterVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+void OMAPLFBAtomicBoolSet(OMAPLFB_ATOMIC_BOOL *psAtomic, OMAPLFB_BOOL bVal)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
-	return omap_dispc_request_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain);
-#else
-	return omap2_disp_register_isr(OMAPLFBVSyncISR, psSwapChain,
-								   DISPC_IRQSTATUS_VSYNC);
-#endif
+	atomic_set(psAtomic, (int)bVal);
 }
 
-static inline int OMAPLFBUnregisterVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+OMAPLFB_BOOL OMAPLFBAtomicBoolRead(OMAPLFB_ATOMIC_BOOL *psAtomic)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
-	omap_dispc_free_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain);
-	return 0;
-#else
-	return omap2_disp_unregister_isr(OMAPLFBVSyncISR);
-#endif
+	return (OMAPLFB_BOOL)atomic_read(psAtomic);
 }
 
-#endif 
+void OMAPLFBAtomicIntInit(OMAPLFB_ATOMIC_INT *psAtomic, int iVal)
+{
+	atomic_set(psAtomic, iVal);
+}
 
-#endif 
+void OMAPLFBAtomicIntDeInit(OMAPLFB_ATOMIC_INT *psAtomic)
+{
+}
 
-#if !defined (SUPPORT_TI_DSS_FW)
+void OMAPLFBAtomicIntSet(OMAPLFB_ATOMIC_INT *psAtomic, int iVal)
+{
+	atomic_set(psAtomic, iVal);
+}
 
-IMG_VOID OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
+int OMAPLFBAtomicIntRead(OMAPLFB_ATOMIC_INT *psAtomic)
 {
-        if (pOMAPLFBVSyncISRHandle == NULL)
-                OMAPLFBInstallVSyncISR (psSwapChain);
+	return atomic_read(psAtomic);
 }
 
-IMG_VOID OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
+void OMAPLFBAtomicIntInc(OMAPLFB_ATOMIC_INT *psAtomic)
 {
-        if (pOMAPLFBVSyncISRHandle != NULL)
-                OMAPLFBUninstallVSyncISR (psSwapChain);
+	atomic_inc(psAtomic);
 }
-#else
 
-static void OMAPLFBVSyncWriteReg(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long ulOffset, unsigned long ulValue)
+OMAPLFB_ERROR OMAPLFBGetLibFuncAddr (char *szFunctionName, PFN_DC_GET_PVRJTABLE *ppfnFuncTable)
 {
-	void *pvRegAddr = (void *)((char *)psSwapChain->pvRegs + ulOffset);
+	if(strcmp("PVRGetDisplayClassJTable", szFunctionName) != 0)
+	{
+		return (OMAPLFB_ERROR_INVALID_PARAMS);
+	}
 
 	
-	writel(ulValue, pvRegAddr);
+	*ppfnFuncTable = PVRGetDisplayClassJTable;
+
+	return (OMAPLFB_OK);
 }
 
-static unsigned long OMAPLFBVSyncReadReg(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long ulOffset)
+void OMAPLFBQueueBufferForSwap(OMAPLFB_SWAPCHAIN *psSwapChain, OMAPLFB_BUFFER *psBuffer)
 {
-	return readl((char *)psSwapChain->pvRegs + ulOffset);
+	int res = queue_work(psSwapChain->psWorkQueue, &psBuffer->sWork);
+
+	if (res == 0)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Buffer already on work queue\n", __FUNCTION__, psSwapChain->uiFBDevID);
+	}
 }
 
-void OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
+static void WorkQueueHandler(struct work_struct *psWork)
 {
-#if defined(SYS_USING_INTERRUPTS)
-	
-	unsigned long ulInterruptEnable  = OMAPLFBVSyncReadReg(psSwapChain, OMAPLCD_IRQENABLE);
-	ulInterruptEnable |= OMAPLCD_INTMASK_VSYNC;
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_IRQENABLE, ulInterruptEnable );
-#endif
+	OMAPLFB_BUFFER *psBuffer = container_of(psWork, OMAPLFB_BUFFER, sWork);
+
+	OMAPLFBSwapHandler(psBuffer);
 }
 
-void OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
+OMAPLFB_ERROR OMAPLFBCreateSwapQueue(OMAPLFB_SWAPCHAIN *psSwapChain)
 {
-#if defined(SYS_USING_INTERRUPTS)
-	
-	unsigned long ulInterruptEnable = OMAPLFBVSyncReadReg(psSwapChain, OMAPLCD_IRQENABLE);
-	ulInterruptEnable &= ~(OMAPLCD_INTMASK_VSYNC);
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_IRQENABLE, ulInterruptEnable);
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,34))
+        psSwapChain->psWorkQueue = __create_workqueue(DEVNAME, 1, 1, 1);
+#else	
+	psSwapChain->psWorkQueue = create_workqueue(DEVNAME);
 #endif
+	if (psSwapChain->psWorkQueue == NULL)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: create_singlethreaded_workqueue failed\n", __FUNCTION__, psSwapChain->uiFBDevID);
+
+		return (OMAPLFB_ERROR_INIT_FAILURE);
+	}
+
+	return (OMAPLFB_OK);
 }
-#endif
 
-#if !defined (SUPPORT_TI_DSS_FW)
-OMAP_ERROR OMAPLFBInstallVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+void OMAPLFBInitBufferForSwap(OMAPLFB_BUFFER *psBuffer)
 {
-#if !defined (CONFIG_OMAP2_DSS)
-        if (omap_dispc_request_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain) != 0)
-#else
-        int ret;
-#ifdef FBDEV_PRESENT
-	ret = vps_grpx_register_isr ((vsync_callback_t)OMAPLFBVSyncISR, psSwapChain, 0); // fb_idx = 0
-#endif
-//        if (ret == 0) 
-             pOMAPLFBVSyncISRHandle  = (omap_dispc_isr_t *)NULL;
-  //      else 
-    //        pOMAPLFBVSyncISRHandle = NULL;
-
-        if (pOMAPLFBVSyncISRHandle != NULL)
-#endif
-                return PVRSRV_ERROR_OUT_OF_MEMORY; /* not worth a proper mapping */
-        return OMAP_OK;
+	INIT_WORK(&psBuffer->sWork, WorkQueueHandler);
 }
 
+void OMAPLFBDestroySwapQueue(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+	destroy_workqueue(psSwapChain->psWorkQueue);
+}
 
-OMAP_ERROR OMAPLFBUninstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain)
+void OMAPLFBFlip(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_BUFFER *psBuffer)
 {
-#if !defined (CONFIG_OMAP2_DSS)
-        omap_dispc_free_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain);
+	struct fb_var_screeninfo sFBVar;
+	int res;
+	unsigned long ulYResVirtual;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_lock();
 #else
-        int ret;
-#ifdef FBDEV_PRESENT
-        ret = vps_grpx_unregister_isr((vsync_callback_t) OMAPLFBVSyncISR, (void *)psSwapChain, 0); // fb_idx = 0
-#endif
+        acquire_console_sem();
 #endif
-        return OMAP_OK;
-}
 
+	sFBVar = psDevInfo->psLINFBInfo->var;
 
-IMG_VOID OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain,
-                                                  IMG_UINT32 aPhyAddr)
-{
-#if !defined (CONFIG_OMAP2_DSS)
-        omap_dispc_set_plane_base(0, aPhyAddr);
+	sFBVar.xoffset = 0;
+	sFBVar.yoffset = psBuffer->ulYOffset;
+
+	ulYResVirtual = psBuffer->ulYOffset + sFBVar.yres;
+
+	
+	if (sFBVar.xres_virtual != sFBVar.xres || sFBVar.yres_virtual < ulYResVirtual)
+	{
+		sFBVar.xres_virtual = sFBVar.xres;
+		sFBVar.yres_virtual = ulYResVirtual;
+
+		sFBVar.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
+
+		res = fb_set_var(psDevInfo->psLINFBInfo, &sFBVar);
+		if (res != 0)
+		{
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: fb_set_var failed (Y Offset: %lu, Error: %d)\n", __FUNCTION__, psDevInfo->uiFBDevID, psBuffer->ulYOffset, res);
+		}
+	}
+	else
+	{
+		res = fb_pan_display(psDevInfo->psLINFBInfo, &sFBVar);
+		if (res != 0)
+		{
+                        printk (" fb_pan api failed \n");
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: fb_pan_display failed (Y Offset: %lu, Error: %d)\n", __FUNCTION__, psDevInfo->uiFBDevID, psBuffer->ulYOffset, res);
+		}
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_unlock();
 #else
-        OMAPLFBFlipDSS2 (psSwapChain, aPhyAddr);
+        release_console_sem();
 #endif
 }
-#else
 
-OMAP_ERROR OMAPLFBInstallVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+OMAPLFB_UPDATE_MODE OMAPLFBGetUpdateMode(OMAPLFB_DEVINFO *psDevInfo)
 {
-#if defined(SYS_USING_INTERRUPTS)
-	OMAPLFBDisableVSyncInterrupt(psSwapChain);
+#if 0
+	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
+	OMAP_DSS_DRIVER(psDSSDrv, psDSSDev);
 
-	if (OMAPLFBRegisterVSyncISR(psSwapChain))
+	enum omap_dss_update_mode eMode;
+
+	if (psDSSDrv == NULL || psDSSDrv->get_update_mode == NULL)
 	{
-		printk(KERN_INFO DRIVER_PREFIX ": OMAPLFBInstallVSyncISR: Request OMAPLCD IRQ failed\n");
-		return (OMAP_ERROR_INIT_FAILURE);
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Can't get update mode\n", __FUNCTION__, psDevInfo->uiFBDevID));
+		return OMAPLFB_UPDATE_MODE_UNDEFINED;
 	}
 
+	eMode = psDSSDrv->get_update_mode(psDSSDev);
+	switch(eMode)
+	{
+		case OMAP_DSS_UPDATE_AUTO:
+			return OMAPLFB_UPDATE_MODE_AUTO;
+		case OMAP_DSS_UPDATE_MANUAL:
+			return OMAPLFB_UPDATE_MODE_MANUAL;
+		case OMAP_DSS_UPDATE_DISABLED:
+			return OMAPLFB_UPDATE_MODE_DISABLED;
+		default:
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown update mode (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eMode));
+			break;
+	}
+
+	return OMAPLFB_UPDATE_MODE_UNDEFINED;
 #endif
-	return (OMAP_OK);
+        return OMAPLFB_UPDATE_MODE_AUTO;
 }
 
-
-OMAP_ERROR OMAPLFBUninstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain)
+OMAPLFB_BOOL OMAPLFBSetUpdateMode(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_UPDATE_MODE eMode)
 {
-#if defined(SYS_USING_INTERRUPTS)
-	OMAPLFBDisableVSyncInterrupt(psSwapChain);
+#if 0
+	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
+	OMAP_DSS_DRIVER(psDSSDrv, psDSSDev);
+	enum omap_dss_update_mode eDSSMode;
+	int res;
 
-	OMAPLFBUnregisterVSyncISR(psSwapChain);
+	if (psDSSDrv == NULL || psDSSDrv->set_update_mode == NULL)
+	{
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Can't set update mode\n", __FUNCTION__, psDevInfo->uiFBDevID));
+		return OMAPLFB_FALSE;
+	}
 
+	switch(eMode)
+	{
+		case OMAPLFB_UPDATE_MODE_AUTO:
+			eDSSMode = OMAP_DSS_UPDATE_AUTO;
+			break;
+		case OMAPLFB_UPDATE_MODE_MANUAL:
+			eDSSMode = OMAP_DSS_UPDATE_MANUAL;
+			break;
+		case OMAPLFB_UPDATE_MODE_DISABLED:
+			eDSSMode = OMAP_DSS_UPDATE_DISABLED;
+			break;
+		default:
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown update mode (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eMode));
+			return OMAPLFB_FALSE;
+	}
+
+	res = psDSSDrv->set_update_mode(psDSSDev, eDSSMode);
+	if (res != 0)
+	{
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: set_update_mode failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res));
+	}
+
+	return (res == 0);
 #endif
-	return (OMAP_OK);
+        return 1;
 }
 
-void OMAPLFBEnableDisplayRegisterAccess(void)
+OMAPLFB_BOOL OMAPLFBWaitForVSync(OMAPLFB_DEVINFO *psDevInfo)
 {
-#if !defined(SUPPORT_OMAP3430_OMAPFB3)
-	omap2_disp_get_dss();
+
+#if 0
+	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
+	OMAP_DSS_MANAGER(psDSSMan, psDSSDev);
+
+	if (psDSSMan != NULL && WAIT_FOR_VSYNC(psDSSMan) != NULL)
+	{
+		int res = WAIT_FOR_VSYNC(psDSSMan)(psDSSMan);
+		if (res != 0)
+		{
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Wait for vsync failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res));
+			return OMAPLFB_FALSE;
+		}
+	}
+#endif
+#if 0
+        struct vps_grpx_ctrl *gctrl;
+        int r;
+        gctrl = vps_grpx_get_ctrl(psDevInfo->uiFBDevID); 
+        printk (" BVSYNC \n");
+        r = gctrl->wait_for_vsync(gctrl);
+        printk (" AVSYNC: %d\n", vsync_num++);
+        return OMAPLFB_TRUE;
 #endif
+//    unsigned long timeout = msecs_to_jiffies(500);
+
+#if FBDEV_PRESENT
+      int r;
+
+      void grpx_irq_wait_handler(void *data)
+      {
+          complete((struct completion *)data);
+      }
+      DECLARE_COMPLETION_ONSTACK(completion);
+
+      if (vps_grpx_register_isr ((vsync_callback_t)grpx_irq_wait_handler, &completion, psDevInfo->uiFBDevID) != 0)
+      {
+          printk (KERN_WARNING DRIVER_PREFIX ": Failed to register for vsync call back\n");
+          return OMAPLFB_FALSE;
+      }
+//    timeout = wait_for_completion_interruptible_timeout(&completion, timeout);
+      r = wait_for_completion_interruptible(&completion);
+      if (vps_grpx_unregister_isr((vsync_callback_t)grpx_irq_wait_handler , &completion, psDevInfo->uiFBDevID) != 0)
+      {
+          printk (KERN_WARNING DRIVER_PREFIX ": Failed to un-register for vsync call back\n");
+          return OMAPLFB_FALSE;
+      }
+#endif
+      return OMAPLFB_TRUE;
 }
 
-void OMAPLFBDisableDisplayRegisterAccess(void)
+OMAPLFB_BOOL OMAPLFBManualSync(OMAPLFB_DEVINFO *psDevInfo)
 {
-#if !defined(SUPPORT_OMAP3430_OMAPFB3)
-	omap2_disp_put_dss();
+#if 0
+	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
+	OMAP_DSS_DRIVER(psDSSDrv, psDSSDev);
+
+	if (psDSSDrv != NULL && psDSSDrv->sync != NULL)
+	{
+		int res = psDSSDrv->sync(psDSSDev);
+		if (res != 0)
+		{
+			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Sync failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res);
+			return OMAPLFB_FALSE;
+		}
+	}
 #endif
+
+	return OMAPLFB_TRUE;
 }
 
+OMAPLFB_BOOL OMAPLFBCheckModeAndSync(OMAPLFB_DEVINFO *psDevInfo)
+{
+	OMAPLFB_UPDATE_MODE eMode = OMAPLFBGetUpdateMode(psDevInfo);
+
+	switch(eMode)
+	{
+		case OMAPLFB_UPDATE_MODE_AUTO:
+		case OMAPLFB_UPDATE_MODE_MANUAL:
+			return OMAPLFBManualSync(psDevInfo);
+		default:
+			break;
+	}
 
-void OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long aPhyAddr)
+	return OMAPLFB_TRUE;
+}
+
+static int OMAPLFBFrameBufferEvents(struct notifier_block *psNotif,
+                             unsigned long event, void *data)
 {
-	unsigned long control;
+	OMAPLFB_DEVINFO *psDevInfo;
+	struct fb_event *psFBEvent = (struct fb_event *)data;
+	struct fb_info *psFBInfo = psFBEvent->info;
+	OMAPLFB_BOOL bBlanked;
 
 	
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_GFX_BA0, aPhyAddr);
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_GFX_BA1, aPhyAddr);
+	if (event != FB_EVENT_BLANK)
+	{
+		return 0;
+	}
 
-	control = OMAPLFBVSyncReadReg(psSwapChain, OMAPLCD_CONTROL);
-	control |= OMAP_CONTROL_GOLCD;
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_CONTROL, control);
-}
+	bBlanked = (*(IMG_INT *)psFBEvent->data != 0) ? OMAPLFB_TRUE: OMAPLFB_FALSE;
+
+	psDevInfo = OMAPLFBGetDevInfoPtr(psFBInfo->node);
+
+#if 0
+	if (psDevInfo != NULL)
+	{
+		if (bBlanked)
+		{
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Blank event received\n", __FUNCTION__, psDevInfo->uiFBDevID));
+		}
+		else
+		{
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unblank event received\n", __FUNCTION__, psDevInfo->uiFBDevID));
+		}
+	}
+	else
+	{
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Blank/Unblank event for unknown framebuffer\n", __FUNCTION__, psFBInfo->node));
+	}
 #endif
 
-#if defined(LDM_PLATFORM)
+	if (psDevInfo != NULL)
+	{
+		OMAPLFBAtomicBoolSet(&psDevInfo->sBlanked, bBlanked);
+		OMAPLFBAtomicIntInc(&psDevInfo->sBlankEvents);
+	}
 
-static OMAP_BOOL bDeviceSuspended;
+	return 0;
+}
 
-static void OMAPLFBCommonSuspend(void)
+OMAPLFB_ERROR OMAPLFBUnblankDisplay(OMAPLFB_DEVINFO *psDevInfo)
 {
-	if (bDeviceSuspended)
+	int res;
+#ifdef FBDEV_PRESENT
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_lock();
+#else
+        acquire_console_sem();
+#endif
+	res = fb_blank(psDevInfo->psLINFBInfo, 0);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_unlock();
+#else
+        release_console_sem();
+#endif	
+	if (res != 0 && res != -EINVAL)
 	{
-		return;
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: fb_blank failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res);
+		return (OMAPLFB_ERROR_GENERIC);
 	}
+#endif
+
+	return (OMAPLFB_OK);
+}
 
-	OMAPLFBDriverSuspend();
+#ifdef CONFIG_HAS_EARLYSUSPEND
 
-	bDeviceSuspended = OMAP_TRUE;
+static void OMAPLFBBlankDisplay(OMAPLFB_DEVINFO *psDevInfo)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_lock();
+#else
+        acquire_console_sem();
+#endif
+	fb_blank(psDevInfo->psLINFBInfo, 1);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        console_unlock();
+#else
+        release_console_sem();
+#endif
 }
 
-static int OMAPLFBDriverSuspend_Entry(struct platform_device unref__ *pDevice, pm_message_t unref__ state)
+static void OMAPLFBEarlySuspendHandler(struct early_suspend *h)
 {
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverSuspend_Entry\n"));
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
 
-	OMAPLFBCommonSuspend();
+	for (i=0; i < uiMaxFBDevIDPlusOne; i++)
+	{
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBGetDevInfoPtr(i);
 
-	return 0;
+		if (psDevInfo != NULL)
+		{
+			OMAPLFBAtomicBoolSet(&psDevInfo->sEarlySuspendFlag, OMAPLFB_TRUE);
+			OMAPLFBBlankDisplay(psDevInfo);
+		}
+	}
 }
 
-static int OMAPLFBDriverResume_Entry(struct platform_device unref__ *pDevice)
+static void OMAPLFBEarlyResumeHandler(struct early_suspend *h)
 {
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverResume_Entry\n"));
-
-	OMAPLFBDriverResume();
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
 
-	bDeviceSuspended = OMAP_FALSE;
+	for (i=0; i < uiMaxFBDevIDPlusOne; i++)
+	{
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBGetDevInfoPtr(i);
 
-	return 0;
+		if (psDevInfo != NULL)
+		{
+			OMAPLFBUnblankDisplay(psDevInfo);
+			OMAPLFBAtomicBoolSet(&psDevInfo->sEarlySuspendFlag, OMAPLFB_FALSE);
+		}
+	}
 }
 
-static IMG_VOID OMAPLFBDriverShutdown_Entry(struct platform_device unref__ *pDevice)
+#endif 
+
+OMAPLFB_ERROR OMAPLFBEnableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
 {
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverShutdown_Entry\n"));
+	int                res;
+	OMAPLFB_ERROR         eError;
 
-	OMAPLFBCommonSuspend();
-}
+	
+	memset(&psDevInfo->sLINNotifBlock, 0, sizeof(psDevInfo->sLINNotifBlock));
 
-static struct platform_driver omaplfb_driver = {
-	.driver = {
-		.name		= DRVNAME,
-	},
-	.suspend	= OMAPLFBDriverSuspend_Entry,
-	.resume		= OMAPLFBDriverResume_Entry,
-	.shutdown	= OMAPLFBDriverShutdown_Entry,
-};
+	psDevInfo->sLINNotifBlock.notifier_call = OMAPLFBFrameBufferEvents;
 
-#if defined(MODULE)
+	OMAPLFBAtomicBoolSet(&psDevInfo->sBlanked, OMAPLFB_FALSE);
+	OMAPLFBAtomicIntSet(&psDevInfo->sBlankEvents, 0);
 
-static void OMAPLFBDeviceRelease_Entry(struct device unref__ *pDevice)
-{
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverRelease_Entry\n"));
+	res = fb_register_client(&psDevInfo->sLINNotifBlock);
+	if (res != 0)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: fb_register_client failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res);
 
-	OMAPLFBCommonSuspend();
-}
+		return (OMAPLFB_ERROR_GENERIC);
+	}
 
-static struct platform_device omaplfb_device = {
-	.name			= DEVNAME,
-	.id				= -1,
-	.dev 			= {
-		.release		= OMAPLFBDeviceRelease_Entry
+	eError = OMAPLFBUnblankDisplay(psDevInfo);
+	if (eError != OMAPLFB_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: UnblankDisplay failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eError);
+		return eError;
 	}
-};
 
-#endif  
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	psDevInfo->sEarlySuspend.suspend = OMAPLFBEarlySuspendHandler;
+	psDevInfo->sEarlySuspend.resume = OMAPLFBEarlyResumeHandler;
+	psDevInfo->sEarlySuspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	register_early_suspend(&psDevInfo->sEarlySuspend);
+#endif
 
-#endif	
+	return (OMAPLFB_OK);
+}
 
-static int __init OMAPLFB_Init(void)
+OMAPLFB_ERROR OMAPLFBDisableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
 {
-#if defined(LDM_PLATFORM)
-	int error;
+	int res;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&psDevInfo->sEarlySuspend);
 #endif
 
-	if(OMAPLFBInit() != OMAP_OK)
+	
+	res = fb_unregister_client(&psDevInfo->sLINNotifBlock);
+	if (res != 0)
 	{
-		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: OMAPLFBInit failed\n");
-		return -ENODEV;
+		printk(KERN_WARNING DRIVER_PREFIX
+			": %s: Device %u: fb_unregister_client failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res);
+		return (OMAPLFB_ERROR_GENERIC);
 	}
 
-#if defined(LDM_PLATFORM)
-	if ((error = platform_driver_register(&omaplfb_driver)) != 0)
+	OMAPLFBAtomicBoolSet(&psDevInfo->sBlanked, OMAPLFB_FALSE);
+
+	return (OMAPLFB_OK);
+}
+
+#if defined(SUPPORT_DRI_DRM) && defined(PVR_DISPLAY_CONTROLLER_DRM_IOCTL)
+static OMAPLFB_DEVINFO *OMAPLFBPVRDevIDToDevInfo(unsigned uiPVRDevID)
+{
+	unsigned uiMaxFBDevIDPlusOne = OMAPLFBMaxFBDevIDPlusOne();
+	unsigned i;
+
+	for (i=0; i < uiMaxFBDevIDPlusOne; i++)
 	{
-		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: Unable to register platform driver (%d)\n", error);
+		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBGetDevInfoPtr(i);
 
-		goto ExitDeinit;
+		if (psDevInfo->uiPVRDevID == uiPVRDevID)
+		{
+			return psDevInfo;
+		}
 	}
 
-#if defined(MODULE)
-	if ((error = platform_device_register(&omaplfb_device)) != 0)
+	printk(KERN_WARNING DRIVER_PREFIX
+		": %s: PVR Device %u: Couldn't find device\n", __FUNCTION__, uiPVRDevID);
+
+	return NULL;
+}
+
+int PVR_DRM_MAKENAME(omaplfb, _Ioctl)(struct drm_device unref__ *dev, void *arg, struct drm_file unref__ *pFile)
+{
+	uint32_t *puiArgs;
+	uint32_t uiCmd;
+	unsigned uiPVRDevID;
+	int ret = 0;
+	OMAPLFB_DEVINFO *psDevInfo;
+
+	if (arg == NULL)
 	{
-		platform_driver_unregister(&omaplfb_driver);
+		return -EFAULT;
+	}
 
-		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: Unable to register platform device (%d)\n", error);
+	puiArgs = (uint32_t *)arg;
+	uiCmd = puiArgs[PVR_DRM_DISP_ARG_CMD];
+	uiPVRDevID = puiArgs[PVR_DRM_DISP_ARG_DEV];
 
-		goto ExitDeinit;
+	psDevInfo = OMAPLFBPVRDevIDToDevInfo(uiPVRDevID);
+	if (psDevInfo == NULL)
+	{
+		return -EINVAL;
 	}
+
+
+	switch (uiCmd)
+	{
+		case PVR_DRM_DISP_CMD_LEAVE_VT:
+		case PVR_DRM_DISP_CMD_ENTER_VT:
+		{
+			OMAPLFB_BOOL bLeaveVT = (uiCmd == PVR_DRM_DISP_CMD_LEAVE_VT);
+			DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: PVR Device %u: %s\n",
+				__FUNCTION__, uiPVRDevID,
+				bLeaveVT ? "Leave VT" : "Enter VT"));
+
+			OMAPLFBCreateSwapChainLock(psDevInfo);
+			
+			OMAPLFBAtomicBoolSet(&psDevInfo->sLeaveVT, bLeaveVT);
+			if (psDevInfo->psSwapChain != NULL)
+			{
+				flush_workqueue(psDevInfo->psSwapChain->psWorkQueue);
+
+				if (bLeaveVT)
+				{
+					OMAPLFBFlip(psDevInfo, &psDevInfo->sSystemBuffer);
+					(void) OMAPLFBCheckModeAndSync(psDevInfo);
+				}
+			}
+
+			OMAPLFBCreateSwapChainUnLock(psDevInfo);
+			(void) OMAPLFBUnblankDisplay(psDevInfo);
+			break;
+		}
+		case PVR_DRM_DISP_CMD_ON:
+		case PVR_DRM_DISP_CMD_STANDBY:
+		case PVR_DRM_DISP_CMD_SUSPEND:
+		case PVR_DRM_DISP_CMD_OFF:
+		{
+			int iFBMode;
+#if defined(DEBUG)
+			{
+				const char *pszMode;
+				switch(uiCmd)
+				{
+					case PVR_DRM_DISP_CMD_ON:
+						pszMode = "On";
+						break;
+					case PVR_DRM_DISP_CMD_STANDBY:
+						pszMode = "Standby";
+						break;
+					case PVR_DRM_DISP_CMD_SUSPEND:
+						pszMode = "Suspend";
+						break;
+					case PVR_DRM_DISP_CMD_OFF:
+						pszMode = "Off";
+						break;
+					default:
+						pszMode = "(Unknown Mode)";
+						break;
+				}
+				printk (KERN_WARNING DRIVER_PREFIX ": %s: PVR Device %u: Display %s\n",
+				__FUNCTION__, uiPVRDevID, pszMode);
+			}
+#endif
+			switch(uiCmd)
+			{
+				case PVR_DRM_DISP_CMD_ON:
+					iFBMode = FB_BLANK_UNBLANK;
+					break;
+				case PVR_DRM_DISP_CMD_STANDBY:
+					iFBMode = FB_BLANK_HSYNC_SUSPEND;
+					break;
+				case PVR_DRM_DISP_CMD_SUSPEND:
+					iFBMode = FB_BLANK_VSYNC_SUSPEND;
+					break;
+				case PVR_DRM_DISP_CMD_OFF:
+					iFBMode = FB_BLANK_POWERDOWN;
+					break;
+				default:
+					return -EINVAL;
+			}
+
+			OMAPLFBCreateSwapChainLock(psDevInfo);
+
+			if (psDevInfo->psSwapChain != NULL)
+			{
+				flush_workqueue(psDevInfo->psSwapChain->psWorkQueue);
+			}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        		console_lock();
+#else
+        		acquire_console_sem();
+#endif
+			ret = fb_blank(psDevInfo->psLINFBInfo, iFBMode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+        		console_unlock();
+#else
+        		release_console_sem();
 #endif
+			OMAPLFBCreateSwapChainUnLock(psDevInfo);
+
+			break;
+		}
+		default:
+		{
+			ret = -EINVAL;
+			break;
+		}
+	}
 
-#endif 
+	return ret;
+}
+#endif
 
-	return 0;
+#if defined(SUPPORT_DRI_DRM)
+int PVR_DRM_MAKENAME(omaplfb, _Init)(struct drm_device unref__ *dev)
+#else
+static int __init OMAPLFB_Init(void)
+#endif
+{
 
-#if defined(LDM_PLATFORM)
-ExitDeinit:
-	if(OMAPLFBDeinit() != OMAP_OK)
+	if(OMAPLFBInit() != OMAPLFB_OK)
 	{
-		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: OMAPLFBDeinit failed\n");
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: OMAPLFBInit failed\n", __FUNCTION__);
+		return -ENODEV;
 	}
 
-	return -ENODEV;
-#endif 
+	return 0;
+
 }
 
-static IMG_VOID __exit OMAPLFB_Cleanup(IMG_VOID)
-{    
-#if defined (LDM_PLATFORM)
-#if defined (MODULE)
-	platform_device_unregister(&omaplfb_device);
-#endif
-	platform_driver_unregister(&omaplfb_driver);
+#if defined(SUPPORT_DRI_DRM)
+void PVR_DRM_MAKENAME(omaplfb, _Cleanup)(struct drm_device unref__ *dev)
+#else
+static void __exit OMAPLFB_Cleanup(void)
 #endif
-
-	if(OMAPLFBDeinit() != OMAP_OK)
+{    
+	if(OMAPLFBDeInit() != OMAPLFB_OK)
 	{
-		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Cleanup: OMAPLFBDeinit failed\n");
+		printk(KERN_WARNING DRIVER_PREFIX ": %s: OMAPLFBDeInit failed\n", __FUNCTION__);
 	}
 }
 
-module_init(OMAPLFB_Init);
+#if !defined(SUPPORT_DRI_DRM)
+late_initcall(OMAPLFB_Init);
 module_exit(OMAPLFB_Cleanup);
-
+#endif
diff --git a/drivers/staging/omap3-sgx/services4/include/sgxinfo.h b/drivers/staging/omap3-sgx/services4/include/sgxinfo.h
index eaef12f..2deaa7a 100644
--- a/drivers/staging/omap3-sgx/services4/include/sgxinfo.h
+++ b/drivers/staging/omap3-sgx/services4/include/sgxinfo.h
@@ -94,6 +94,20 @@ typedef struct _SGX_BRIDGE_INIT_INFO_
 #if defined(FIX_HW_BRN_29823)
 	IMG_HANDLE	hKernelDummyTermStreamMemInfo;
 #endif
+
+#if defined(FIX_HW_BRN_31542)
+	IMG_HANDLE hKernelClearClipWAVDMStreamMemInfo;
+	IMG_HANDLE hKernelClearClipWAIndexStreamMemInfo;
+	IMG_HANDLE hKernelClearClipWAPDSMemInfo;
+	IMG_HANDLE hKernelClearClipWAUSEMemInfo;
+	IMG_HANDLE hKernelClearClipWAParamMemInfo;
+	IMG_HANDLE hKernelClearClipWAPMPTMemInfo;
+	IMG_HANDLE hKernelClearClipWADPMLSSMemInfo;
+	IMG_HANDLE hKernelClearClipWATPCMemInfo;
+	IMG_HANDLE hKernelClearClipWAPSGRgnHdrMemInfo;
+	IMG_HANDLE hKernelClearClipWAPartiPIMMemInfo;
+#endif
+
 #if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
 	IMG_HANDLE	hKernelEDMStatusBufferMemInfo;
 #endif
@@ -175,6 +189,7 @@ typedef struct _SGX_CCB_KICK_
 #if (defined(NO_HARDWARE) || defined(PDUMP))
 	IMG_BOOL	bTerminateOrAbort;
 #endif
+	IMG_BOOL	bLastInScene;
 
 	
 	IMG_UINT32	ui32CCBOffset;
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.c b/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.c
index 55e5647..b727ed9 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.c
@@ -3096,7 +3096,7 @@ static PVRSRV_ERROR ModifyCompleteSyncOpsCallBack(IMG_PVOID		pvParam,
 				goto OpFlushedComplete;
 			}
 			PVR_DPF((PVR_DBG_WARNING, "ModifyCompleteSyncOpsCallBack: waiting for current Ops to flush"));
-			OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
+			OSSleepms(1);
 		} END_LOOP_UNTIL_TIMEOUT();
 		
 		PVR_DPF((PVR_DBG_ERROR, "ModifyCompleteSyncOpsCallBack: timeout whilst waiting for current Ops to flush."));
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/bridged/sgx/bridged_sgx_bridge.c b/drivers/staging/omap3-sgx/services4/srvkm/bridged/sgx/bridged_sgx_bridge.c
index e1b7320..7e5a63c 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/bridged/sgx/bridged_sgx_bridge.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/bridged/sgx/bridged_sgx_bridge.c
@@ -961,6 +961,89 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 	}
 #endif
 
+#if defined(FIX_HW_BRN_31542)
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAVDMStreamMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAIndexStreamMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPDSMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAUSEMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAParamMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPMPTMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWADPMLSSMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWATPCMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPSGRgnHdrMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPartiPIMMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+#endif
+
 #if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
 	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
 						   &hDummy,
@@ -1128,6 +1211,90 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 	}
 #endif
 
+
+#if defined(FIX_HW_BRN_31542)
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAVDMStreamMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAVDMStreamMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAIndexStreamMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAIndexStreamMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPDSMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPDSMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAUSEMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAUSEMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAParamMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAParamMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPMPTMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPMPTMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWADPMLSSMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWADPMLSSMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWATPCMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWATPCMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPSGRgnHdrMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPSGRgnHdrMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPartiPIMMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPartiPIMMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+#endif
+
 #if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
 	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
 						   &psSGXDevInitPart2IN->sInitInfo.hKernelEDMStatusBufferMemInfo,
@@ -1251,6 +1418,29 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
 #endif
 
+#if defined(FIX_HW_BRN_31542)
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAVDMStreamMemInfo);
+	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAIndexStreamMemInfo);
+	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPDSMemInfo);
+	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAUSEMemInfo);
+	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAParamMemInfo);
+	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPMPTMemInfo);
+	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWADPMLSSMemInfo);
+	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWATPCMemInfo);
+	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPSGRgnHdrMemInfo);
+	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelClearClipWAPartiPIMMemInfo);
+	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+#endif
+
 #if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
 	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelEDMStatusBufferMemInfo);
 	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/metrics.c b/drivers/staging/omap3-sgx/services4/srvkm/common/metrics.c
index ee5cabd..fcba425 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/metrics.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/metrics.c
@@ -77,6 +77,8 @@ IMG_UINT32 PVRSRVTimeNow(IMG_VOID)
 
 static IMG_UINT32 PVRSRVGetCPUFreq(IMG_VOID)
 {
+
+
 	IMG_UINT32 ui32Time1, ui32Time2;
 
 	ui32Time1 = PVRSRVTimeNow();
@@ -93,6 +95,7 @@ static IMG_UINT32 PVRSRVGetCPUFreq(IMG_VOID)
 
 IMG_VOID PVRSRVSetupMetricTimers(IMG_VOID *pvDevInfo)
 {
+
 	IMG_UINT32 ui32Loop;
 
 	PVR_UNREFERENCED_PARAMETER(pvDevInfo);
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/pvrsrv.c b/drivers/staging/omap3-sgx/services4/srvkm/common/pvrsrv.c
index 6e19974..9194966 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/pvrsrv.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/pvrsrv.c
@@ -613,32 +613,44 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVDeinitialiseDevice(IMG_UINT32 ui32DevIndex)
 
 
 IMG_EXPORT
-PVRSRV_ERROR IMG_CALLCONV PollForValueKM (volatile IMG_UINT32* pui32LinMemAddr,
-										  IMG_UINT32 ui32Value,
-										  IMG_UINT32 ui32Mask,
-										  IMG_UINT32 ui32Waitus,
-										  IMG_UINT32 ui32Tries)
+PVRSRV_ERROR IMG_CALLCONV PollForValueKM (volatile IMG_UINT32*	pui32LinMemAddr,
+										  IMG_UINT32			ui32Value,
+										  IMG_UINT32			ui32Mask,
+										  IMG_UINT32			ui32Timeoutus,
+										  IMG_UINT32			ui32PollPeriodus,
+										  IMG_BOOL				bAllowPreemption)
 {
 	{
 		IMG_UINT32	ui32ActualValue = 0xFFFFFFFFU; 
-		IMG_UINT32	uiMaxTime = ui32Tries * ui32Waitus;
+
+		if (bAllowPreemption)
+		{
+			PVR_ASSERT(ui32PollPeriodus >= 1000);
+		}
 
 		 
-		LOOP_UNTIL_TIMEOUT(uiMaxTime)
+		LOOP_UNTIL_TIMEOUT(ui32Timeoutus)
 		{
 			ui32ActualValue = (*pui32LinMemAddr & ui32Mask);
 			if(ui32ActualValue == ui32Value)
 			{
 				return PVRSRV_OK;
 			}
-			OSWaitus(ui32Waitus);
+			
+			if (bAllowPreemption)
+			{
+				OSSleepms(ui32PollPeriodus / 1000);
+			}
+			else
+			{
+				OSWaitus(ui32PollPeriodus);
+			}
 		} END_LOOP_UNTIL_TIMEOUT();
 	
 		PVR_DPF((PVR_DBG_ERROR,"PollForValueKM: Timeout. Expected 0x%x but found 0x%x (mask 0x%x).",
 				ui32Value, ui32ActualValue, ui32Mask));
 	}
 
-
 	return PVRSRV_ERROR_TIMEOUT;
 }
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/queue.c b/drivers/staging/omap3-sgx/services4/srvkm/common/queue.c
index afd30a8..b6c4cda 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/queue.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/queue.c
@@ -342,7 +342,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyCommandQueueKM(PVRSRV_QUEUE_INFO *psQueue
 			bTimeout = IMG_FALSE;
 			break;
 		}
-		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
+		OSSleepms(1);
 	} END_LOOP_UNTIL_TIMEOUT();
 
 	if (bTimeout)
@@ -460,7 +460,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetQueueSpaceKM(PVRSRV_QUEUE_INFO *psQueue,
 			bTimeout = IMG_FALSE;
 			break;
 		}
-		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
+		OSSleepms(1);
 	} END_LOOP_UNTIL_TIMEOUT();
 
 	if (bTimeout == IMG_TRUE)
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/resman.c b/drivers/staging/omap3-sgx/services4/srvkm/common/resman.c
index 6ae4ce2..bc127ac 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/resman.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/resman.c
@@ -27,12 +27,14 @@
 #include "services_headers.h"
 #include "resman.h"
 
+#include <linux/version.h>
 #ifdef __linux__
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
  #include <linux/config.h>
 #endif
+#endif
 
-#include <linux/version.h>
 #include <linux/sched.h>
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,9)
 #include <linux/hardirq.h>
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxconfig.h b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxconfig.h
index a0ca3e9..f8e467d 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxconfig.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxconfig.h
@@ -87,14 +87,19 @@
 #endif 
 
 #if SGX_FEATURE_ADDRESS_SPACE_SIZE == 28
-	#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
+
+#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
 	#define SGX_GENERAL_MAPPING_HEAP_BASE		 0x00001000
 	#define SGX_GENERAL_MAPPING_HEAP_SIZE		(0x01800000-0x00001000-0x00001000)
-	#endif
-		
+
 	#define SGX_GENERAL_HEAP_BASE				 0x01800000
 	#define SGX_GENERAL_HEAP_SIZE				(0x07000000-0x00001000)
 
+#else
+	#define SGX_GENERAL_HEAP_BASE				 0x00001000
+	#define SGX_GENERAL_HEAP_SIZE				(0x08800000-0x00001000-0x00001000)
+#endif
+	
 	#define SGX_3DPARAMETERS_HEAP_BASE			 0x08800000
 	#define SGX_3DPARAMETERS_HEAP_SIZE			(0x04000000-0x00001000)
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinit.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinit.c
index deb8a84..052618d 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinit.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinit.c
@@ -294,7 +294,7 @@ static PVRSRV_ERROR SGXRunScript(PVRSRV_SGXDEV_INFO *psDevInfo, SGX_INIT_COMMAND
 //Function to configure PLL clocks. Only required for TI814x. For other devices its taken care in u-boot.
 void PLL_Clocks_Config(UWORD32 Base_Address,UWORD32 OSC_FREQ,UWORD32 N,UWORD32 M,UWORD32 M2,UWORD32 CLKCTRL_VAL)
 {
-        UWORD32 m2nval,mn2val,read_clkctrl,clk_out,ref_clk,clkout_dco = 0;
+        UWORD32 m2nval,mn2val,read_clkctrl;
         m2nval = (M2<<16) | N;
         mn2val =  M;
 	WR_MEM_32((Base_Address+M2NDIV    ),m2nval);
@@ -391,6 +391,7 @@ PVRSRV_ERROR SGXInitialise(PVRSRV_SGXDEV_INFO	*psDevInfo,
 	}
 	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "End of SGX initialisation script part 2\n");
 
+              //  OSWriteHWReg(psDevInfo->pvRegsBaseKM, 0xFF08, 0x80000000);//OCP Bypass mode
 #ifdef PLAT_TI81xx
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, 0xFF08, 0x80000000);//OCP Bypass mode
         if(cpu_is_ti816x()) {
@@ -402,14 +403,16 @@ PVRSRV_ERROR SGXInitialise(PVRSRV_SGXDEV_INFO	*psDevInfo,
             div_base = ioremap(SGX_TI81xx_CLK_DVDR_ADDR,0x100);
             WR_MEM_32((div_base),0x0);
             pll_base = ioremap(SGX_PLL_BASE,0x100);
-	    PLL_Clocks_Config(pll_base,OSC_0,19,800,4,ADPLLJ_CLKCRTL_HS2);
+	    PLL_Clocks_Config((UWORD32)pll_base,OSC_0,19,800,4,ADPLLJ_CLKCRTL_HS2);
             iounmap (div_base);
             iounmap (pll_base);
         }
 
 #else
-        if(cpu_is_omap3630())
-                OSWriteHWReg(psDevInfo->pvRegsBaseKM, 0xFF08, 0x80000000);//OCP Bypass mode
+        if(!(cpu_is_omap3530() || cpu_is_omap3517()))
+	{
+               OSWriteHWReg(psDevInfo->pvRegsBaseKM, 0xFF08, 0x80000000);//OCP Bypass mode
+	}
 #endif
 
 
@@ -466,13 +469,20 @@ PVRSRV_ERROR SGXInitialise(PVRSRV_SGXDEV_INFO	*psDevInfo,
 #endif 
 
 #if !defined(NO_HARDWARE)
+
+       if (PollForValueKM(&psSGXHostCtl->ui32InitStatus,
+                                           PVRSRV_USSE_EDM_INIT_COMPLETE,
+                                           PVRSRV_USSE_EDM_INIT_COMPLETE,
+                                           MAX_HW_TIME_US,
+                                           MAX_HW_TIME_US/WAIT_TRY_COUNT,
+                                           IMG_FALSE) != PVRSRV_OK)
 	
 
-	if (PollForValueKM(&psSGXHostCtl->ui32InitStatus,
-					   PVRSRV_USSE_EDM_INIT_COMPLETE,
-					   PVRSRV_USSE_EDM_INIT_COMPLETE,
-					   MAX_HW_TIME_US/WAIT_TRY_COUNT,
-					   WAIT_TRY_COUNT) != PVRSRV_OK)
+//	if (PollForValueKM(&psSGXHostCtl->ui32InitStatus,
+//					   PVRSRV_USSE_EDM_INIT_COMPLETE,
+//					   PVRSRV_USSE_EDM_INIT_COMPLETE,
+//					   MAX_HW_TIME_US/WAIT_TRY_COUNT,
+//					   WAIT_TRY_COUNT) != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "SGXInitialise: Wait for uKernel initialisation failed"));
 		#if !defined(FIX_HW_BRN_23281)
@@ -2067,11 +2077,19 @@ PVRSRV_ERROR SGXGetMiscInfoUkernel(PVRSRV_SGXDEV_INFO	*psDevInfo,
 	sCommandData.ui32Data[1] = psMemInfo->sDevVAddr.uiAddr; 
 
 	PDUMPCOMMENT("Microkernel kick for SGXGetMiscInfo");
-	eError = SGXScheduleCCBCommandKM(psDeviceNode,
+/*	eError = SGXScheduleCCBCommandKM(psDeviceNode,
 									 SGXMKIF_CMD_GETMISCINFO,
 									 &sCommandData,
 									 KERNEL_ID,
 									 0);
+*/
+
+      eError = SGXScheduleCCBCommandKM(psDeviceNode,
+                                                                         SGXMKIF_CMD_GETMISCINFO,
+                                                                         &sCommandData,
+                                                                         KERNEL_ID,
+                                                                         0,
+                                                                         IMG_FALSE);
 
 	if (eError != PVRSRV_OK)
 	{
@@ -2177,11 +2195,19 @@ PVRSRV_ERROR SGXGetMiscInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
 			psDevInfo->psSGXHostCtl->ui32BPSetClearSignal = 0;
 
 			PDUMPCOMMENT("Microkernel kick for setting a data breakpoint");
-			eError = SGXScheduleCCBCommandKM(psDeviceNode,
+/*			eError = SGXScheduleCCBCommandKM(psDeviceNode,
 											 SGXMKIF_CMD_DATABREAKPOINT,
 											 &sCommandData,
 											 KERNEL_ID,
 											 0);
+*/
+                        eError = SGXScheduleCCBCommandKM(psDeviceNode,
+                                                                                         SGXMKIF_CMD_DATABREAKPOINT,
+                                                                                         &sCommandData,
+                                                                                         KERNEL_ID,
+                                                                                         0,
+                                                                                         IMG_FALSE);
+
 
 			if (eError != PVRSRV_OK)
 			{
@@ -2558,11 +2584,19 @@ PVRSRV_ERROR SGXGetMiscInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
 
 			
 			sCommandData.ui32Data[0] = psSetHWPerfStatus->ui32NewHWPerfStatus;
-			eError = SGXScheduleCCBCommandKM(psDeviceNode,
+/*			eError = SGXScheduleCCBCommandKM(psDeviceNode,
 											 SGXMKIF_CMD_SETHWPERFSTATUS,
 											 &sCommandData,
 											 KERNEL_ID,
 											 0);
+*/
+                        eError = SGXScheduleCCBCommandKM(psDeviceNode,
+                                                                                         SGXMKIF_CMD_SETHWPERFSTATUS,
+                                                                                         &sCommandData,
+                                                                                         KERNEL_ID,
+                                                                                         0,
+                                                                                         IMG_FALSE);
+
 			return eError;
 		}
 #endif 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxkick.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxkick.c
index 8a229c9..581640b 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxkick.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxkick.c
@@ -550,7 +550,7 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 	}
 #endif	
 
-	eError = SGXScheduleCCBCommandKM(hDevHandle, SGXMKIF_CMD_TA, &psCCBKick->sCommand, KERNEL_ID, 0);
+	eError = SGXScheduleCCBCommandKM(hDevHandle, SGXMKIF_CMD_TA, &psCCBKick->sCommand, KERNEL_ID, 0, psCCBKick->bLastInScene);
 	if (eError == PVRSRV_ERROR_RETRY)
 	{
 		if (psCCBKick->bFirstKickOrResume && psCCBKick->ui32NumDstSyncObjects > 0)
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxpower.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxpower.c
index aeac6e3..427cb50 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxpower.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxpower.c
@@ -197,8 +197,9 @@ static IMG_VOID SGXPollForClockGating (PVRSRV_SGXDEV_INFO	*psDevInfo,
 	if (PollForValueKM((IMG_UINT32 *)psDevInfo->pvRegsBaseKM + (ui32Register >> 2),
 						0,
 						ui32RegisterValue,
+						MAX_HW_TIME_US,
 						MAX_HW_TIME_US/WAIT_TRY_COUNT,
-						WAIT_TRY_COUNT) != PVRSRV_OK)
+						IMG_FALSE) != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"SGXPollForClockGating: %s failed.", pszComment));
 		PVR_DBG_BREAK;
@@ -251,7 +252,7 @@ PVRSRV_ERROR SGXPrePowerState (IMG_HANDLE				hDevHandle,
 
 		sCommand.ui32Data[1] = ui32PowerCmd;
 
-		eError = SGXScheduleCCBCommand(psDevInfo, SGXMKIF_CMD_POWER, &sCommand, KERNEL_ID, 0);
+		eError = SGXScheduleCCBCommand(psDevInfo, SGXMKIF_CMD_POWER, &sCommand, KERNEL_ID, 0, IMG_FALSE);
 		if (eError != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,"SGXPrePowerState: Failed to submit power down command"));
@@ -263,8 +264,9 @@ PVRSRV_ERROR SGXPrePowerState (IMG_HANDLE				hDevHandle,
 		if (PollForValueKM(&psDevInfo->psSGXHostCtl->ui32PowerStatus,
 							ui32CompleteStatus,
 							ui32CompleteStatus,
+							MAX_HW_TIME_US,
 							MAX_HW_TIME_US/WAIT_TRY_COUNT,
-							WAIT_TRY_COUNT) != PVRSRV_OK)
+							IMG_FALSE) != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,"SGXPrePowerState: Wait for SGX ukernel power transition failed."));
 			PVR_DBG_BREAK;
@@ -371,7 +373,7 @@ PVRSRV_ERROR SGXPostPowerState (IMG_HANDLE				hDevHandle,
 			SGXMKIF_COMMAND		sCommand = {0};
 
 			sCommand.ui32Data[1] = PVRSRV_POWERCMD_RESUME;
-			eError = SGXScheduleCCBCommand(psDevInfo, SGXMKIF_CMD_POWER, &sCommand, ISR_ID, 0);
+			eError = SGXScheduleCCBCommand(psDevInfo, SGXMKIF_CMD_POWER, &sCommand, ISR_ID, 0, IMG_FALSE);
 			if (eError != PVRSRV_OK)
 			{
 				PVR_DPF((PVR_DBG_ERROR,"SGXPostPowerState failed to schedule CCB command: %u", eError));
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxreset.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxreset.c
index 68d0e79..847ca24 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxreset.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxreset.c
@@ -199,8 +199,9 @@ static IMG_VOID SGXResetInvalDC(PVRSRV_SGXDEV_INFO	*psDevInfo,
 		if (PollForValueKM((IMG_UINT32 *)((IMG_UINT8*)psDevInfo->pvRegsBaseKM + EUR_CR_BIF_MEM_REQ_STAT),
 							0,
 							EUR_CR_BIF_MEM_REQ_STAT_READS_MASK,
+							MAX_HW_TIME_US,
 							MAX_HW_TIME_US/WAIT_TRY_COUNT,
-							WAIT_TRY_COUNT) != PVRSRV_OK)
+							IMG_FALSE) != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,"Wait for DC invalidate failed."));
 			PVR_DBG_BREAK;
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxtransfer.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxtransfer.c
index 0e9fe81..1624eb2 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxtransfer.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxtransfer.c
@@ -229,7 +229,7 @@ IMG_EXPORT PVRSRV_ERROR SGXSubmitTransferKM(IMG_HANDLE hDevHandle, PVRSRV_TRANSF
 
 	sCommand.ui32Data[1] = psKick->sHWTransferContextDevVAddr.uiAddr;
 	
-	eError = SGXScheduleCCBCommandKM(hDevHandle, SGXMKIF_CMD_TRANSFER, &sCommand, KERNEL_ID, psKick->ui32PDumpFlags);
+	eError = SGXScheduleCCBCommandKM(hDevHandle, SGXMKIF_CMD_TRANSFER, &sCommand, KERNEL_ID, psKick->ui32PDumpFlags, IMG_FALSE);
 
 	if (eError == PVRSRV_ERROR_RETRY)
 	{
@@ -491,7 +491,7 @@ IMG_EXPORT PVRSRV_ERROR SGXSubmit2DKM(IMG_HANDLE hDevHandle, PVRSRV_2D_SGX_KICK
 
 	sCommand.ui32Data[1] = psKick->sHW2DContextDevVAddr.uiAddr;
 	
-	eError = SGXScheduleCCBCommandKM(hDevHandle, SGXMKIF_CMD_2D, &sCommand, KERNEL_ID, psKick->ui32PDumpFlags);	
+	eError = SGXScheduleCCBCommandKM(hDevHandle, SGXMKIF_CMD_2D, &sCommand, KERNEL_ID, psKick->ui32PDumpFlags, IMG_FALSE);	
 
 	if (eError == PVRSRV_ERROR_RETRY)
 	{
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.c
index d8b6de7..6952571 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.c
@@ -142,7 +142,7 @@ static INLINE SGXMKIF_COMMAND * SGXAcquireKernelCCBSlot(PVRSRV_SGX_CCB_INFO *psC
 			return &psCCB->psCommands[*psCCB->pui32WriteOffset];
 		}
 
-		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
+		OSSleepms(1);
 	} END_LOOP_UNTIL_TIMEOUT();
 
 	
@@ -153,12 +153,12 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 								   SGXMKIF_CMD_TYPE		eCmdType,
 								   SGXMKIF_COMMAND		*psCommandData,
 								   IMG_UINT32			ui32CallerID,
-								   IMG_UINT32			ui32PDumpFlags)
+								   IMG_UINT32			ui32PDumpFlags,
+								   IMG_BOOL			bLastInScene)
 {
 	PVRSRV_SGX_CCB_INFO *psKernelCCB;
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	SGXMKIF_COMMAND *psSGXCommand;
-	SYS_DATA *psSysData;
 #if defined(PDUMP)
 	IMG_VOID *pvDumpCommand;
 	IMG_BOOL bPDumpIsSuspended = PDumpIsSuspended();
@@ -187,7 +187,8 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 									   SGXMKIF_CMD_PROCESS_QUEUES,
 									   &sCacheCommand,
 									   ui32CallerID,
-									   ui32PDumpFlags);
+									   ui32PDumpFlags,
+									   bLastInScene);
 		if (eError != PVRSRV_OK)
 		{
 			goto Exit;
@@ -198,8 +199,9 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 		if(PollForValueKM(&psSGXHostCtl->ui32InvalStatus,
 						  PVRSRV_USSE_EDM_BIF_INVAL_COMPLETE,
 						  PVRSRV_USSE_EDM_BIF_INVAL_COMPLETE,
-						  2 * MAX_HW_TIME_US/WAIT_TRY_COUNT,
-						  WAIT_TRY_COUNT) != PVRSRV_OK)
+						  2 * MAX_HW_TIME_US,
+						  MAX_HW_TIME_US/WAIT_TRY_COUNT,
+						  IMG_FALSE) != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,"SGXScheduleCCBCommand: Wait for uKernel to Invalidate BIF cache failed"));
 			PVR_DBG_BREAK;
@@ -265,20 +267,25 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 		goto Exit;
 	}
 
-	
-	SysAcquireData(&psSysData);
-
-	if(psSysData->ePendingCacheOpType == PVRSRV_MISC_INFO_CPUCACHEOP_FLUSH)
-	{
-		OSFlushCPUCacheKM();
-	}
-	else if(psSysData->ePendingCacheOpType == PVRSRV_MISC_INFO_CPUCACHEOP_CLEAN)
+	if((eCmdType == SGXMKIF_CMD_TA) && bLastInScene)
 	{
-		OSCleanCPUCacheKM();
-	}
+		SYS_DATA *psSysData;
 
-	
-	psSysData->ePendingCacheOpType = PVRSRV_MISC_INFO_CPUCACHEOP_NONE;
+		
+		SysAcquireData(&psSysData);
+
+		if(psSysData->ePendingCacheOpType == PVRSRV_MISC_INFO_CPUCACHEOP_FLUSH)	
+		{
+			OSFlushCPUCacheKM();
+		}
+		else if(psSysData->ePendingCacheOpType == PVRSRV_MISC_INFO_CPUCACHEOP_CLEAN)
+		{
+			OSCleanCPUCacheKM();
+		}
+
+		
+		psSysData->ePendingCacheOpType = PVRSRV_MISC_INFO_CPUCACHEOP_NONE;
+	}
 
 	PVR_ASSERT(eCmdType < SGXMKIF_CMD_MAX);
 	psSGXCommand->ui32ServiceAddress = psDevInfo->aui32HostKickAddr[eCmdType];	 
@@ -330,8 +337,9 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 	eError = PollForValueKM (psKernelCCB->pui32ReadOffset,
 								*psKernelCCB->pui32WriteOffset,
 								0xFF,
+								MAX_HW_TIME_US,
 								MAX_HW_TIME_US/WAIT_TRY_COUNT,
-								WAIT_TRY_COUNT);
+								IMG_FALSE);
 	if (eError != PVRSRV_OK)
 	{
 		eError = PVRSRV_ERROR_TIMEOUT;
@@ -418,7 +426,8 @@ PVRSRV_ERROR SGXScheduleCCBCommandKM(PVRSRV_DEVICE_NODE		*psDeviceNode,
 									 SGXMKIF_CMD_TYPE		eCmdType,
 									 SGXMKIF_COMMAND		*psCommandData,
 									 IMG_UINT32				ui32CallerID,
-									 IMG_UINT32				ui32PDumpFlags)
+									 IMG_UINT32				ui32PDumpFlags,
+									 IMG_BOOL				bLastInScene)
 {
 	PVRSRV_ERROR		eError;
 	PVRSRV_SGXDEV_INFO 	*psDevInfo = psDeviceNode->pvDevice;
@@ -465,7 +474,7 @@ PVRSRV_ERROR SGXScheduleCCBCommandKM(PVRSRV_DEVICE_NODE		*psDeviceNode,
 		return eError;
 	}
 
-	eError = SGXScheduleCCBCommand(psDevInfo, eCmdType, psCommandData, ui32CallerID, ui32PDumpFlags);
+	eError = SGXScheduleCCBCommand(psDevInfo, eCmdType, psCommandData, ui32CallerID, ui32PDumpFlags, bLastInScene);
 
 	PVRSRVPowerUnlock(ui32CallerID);
 
@@ -497,7 +506,7 @@ PVRSRV_ERROR SGXScheduleProcessQueuesKM(PVRSRV_DEVICE_NODE *psDeviceNode)
 		return PVRSRV_OK;
 	}
 
-	eError = SGXScheduleCCBCommandKM(psDeviceNode, SGXMKIF_CMD_PROCESS_QUEUES, &sCommand, ISR_ID, 0);
+	eError = SGXScheduleCCBCommandKM(psDeviceNode, SGXMKIF_CMD_PROCESS_QUEUES, &sCommand, ISR_ID, 0, IMG_FALSE);
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"SGXScheduleProcessQueuesKM failed to schedule CCB command: %u", eError));
@@ -551,7 +560,7 @@ IMG_VOID SGXCleanupRequest(PVRSRV_DEVICE_NODE	*psDeviceNode,
 		sCommand.ui32Data[0] = ui32CleanupType;
 		sCommand.ui32Data[1] = (psHWDataDevVAddr == IMG_NULL) ? 0 : psHWDataDevVAddr->uiAddr;
 
-		eError = SGXScheduleCCBCommandKM(psDeviceNode, SGXMKIF_CMD_CLEANUP, &sCommand, KERNEL_ID, 0);
+		eError = SGXScheduleCCBCommandKM(psDeviceNode, SGXMKIF_CMD_CLEANUP, &sCommand, KERNEL_ID, 0, IMG_FALSE);
 		if (eError != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,"SGXCleanupRequest: Failed to submit clean-up command"));
@@ -563,8 +572,9 @@ IMG_VOID SGXCleanupRequest(PVRSRV_DEVICE_NODE	*psDeviceNode,
 		if(PollForValueKM(&psSGXHostCtl->ui32CleanupStatus,
 						  PVRSRV_USSE_EDM_CLEANUPCMD_COMPLETE,
 						  PVRSRV_USSE_EDM_CLEANUPCMD_COMPLETE,
-						  2 * MAX_HW_TIME_US/WAIT_TRY_COUNT,
-						  WAIT_TRY_COUNT) != PVRSRV_OK)
+						  10 * MAX_HW_TIME_US,
+						  1000,
+						  IMG_TRUE) != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,"SGXCleanupRequest: Wait for uKernel to clean up (%u) failed", ui32CleanupType));
 			PVR_DBG_BREAK;
@@ -943,7 +953,7 @@ PVRSRV_ERROR SGX2DQueryBlitsCompleteKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
 
 	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
 	{
-		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
+		OSSleepms(1);
 
 		if(SGX2DQuerySyncOpsComplete(psSyncInfo, ui32ReadOpsPending, ui32WriteOpsPending))
 		{
@@ -952,7 +962,7 @@ PVRSRV_ERROR SGX2DQueryBlitsCompleteKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
 			return PVRSRV_OK;
 		}
 
-		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
+		OSSleepms(1);
 	} END_LOOP_UNTIL_TIMEOUT();
 
 	
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.h b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.h
index aeee635..abf9dc2 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.h
@@ -46,13 +46,15 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 								   SGXMKIF_CMD_TYPE		eCommandType,
 								   SGXMKIF_COMMAND		*psCommandData,
 								   IMG_UINT32			ui32CallerID,
-								   IMG_UINT32			ui32PDumpFlags);
+								   IMG_UINT32			ui32PDumpFlags,
+								   IMG_BOOL			bLastInScene);
 IMG_IMPORT
 PVRSRV_ERROR SGXScheduleCCBCommandKM(PVRSRV_DEVICE_NODE		*psDeviceNode,
 									 SGXMKIF_CMD_TYPE		eCommandType,
 									 SGXMKIF_COMMAND		*psCommandData,
 									 IMG_UINT32				ui32CallerID,
-									 IMG_UINT32				ui32PDumpFlags);
+									 IMG_UINT32				ui32PDumpFlags,
+									 IMG_BOOL				bLastInScene);
 
 IMG_IMPORT
 PVRSRV_ERROR SGXScheduleProcessQueuesKM(PVRSRV_DEVICE_NODE *psDeviceNode);
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/event.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/event.c
index 2a930a6..f8e8acb 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/event.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/event.c
@@ -24,11 +24,13 @@
  *
  ******************************************************************************/
 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
  #include <linux/config.h>
 #endif
+#endif
 
-#include <linux/version.h>
 #include <asm/io.h>
 #include <asm/page.h>
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.c
index ecaba8e..8211d4a 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.c
@@ -24,11 +24,13 @@
  *
  ******************************************************************************/
 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
  #include <linux/config.h>
 #endif
+#endif
 
-#include <linux/version.h>
 #include <linux/mm.h>
 #include <linux/vmalloc.h>
 #include <asm/io.h>
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.h b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.h
index 047b3ad..21f295f 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.h
@@ -27,11 +27,15 @@
 #ifndef __IMG_LINUX_MM_H__
 #define __IMG_LINUX_MM_H__
 
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
  #include <linux/config.h>
 #endif
+#endif
 
-#include <linux/version.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/list.h>
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.c
index 66cef26..2359c71 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.c
@@ -24,11 +24,14 @@
  *
  ******************************************************************************/
 
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
  #include <linux/config.h>
 #endif
+#endif
 
-#include <linux/version.h>
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/vmalloc.h>
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/module.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/module.c
index df1b49f..305db3a 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/module.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/module.c
@@ -24,9 +24,14 @@
  *
  ******************************************************************************/
 
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
  #include <linux/config.h>
 #endif
+#endif
+
 
 #if !defined(SUPPORT_DRI_DRM)
 	
@@ -44,7 +49,6 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/version.h>
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.c
index 83eab51..0a7cad1 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.c
@@ -24,10 +24,12 @@
  *
  ******************************************************************************/
 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
-#include <linux/version.h>
+#endif
 
 #include <linux/spinlock.h>
 #include <linux/mm.h>
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.h b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.h
index 943c2bd..cdde900 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.h
@@ -27,11 +27,13 @@
 #ifndef __IMG_LINUX_MUTILS_H__
 #define __IMG_LINUX_MUTILS_H__
 
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
 #include <linux/config.h>
 #endif
-
-#include <linux/version.h>
+#endif
 
 #if !(defined(__i386__) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)))
 #if defined(SUPPORT_LINUX_X86_PAT)
@@ -46,7 +48,7 @@
 	#if defined(__arm__) || defined(__sh__)
 		#define	PGPROT_WC(pv)	pgprot_writecombine(pv)
 	#else
-		#if defined(__i386__)
+		#if defined(__i386__) || defined(__mips__)
 			#define	PGPROT_WC(pv)	pgprot_noncached(pv)
 		#else
 			#define PGPROT_WC(pv)	pgprot_noncached(pv)
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/osfunc.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/osfunc.c
index 81970c6..ad39b05 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/osfunc.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/osfunc.c
@@ -24,11 +24,14 @@
  *
  ******************************************************************************/
 
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
  #include <linux/config.h>
 #endif
+#endif
 
-#include <linux/version.h>
 #include <asm/io.h>
 #include <asm/page.h>
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
@@ -76,11 +79,11 @@
 #else
 #define ON_EACH_CPU(func, info, wait) on_each_cpu(func, info, 0, wait)
 #endif
-/*
+
 #if defined(PVR_LINUX_USING_WORKQUEUES) && !defined(CONFIG_PREEMPT)
-#error "A preemptible Linux kernel is required when using workqueues"
+//#error "A preemptible Linux kernel is required when using workqueues"
 #endif
-*/
+
 #define EVENT_OBJECT_TIMEOUT_MS		(100)
 
 #define HOST_ALLOC_MEM_USING_KMALLOC ((IMG_HANDLE)0)
@@ -132,7 +135,16 @@ PVRSRV_ERROR OSAllocMem_Impl(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOI
     return PVRSRV_OK;
 }
 
-	
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,24))
+
+static inline int is_vmalloc_addr(const void *pvCpuVAddr)
+{
+	unsigned long lAddr = (unsigned long)pvCpuVAddr;
+	return lAddr >= VMALLOC_START && lAddr < VMALLOC_END;
+}
+
+#endif 
+
 #if !defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 PVRSRV_ERROR OSFreeMem_Impl(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID pvCpuVAddr, IMG_HANDLE hBlockAlloc)
 #else
@@ -512,13 +524,18 @@ IMG_UINT32 OSClockus(IMG_VOID)
 }
 
 
- 
 IMG_VOID OSWaitus(IMG_UINT32 ui32Timeus)
 {
     udelay(ui32Timeus);
 }
 
 
+IMG_VOID OSSleepms(IMG_UINT32 ui32Timems)
+{
+    msleep(ui32Timems);
+}
+
+
 IMG_UINT32 OSGetCurrentProcessIDKM(IMG_VOID)
 {
     if (in_interrupt())
@@ -2583,10 +2600,6 @@ error:
 }
 
 typedef void (*InnerCacheOp_t)(const void *pvStart, const void *pvEnd);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
-typedef void (*InnerCacheOp_mapUnmap_t)(const void *pvStart, const IMG_UINT32 size, const IMG_UINT32 type);
-#endif
-
 typedef void (*OuterCacheOp_t)(unsigned long ulStart, unsigned long ulEnd);
 
 #if defined(CONFIG_OUTER_CACHE)
@@ -2652,34 +2665,19 @@ IMG_VOID *FindMMapBaseVAddr(struct list_head *psMMapOffsetStructList,
 
 	return IMG_NULL;
 }
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+
 static
 IMG_BOOL CheckExecuteCacheOp(IMG_HANDLE hOSMemHandle,
 							 IMG_VOID *pvRangeAddrStart,
 							 IMG_UINT32 ui32Length,
-							 void * pfnInnerCacheOp_ptr,
-							 OuterCacheOp_t pfnOuterCacheOp,
-                                                         IMG_UINT32 map_unmap)
-#else
-static
-IMG_BOOL CheckExecuteCacheOp(IMG_HANDLE hOSMemHandle,
-                                                         IMG_VOID *pvRangeAddrStart,
-                                                         IMG_UINT32 ui32Length,
-                                                         InnerCacheOp_t pfnInnerCacheOp,
-                                                         OuterCacheOp_t pfnOuterCacheOp)
-#endif
-
+							 InnerCacheOp_t pfnInnerCacheOp,
+							 OuterCacheOp_t pfnOuterCacheOp)
 {
 	LinuxMemArea *psLinuxMemArea = (LinuxMemArea *)hOSMemHandle;
 	IMG_UINT32 ui32AreaLength, ui32AreaOffset = 0;
 	struct list_head *psMMapOffsetStructList;
 	IMG_VOID *pvMinVAddr;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))        
-        InnerCacheOp_t pfnInnerCacheOp = (InnerCacheOp_t)pfnInnerCacheOp_ptr;
-        InnerCacheOp_mapUnmap_t pfnInnerCacheOp_mapUnamp = (InnerCacheOp_mapUnmap_t)pfnInnerCacheOp_ptr;
-#endif
-
 #if defined(CONFIG_OUTER_CACHE)
 	MemAreaToPhys_t pfnMemAreaToPhys = IMG_NULL;
 	IMG_UINT32 ui32PageNumOffset = 0;
@@ -2705,16 +2703,38 @@ IMG_BOOL CheckExecuteCacheOp(IMG_HANDLE hOSMemHandle,
 	{
 		case LINUX_MEM_AREA_VMALLOC:
 		{
-			pvMinVAddr = psLinuxMemArea->uData.sVmalloc.pvVmallocAddress + ui32AreaOffset;
+			if(is_vmalloc_addr(pvRangeAddrStart))
+			{
+				pvMinVAddr = psLinuxMemArea->uData.sVmalloc.pvVmallocAddress + ui32AreaOffset;
 
-			
-			if(pvRangeAddrStart < pvMinVAddr &&
-			   ui32AreaOffset + ui32Length > ui32AreaLength)
-				goto err_blocked;
+				
+				if(pvRangeAddrStart < pvMinVAddr)
+					goto err_blocked;
+
+				pfnInnerCacheOp(pvRangeAddrStart, pvRangeAddrStart + ui32Length);
+			}
+			else
+			{
+				
+				
+
+				pvMinVAddr = FindMMapBaseVAddr(psMMapOffsetStructList,
+											   pvRangeAddrStart, ui32Length);
+				if(!pvMinVAddr)
+					goto err_blocked;
+
+				pfnInnerCacheOp(pvRangeAddrStart, pvRangeAddrStart + ui32Length);
 
 #if defined(CONFIG_OUTER_CACHE)
+				
+				pvRangeAddrStart = psLinuxMemArea->uData.sVmalloc.pvVmallocAddress +
+								   (ui32AreaOffset & PAGE_MASK) + (pvRangeAddrStart - pvMinVAddr);
+			}
+
 			pfnMemAreaToPhys = VMallocAreaToPhys;
-#endif
+#else 
+			}
+#endif 
 			break;
 		}
 
@@ -2743,6 +2763,8 @@ IMG_BOOL CheckExecuteCacheOp(IMG_HANDLE hOSMemHandle,
 			if(!pvMinVAddr)
 				goto err_blocked;
 
+			pfnInnerCacheOp(pvRangeAddrStart, pvRangeAddrStart + ui32Length);
+
 #if defined(CONFIG_OUTER_CACHE)
 			ui32PageNumOffset = ((ui32AreaOffset & PAGE_MASK) + (pvRangeAddrStart - pvMinVAddr)) >> PAGE_SHIFT;
 			pfnMemAreaToPhys = ExternalKVAreaToPhys;
@@ -2757,6 +2779,8 @@ IMG_BOOL CheckExecuteCacheOp(IMG_HANDLE hOSMemHandle,
 			if(!pvMinVAddr)
 				goto err_blocked;
 
+			pfnInnerCacheOp(pvRangeAddrStart, pvRangeAddrStart + ui32Length);
+
 #if defined(CONFIG_OUTER_CACHE)
 			ui32PageNumOffset = ((ui32AreaOffset & PAGE_MASK) + (pvRangeAddrStart - pvMinVAddr)) >> PAGE_SHIFT;
 			pfnMemAreaToPhys = AllocPagesAreaToPhys;
@@ -2768,27 +2792,10 @@ IMG_BOOL CheckExecuteCacheOp(IMG_HANDLE hOSMemHandle,
 			PVR_DBG_BREAK;
 	}
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
-        if (map_unmap == 0 ) {
-
-           pfnInnerCacheOp(pvRangeAddrStart, pvRangeAddrStart + ui32Length);
-
-        } else if (map_unmap == 1) {
-	
-	   pfnInnerCacheOp_mapUnamp (pvRangeAddrStart, ui32Length, DMA_TO_DEVICE);
-
-        } else {
-
-           pfnInnerCacheOp_mapUnamp (pvRangeAddrStart, ui32Length, DMA_FROM_DEVICE);
-
-        }
-#else
-pfnInnerCacheOp(pvRangeAddrStart, pvRangeAddrStart + ui32Length);
-#endif
-
 #if defined(CONFIG_OUTER_CACHE)
+	PVR_ASSERT(pfnMemAreaToPhys != IMG_NULL);
+
 	
-	if (pfnMemAreaToPhys != IMG_NULL)
 	{
 		unsigned long ulStart, ulEnd, ulLength, ulStartOffset, ulEndOffset;
 		IMG_UINT32 i, ui32NumPages;
@@ -2816,10 +2823,6 @@ pfnInnerCacheOp(pvRangeAddrStart, pvRangeAddrStart + ui32Length);
 			pfnOuterCacheOp(ulStart, ulEnd);
 		}
 	}
-	else
-	{
-		PVR_DBG_BREAK;
-	}
 #endif
 
 	return IMG_TRUE;
@@ -2831,7 +2834,8 @@ err_blocked:
 			 psLinuxMemArea->eAreaType));
 	return IMG_FALSE;
 }
-#endif 
+
+#endif
 
 #if defined(__i386__)
 
@@ -2873,40 +2877,27 @@ IMG_BOOL OSFlushCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
 								IMG_VOID *pvRangeAddrStart,
 								IMG_UINT32 ui32Length)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))	
+	
 	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
-							   (void *) x86_flush_cache_range, IMG_NULL, 0);
-#else
-       return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
-                                                           x86_flush_cache_range, IMG_NULL);
-
-#endif
+							   x86_flush_cache_range, IMG_NULL);
 }
 
 IMG_BOOL OSCleanCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
 								IMG_VOID *pvRangeAddrStart,
 								IMG_UINT32 ui32Length)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))	
+	
 	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
-							   (void *) x86_flush_cache_range, IMG_NULL, 0);
-#else
-       return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
-                                                           x86_flush_cache_range, IMG_NULL);
-#endif
+							   x86_flush_cache_range, IMG_NULL);
 }
 
 IMG_BOOL OSInvalidateCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
 									 IMG_VOID *pvRangeAddrStart,
 									 IMG_UINT32 ui32Length)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))	
+	
 	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
-							   (void *) x86_flush_cache_range, IMG_NULL, 0);
-#else
-        return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
-                                                           x86_flush_cache_range, IMG_NULL);
-#endif
+							   x86_flush_cache_range, IMG_NULL);
 }
 
 #else 
@@ -2935,52 +2926,55 @@ IMG_VOID OSFlushCPUCacheKM(IMG_VOID)
 	outer_flush_all();
 #endif
 }
+static inline size_t pvr_dmac_range_len(const void *pvStart, const void *pvEnd)
+{
+        return (size_t)((char *)pvEnd - (char *)pvStart);
+}
 
-IMG_BOOL OSFlushCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
-								IMG_VOID *pvRangeAddrStart,
-								IMG_UINT32 ui32Length)
+
+static void pvr_dmac_inv_range(const void *pvStart, const void *pvEnd)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
-	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
-							   (void *) dmac_flush_range, outer_flush_range, 0);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34))
+        dmac_inv_range(pvStart, pvEnd);
 #else
-        return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
-                                                           dmac_flush_range, outer_flush_range);
+        dmac_map_area(pvStart, pvr_dmac_range_len(pvStart, pvEnd), DMA_FROM_DEVICE);
 #endif
+}
 
+static void pvr_dmac_clean_range(const void *pvStart, const void *pvEnd)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34))
+        dmac_clean_range(pvStart, pvEnd);
+#else
+        dmac_map_area(pvStart, pvr_dmac_range_len(pvStart, pvEnd), DMA_TO_DEVICE);
+#endif
 }
 
-IMG_BOOL OSCleanCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+
+IMG_BOOL OSFlushCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
 								IMG_VOID *pvRangeAddrStart,
 								IMG_UINT32 ui32Length)
-{ 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
-	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
-                                                           (void *) dmac_map_area, outer_clean_range, 2);
-#else
-        return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
-                                                           dmac_clean_range, outer_clean_range);
-#endif
+{
+	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,dmac_flush_range, (OuterCacheOp_t)outer_flush_range);
+}
 
+IMG_BOOL OSCleanCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+								IMG_VOID *pvRangeAddrStart,
+								IMG_UINT32 ui32Length)
+{
+	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,pvr_dmac_clean_range, (OuterCacheOp_t)outer_clean_range);
 }
 
 IMG_BOOL OSInvalidateCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
 									 IMG_VOID *pvRangeAddrStart,
 									 IMG_UINT32 ui32Length)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
-	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
-							   (void *) dmac_unmap_area, outer_inv_range, 1);
-#else
-        return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
-                                                           dmac_inv_range, outer_inv_range);
-#endif
+	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,pvr_dmac_inv_range, (OuterCacheOp_t)outer_inv_range);
 }
 
 #else 
 
 #if defined(__mips__)
-
 IMG_VOID OSCleanCPUCacheKM(IMG_VOID)
 {
 	
@@ -3017,8 +3011,7 @@ IMG_BOOL OSInvalidateCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
 	return IMG_TRUE;
 }
 
-
-#else
+#else 
 
 #error "Implement CPU cache flush/clean/invalidate primitives for this CPU!"
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/proc.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/proc.c
index 965346d..27078ef 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/proc.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/proc.c
@@ -24,13 +24,16 @@
  *
  ******************************************************************************/
 
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
  #include <linux/config.h>
 #endif
+#endif
 
 #include <linux/init.h>
 #include <linux/module.h>
-#include <linux/version.h>
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_bridge_k.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_bridge_k.c
index 3abf604..3a59ce0 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_bridge_k.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_bridge_k.c
@@ -432,7 +432,6 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, unsigned int unref__ ioctlCmd, unsig
 			}
 			break;
 		}
-
 		case PVRSRV_BRIDGE_MAP_DEV_MEMORY:
 		{
 			PVRSRV_BRIDGE_IN_MAP_DEV_MEMORY *psMapDevMemIN =
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_debug.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_debug.c
index 091f659..476319c 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_debug.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_debug.c
@@ -24,9 +24,12 @@
  *
  ******************************************************************************/
 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
  #include <linux/config.h>
 #endif
+#endif
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
@@ -72,7 +75,8 @@ static IMG_CHAR gszBufferIRQ[PVR_MAX_MSG_LEN + 1];
 static PVRSRV_LINUX_MUTEX gsDebugMutexNonIRQ;
 
  
-static spinlock_t gsDebugLockIRQ = SPIN_LOCK_UNLOCKED;
+//static spinlock_t gsDebugLockIRQ = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(gsDebugLockIRQ);
 
 #if !defined (USE_SPIN_LOCK)  
 #define	USE_SPIN_LOCK (in_interrupt() || !preemptible())
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_drm.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_drm.c
index 94d65c2..c7eecb3b 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_drm.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_drm.c
@@ -26,16 +26,19 @@
 
 #if defined(SUPPORT_DRI_DRM)
 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
  #include <linux/config.h>
 #endif
+#endif
 
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/version.h>
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
+#include <linux/sched.h>
 #include <asm/ioctl.h>
 #include <drm/drmP.h>
 #include <drm/drm.h>
@@ -69,6 +72,11 @@
 #define PVR_DRM_NAME	PVRSRV_MODNAME
 #define PVR_DRM_DESC	"Imagination Technologies PVR DRM"
 
+DECLARE_WAIT_QUEUE_HEAD(sWaitForInit);
+
+IMG_BOOL bInitComplete;
+IMG_BOOL bInitFailed;
+
 #if !defined(PVR_DRI_DRM_NOT_PCI)
 struct pci_dev *gpsPVRLDMDev;
 #endif
@@ -98,7 +106,7 @@ static struct pci_device_id asPciIdList[] = {
 DRI_DRM_STATIC int
 PVRSRVDrmLoad(struct drm_device *dev, unsigned long flags)
 {
-	int iRes;
+	int iRes=0;
 
 	PVR_TRACE(("PVRSRVDrmLoad"));
 
@@ -111,7 +119,7 @@ PVRSRVDrmLoad(struct drm_device *dev, unsigned long flags)
 	iRes = dbgdrv_init();
 	if (iRes != 0)
 	{
-		return iRes;
+		goto exit;
 	}
 #endif
 	
@@ -128,8 +136,8 @@ PVRSRVDrmLoad(struct drm_device *dev, unsigned long flags)
 		goto exit_pvrcore_cleanup;
 	}
 #endif
-	return 0;
-
+//	return 0;
+        goto exit;
 #if defined(DISPLAY_CONTROLLER)
 exit_pvrcore_cleanup:
 	PVRCore_Cleanup();
@@ -138,6 +146,16 @@ exit_dbgdrv_cleanup:
 #if defined(PDUMP)
 	dbgdrv_cleanup();
 #endif
+exit:
+	if (iRes != 0)
+	{
+		bInitFailed = IMG_TRUE;
+	}
+	bInitComplete = IMG_TRUE;
+
+	wake_up_interruptible(&sWaitForInit);
+
+
 	return iRes;
 }
 
@@ -162,6 +180,34 @@ PVRSRVDrmUnload(struct drm_device *dev)
 DRI_DRM_STATIC int
 PVRSRVDrmOpen(struct drm_device *dev, struct drm_file *file)
 {
+while (!bInitComplete)
+	{
+		DEFINE_WAIT(sWait);
+
+		prepare_to_wait(&sWaitForInit, &sWait, TASK_INTERRUPTIBLE);
+
+		if (!bInitComplete)
+		{
+			PVR_TRACE(("%s: Waiting for module initialisation to complete", __FUNCTION__));
+
+			schedule();
+		}
+
+		finish_wait(&sWaitForInit, &sWait);
+
+		if (signal_pending(current))
+		{
+			return -ERESTARTSYS;
+		}
+	}
+
+	if (bInitFailed)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Module initialisation failed", __FUNCTION__));
+		return -EINVAL;
+	}
+
+
 	return PVRSRVOpen(dev, file);
 }
 
@@ -263,6 +309,12 @@ PVRDRM_Display_ioctl(struct drm_device *dev, void *arg, struct drm_file *pFile)
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
 #define	PVR_DRM_FOPS_IOCTL	.unlocked_ioctl
 #define	PVR_DRM_UNLOCKED	DRM_UNLOCKED
+#define DRM_IOCTL_PVR_DRM_SRVKM_IOCTL PVR_DRM_SRVKM_IOCTL
+#define DRM_PVR_DRM_SRVKM_IOCTL PVR_DRM_SRVKM_IOCTL
+#define DRM_PVR_DRM_IS_MASTER_IOCTL PVR_DRM_IS_MASTER_IOCTL
+#define DRM_IOCTL_PVR_DRM_IS_MASTER_IOCTL PVR_DRM_IS_MASTER_IOCTL
+#define DRM_PVR_DRM_UNPRIV_IOCTL PVR_DRM_UNPRIV_IOCTL
+#define DRM_IOCTL_PVR_DRM_UNPRIV_IOCTL PVR_DRM_UNPRIV_IOCTL
 #else
 #define	PVR_DRM_FOPS_IOCTL	.ioctl
 #define	PVR_DRM_UNLOCKED	0
@@ -270,15 +322,29 @@ PVRDRM_Display_ioctl(struct drm_device *dev, void *arg, struct drm_file *pFile)
 
 #if !defined(SUPPORT_DRI_DRM_EXT)
 struct drm_ioctl_desc sPVRDrmIoctls[] = {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
+	DRM_IOCTL_DEF_DRV(PVR_DRM_SRVKM_IOCTL, PVRSRV_BridgeDispatchKM, PVR_DRM_UNLOCKED),
+	DRM_IOCTL_DEF_DRV(PVR_DRM_IS_MASTER_IOCTL, PVRDRMIsMaster, DRM_MASTER | PVR_DRM_UNLOCKED),
+	DRM_IOCTL_DEF_DRV(PVR_DRM_UNPRIV_IOCTL, PVRDRMUnprivCmd, PVR_DRM_UNLOCKED),
+#else
 	DRM_IOCTL_DEF(PVR_DRM_SRVKM_IOCTL, PVRSRV_BridgeDispatchKM, PVR_DRM_UNLOCKED),
 	DRM_IOCTL_DEF(PVR_DRM_IS_MASTER_IOCTL, PVRDRMIsMaster, DRM_MASTER | PVR_DRM_UNLOCKED),
 	DRM_IOCTL_DEF(PVR_DRM_UNPRIV_IOCTL, PVRDRMUnprivCmd, PVR_DRM_UNLOCKED),
+#endif
 #if defined(PDUMP)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
+	DRM_IOCTL_DEF_DRV(PVR_DRM_DBGDRV_IOCTL, dbgdrv_ioctl, PVR_DRM_UNLOCKED),
+#else
 	DRM_IOCTL_DEF(PVR_DRM_DBGDRV_IOCTL, dbgdrv_ioctl, PVR_DRM_UNLOCKED),
 #endif
+#endif
 #if defined(DISPLAY_CONTROLLER) && defined(PVR_DISPLAY_CONTROLLER_DRM_IOCTL)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
+	DRM_IOCTL_DEF_DRV(PVR_DRM_DISP_IOCTL, PVRDRM_Display_ioctl, DRM_MASTER | PVR_DRM_UNLOCKED)
+#else
 	DRM_IOCTL_DEF(PVR_DRM_DISP_IOCTL, PVRDRM_Display_ioctl, DRM_MASTER | PVR_DRM_UNLOCKED)
 #endif
+#endif
 };
 
 static int pvr_max_ioctl = DRM_ARRAY_SIZE(sPVRDrmIoctls);
@@ -292,8 +358,10 @@ static struct drm_driver sPVRDrmDriver =
 	.open = PVRSRVDrmOpen,
 	.suspend = PVRSRVDriverSuspend,
 	.resume = PVRSRVDriverResume,
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,32))
 	.get_map_ofs = drm_core_get_map_ofs,
 	.get_reg_ofs = drm_core_get_reg_ofs,
+#endif
 	.ioctls = sPVRDrmIoctls,
 	.fops = 
 	{
@@ -305,11 +373,23 @@ static struct drm_driver sPVRDrmDriver =
 		.poll = drm_poll,
 		.fasync = drm_fasync,
 	},
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,38))
 	.pci_driver = 
 	{
 		.name = PVR_DRM_NAME,
 		.id_table = asPciIdList,
 	},
+#else
+	.kdriver = 
+	{
+	PVR_DRM_NAME,
+	asPciIdList,
+	},
+//	{
+//		.pci->name = PVR_DRM_NAME,
+//		.pci->id_table = asPciIdList,
+//	},
+#endif
 		
 	.name = PVR_DRM_NAME,
 	.desc = PVR_DRM_DESC,
@@ -319,6 +399,13 @@ static struct drm_driver sPVRDrmDriver =
 	.patchlevel = PVRVERSION_BUILD,
 };
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
+static struct pci_driver pci_pvr_driver = {
+        .name = PVR_DRM_NAME,
+        .id_table = asPciIdList,
+};
+#endif
+
 static int __init PVRSRVDrmInit(void)
 {
 	int iRes;
@@ -335,7 +422,11 @@ static int __init PVRSRVDrmInit(void)
 	}
 #endif
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,38))
 	iRes = drm_init(&sPVRDrmDriver);
+#else
+	iRes = drm_pci_init(&sPVRDrmDriver,&pci_pvr_driver);
+#endif
 #if defined(PVR_DRI_DRM_NOT_PCI)
 	if (iRes != 0)
 	{
@@ -347,7 +438,11 @@ static int __init PVRSRVDrmInit(void)
 	
 static void __exit PVRSRVDrmExit(void)
 {
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,38))
 	drm_exit(&sPVRDrmDriver);
+#else
+	drm_pci_exit(&sPVRDrmDriver,&pci_pvr_driver);
+#endif
 
 #if defined(PVR_DRI_DRM_NOT_PCI)
 	drm_pvr_dev_remove();
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_uaccess.h b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_uaccess.h
index 04fdcc2..7bc47ac 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_uaccess.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_uaccess.h
@@ -27,11 +27,14 @@
 #ifndef __PVR_UACCESS_H__
 #define __PVR_UACCESS_H__
 
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 #ifndef AUTOCONF_INCLUDED
  #include <linux/config.h>
 #endif
+#endif
 
-#include <linux/version.h>
 #include <asm/uaccess.h>
 
 static inline unsigned long pvr_copy_to_user(void __user *pvTo, const void *pvFrom, unsigned long ulBytes)
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h
index 9b34224..5c57200 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h
@@ -61,6 +61,7 @@
 	#endif
         #if SGX_CORE_REV == 103
                #define FIX_HW_BRN_22934
+	       #define FIX_HW_BRN_28889
         #else
 
 	#if SGX_CORE_REV == 110
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/device.h b/drivers/staging/omap3-sgx/services4/srvkm/include/device.h
index bed2351..f41bd9e 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/device.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/device.h
@@ -288,11 +288,12 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVDeinitialiseDevice(IMG_UINT32 ui32DevIndex);
 
 #if !defined(USE_CODE)
 
-IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PollForValueKM(volatile IMG_UINT32* pui32LinMemAddr,
-												   IMG_UINT32 ui32Value,
-												   IMG_UINT32 ui32Mask,
-												   IMG_UINT32 ui32Waitus,
-												   IMG_UINT32 ui32Tries);
+IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PollForValueKM(volatile IMG_UINT32*	pui32LinMemAddr,
+													IMG_UINT32				ui32Value,
+													IMG_UINT32				ui32Mask,
+													IMG_UINT32				ui32Timeoutus,
+													IMG_UINT32				ui32PollPeriodus,
+													IMG_BOOL				bAllowPreemption);
 
 #endif 
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/osfunc.h b/drivers/staging/omap3-sgx/services4/srvkm/include/osfunc.h
index 8ffbea6..ab86788 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/osfunc.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/osfunc.h
@@ -445,6 +445,7 @@ PVRSRV_ERROR OSCreateResource(PVRSRV_RESOURCE *psResource);
 PVRSRV_ERROR OSDestroyResource(PVRSRV_RESOURCE *psResource);
 IMG_VOID OSBreakResourceLock(PVRSRV_RESOURCE *psResource, IMG_UINT32 ui32ID);
 IMG_VOID OSWaitus(IMG_UINT32 ui32Timeus);
+IMG_VOID OSSleepms(IMG_UINT32 ui32Timems);
 IMG_VOID OSReleaseThreadQuanta(IMG_VOID);
 IMG_UINT32 OSPCIReadDword(IMG_UINT32 ui32Bus, IMG_UINT32 ui32Dev, IMG_UINT32 ui32Func, IMG_UINT32 ui32Reg);
 IMG_VOID OSPCIWriteDword(IMG_UINT32 ui32Bus, IMG_UINT32 ui32Dev, IMG_UINT32 ui32Func, IMG_UINT32 ui32Reg, IMG_UINT32 ui32Value);
diff --git a/drivers/staging/omap3-sgx/services4/system/omap4/sysinfo.h b/drivers/staging/omap3-sgx/services4/system/omap4/sysinfo.h
index 42489f0..f9d7e68 100644
--- a/drivers/staging/omap3-sgx/services4/system/omap4/sysinfo.h
+++ b/drivers/staging/omap3-sgx/services4/system/omap4/sysinfo.h
@@ -36,6 +36,7 @@
 #endif
 
 
-#define SYS_DEVICE_COUNT 15 
+//#define SYS_DEVICE_COUNT 15 
+#define SYS_DEVICE_COUNT 3
 
 #endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/omap4/sysutils_linux.c b/drivers/staging/omap3-sgx/services4/system/omap4/sysutils_linux.c
index b23d5ec..7aaaefb 100644
--- a/drivers/staging/omap3-sgx/services4/system/omap4/sysutils_linux.c
+++ b/drivers/staging/omap3-sgx/services4/system/omap4/sysutils_linux.c
@@ -43,7 +43,7 @@
 #endif
 
 #if ((defined(DEBUG) || defined(TIMING)) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34)))
-#define	PVR_OMAP4_TIMING_PRCM
+//#define	PVR_OMAP4_TIMING_PRCM
 #endif
 
 #define	ONE_MHZ	1000000
@@ -259,6 +259,9 @@ IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
 
 PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 {
+
+	PVR_TRACE(("Enter Enabling System Clocks"));
+	PVRSRV_ERROR eError;
 	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
 #if (defined(OMAP4_PRCM_ENABLE) || defined(PVR_OMAP4_TIMING_PRCM))
 	struct clk *psCLK;
@@ -268,7 +271,6 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 	struct clk *sys_ck;
 	IMG_INT rate;
 #endif
-	PVRSRV_ERROR eError;
 
 #if (defined(DEBUG) || defined(TIMING))
 	IMG_CPU_PHYADDR     TimerRegPhysBase;
@@ -332,8 +334,7 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 #if (defined(DEBUG) || defined(TIMING))
 
 #if defined(PVR_OMAP4_TIMING_PRCM)
-	
-	psCLK = clk_get(NULL, "gpt11_fck");
+psCLK = clk_get(NULL, "timer11_fck");
 	if (IS_ERR(psCLK))
 	{
 		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
@@ -341,14 +342,15 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 	}
 	psSysSpecData->psGPT11_FCK = psCLK;
 
-	psCLK = clk_get(NULL, "gpt11_ick");
+	PVR_TRACE(("EnableSystemClocks: After Timer 11 clk_get"));
+/*	psCLK = clk_get(NULL, "gpt11_ick");
 	if (IS_ERR(psCLK))
 	{
 		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
 		goto ExitUnRegisterConstraintNotifications;
 	}
 	psSysSpecData->psGPT11_ICK = psCLK;
-
+*/
 	sys_ck = clk_get(NULL, "sys_clkin_ck");
 	if (IS_ERR(sys_ck))
 	{
@@ -356,6 +358,7 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 		goto ExitUnRegisterConstraintNotifications;
 	}
 
+	PVR_TRACE(("EnableSystemClocks: After system clk_get"));
 	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
 	{
 		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
@@ -367,6 +370,7 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 		}
 	}
 
+	PVR_TRACE(("EnableSystemClocks: After set parent "));
 	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
 	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
 
@@ -377,21 +381,23 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 		goto ExitUnRegisterConstraintNotifications;
 	}
 
-	res = clk_enable(psSysSpecData->psGPT11_ICK);
+	PVR_TRACE(("EnableSystemClocks: After clk enable "));
+/*	res = clk_enable(psSysSpecData->psGPT11_ICK);
 	if (res < 0)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
 		goto ExitDisableGPT11FCK;
 	}
+*/
 #endif	
 
-	
 	TimerRegPhysBase.uiAddr = SYS_OMAP4430_GP11TIMER_TSICR_SYS_PHYS_BASE;
 	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
                   4,
                   PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
                   &hTimerEnable);
 
+	PVR_TRACE(("EnableSystemClocks: After OSMapPhystoLin "));
 	if (pui32TimerEnable == IMG_NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
@@ -410,7 +416,6 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 		    4,
 		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
 		    hTimerEnable);
-
 	
 	TimerRegPhysBase.uiAddr = SYS_OMAP4430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
 	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
@@ -426,21 +431,19 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 
 	
 	*pui32TimerEnable = 3;
-
 	OSUnMapPhysToLin(pui32TimerEnable,
 		    4,
 		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
 		    hTimerEnable);
-
-#endif 
-
+#endif
+	PVR_TRACE(("Exit Enabling System Clocks"));
 	eError = PVRSRV_OK;
 	goto Exit;
 
 #if (defined(DEBUG) || defined(TIMING))
 ExitDisableGPT11ICK:
 #if defined(PVR_OMAP4_TIMING_PRCM)
-	clk_disable(psSysSpecData->psGPT11_ICK);
+//	clk_disable(psSysSpecData->psGPT11_ICK);
 ExitDisableGPT11FCK:
 	clk_disable(psSysSpecData->psGPT11_FCK);
 ExitUnRegisterConstraintNotifications:
@@ -471,13 +474,11 @@ IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
 	DisableSGXClocks(psSysData);
 
 #if (defined(DEBUG) || defined(TIMING))
-	
 	TimerRegPhysBase.uiAddr = SYS_OMAP4430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
 	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
 				4,
 				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
 				&hTimerDisable);
-
 	if (pui32TimerDisable == IMG_NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
@@ -491,9 +492,8 @@ IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
 				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
 				hTimerDisable);
 	}
-
 #if defined(PVR_OMAP4_TIMING_PRCM)
-	clk_disable(psSysSpecData->psGPT11_ICK);
+//	clk_disable(psSysSpecData->psGPT11_ICK);
 
 	clk_disable(psSysSpecData->psGPT11_FCK);
 #endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/ti335x/oemfuncs.h b/drivers/staging/omap3-sgx/services4/system/ti335x/oemfuncs.h
new file mode 100644
index 0000000..206f7fa
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti335x/oemfuncs.h
@@ -0,0 +1,56 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__OEMFUNCS_H__)
+#define __OEMFUNCS_H__
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+typedef IMG_UINT32   (*PFN_SRV_BRIDGEDISPATCH)( IMG_UINT32  Ioctl,
+												IMG_BYTE   *pInBuf,
+												IMG_UINT32  InBufLen, 
+											    IMG_BYTE   *pOutBuf,
+												IMG_UINT32  OutBufLen,
+												IMG_UINT32 *pdwBytesTransferred);
+typedef struct PVRSRV_DC_OEM_JTABLE_TAG
+{
+	PFN_SRV_BRIDGEDISPATCH			pfnOEMBridgeDispatch;
+	IMG_PVOID						pvDummy1;
+	IMG_PVOID						pvDummy2;
+	IMG_PVOID						pvDummy3;
+
+} PVRSRV_DC_OEM_JTABLE;
+
+#define OEM_GET_EXT_FUNCS			(1<<1)
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	
+
diff --git a/drivers/staging/omap3-sgx/services4/system/ti335x/sysconfig.c b/drivers/staging/omap3-sgx/services4/system/ti335x/sysconfig.c
new file mode 100644
index 0000000..be47008
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti335x/sysconfig.c
@@ -0,0 +1,974 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include "services_headers.h"
+#include "kerneldisplay.h"
+#include "oemfuncs.h"
+#include "sgxinfo.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+#include "sysconfig.h"
+
+#include "ocpdefs.h"
+
+#if !defined(NO_HARDWARE) && \
+     defined(SYS_USING_INTERRUPTS) && \
+     defined(SGX530) && (SGX_CORE_REV == 125)
+#define SGX_OCP_REGS_ENABLED
+#endif
+
+SYS_DATA* gpsSysData = (SYS_DATA*)IMG_NULL;
+SYS_DATA  gsSysData;
+
+static SYS_SPECIFIC_DATA gsSysSpecificData;
+SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
+static IMG_UINT32	gui32SGXDeviceID;
+static SGX_DEVICE_MAP	gsSGXDeviceMap;
+static PVRSRV_DEVICE_NODE *gpsSGXDevNode;
+
+#define DEVICE_SGX_INTERRUPT (1 << 0)
+
+#if defined(NO_HARDWARE)
+static IMG_CPU_VIRTADDR gsSGXRegsCPUVAddr;
+#endif
+
+IMG_UINT32 PVRSRV_BridgeDispatchKM(IMG_UINT32	Ioctl,
+								   IMG_BYTE		*pInBuf,
+								   IMG_UINT32	InBufLen,
+								   IMG_BYTE		*pOutBuf,
+								   IMG_UINT32	OutBufLen,
+								   IMG_UINT32	*pdwBytesTransferred);
+
+#if defined(DEBUG) && defined(DUMP_OMAP34xx_CLOCKS) && defined(__linux__)
+
+#pragma GCC diagnostic ignored "-Wstrict-prototypes"
+#include <mach/clock.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+#include <../mach-omap2/clock_34xx.h>
+#define ONCHIP_CLKS onchip_clks
+#else
+#include <../mach-omap2/clock34xx.h>
+#define ONCHIP_CLKS onchip_34xx_clks
+#endif
+
+static void omap3_clk_recalc(struct clk *clk) {}
+static void omap3_followparent_recalc(struct clk *clk) {}
+static void omap3_propagate_rate(struct clk *clk) {}
+static void omap3_table_recalc(struct clk *clk) {}
+static long omap3_round_to_table_rate(struct clk *clk, unsigned long rate) { return 0; }
+static int omap3_select_table_rate(struct clk *clk, unsigned long rate) { return 0; }
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+static void omap3_dpll_recalc(struct clk *clk, unsigned long parent_rate,
+							  u8 rate_storage) {}
+static void omap3_clkoutx2_recalc(struct clk *clk, unsigned long parent_rate,
+								  u8 rate_storage) {}
+static void omap3_dpll_allow_idle(struct clk *clk) {}
+static void omap3_dpll_deny_idle(struct clk *clk) {}
+static u32 omap3_dpll_autoidle_read(struct clk *clk) { return 0; }
+static int omap3_noncore_dpll_enable(struct clk *clk) { return 0; }
+static void omap3_noncore_dpll_disable(struct clk *clk) {}
+static int omap3_noncore_dpll_set_rate(struct clk *clk, unsigned long rate) { return 0; }
+static int omap3_core_dpll_m2_set_rate(struct clk *clk, unsigned long rate) { return 0; }
+void followparent_recalc(struct clk *clk, unsigned long new_parent_rate,
+								u8 rate_storage) {}
+long omap2_dpll_round_rate(struct clk *clk, unsigned long target_rate) { return 0; }
+void omap2_clksel_recalc(struct clk *clk, unsigned long new_parent_rate,
+								u8 rate_storage) {}
+long omap2_clksel_round_rate(struct clk *clk, unsigned long target_rate) { return 0; }
+int omap2_clksel_set_rate(struct clk *clk, unsigned long rate) { return 0; }
+void omap2_fixed_divisor_recalc(struct clk *clk, unsigned long new_parent_rate,
+									   u8 rate_storage) {}
+void omap2_init_clksel_parent(struct clk *clk) {}
+#endif
+
+static void dump_omap34xx_clocks(void)
+{
+	struct clk **c;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+	struct vdd_prcm_config *t1 = vdd1_rate_table;
+	struct vdd_prcm_config *t2 = vdd2_rate_table;
+
+	t1 = t1;
+	t2 = t2;
+#else
+	
+	omap3_dpll_allow_idle(0);
+	omap3_dpll_deny_idle(0);
+	omap3_dpll_autoidle_read(0);
+	omap3_clk_recalc(0);
+	omap3_followparent_recalc(0);
+	omap3_propagate_rate(0);
+	omap3_table_recalc(0);
+	omap3_round_to_table_rate(0, 0);
+	omap3_select_table_rate(0, 0);
+#endif
+
+	for(c = ONCHIP_CLKS; c < ONCHIP_CLKS + ARRAY_SIZE(ONCHIP_CLKS); c++)
+	{
+		struct clk *cp = *c, *copy;
+		unsigned long rate;
+		copy = clk_get(NULL, cp->name);
+		if(!copy)
+			continue;
+		rate = clk_get_rate(copy);
+		if (rate < 1000000)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: clock %s is %lu KHz (%lu Hz)", __func__, cp->name, rate/1000, rate));
+		}
+		else
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: clock %s is %lu MHz (%lu Hz)", __func__, cp->name, rate/1000000, rate));
+		}
+	}
+}
+
+#else  
+
+static INLINE void dump_omap34xx_clocks(void) {}
+
+#endif 
+
+#if defined(SGX_OCP_REGS_ENABLED)
+
+#define SYS_TI335x_OCP_REGS_SYS_PHYS_BASE		(SYS_TI335x_SGX_REGS_SYS_PHYS_BASE + EUR_CR_OCP_REVISION)
+#define SYS_TI335x_OCP_REGS_SIZE				0x110
+
+static IMG_CPU_VIRTADDR gpvOCPRegsLinAddr;
+
+static PVRSRV_ERROR EnableSGXClocksWrap(SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError = EnableSGXClocks(psSysData);
+
+	if(eError == PVRSRV_OK)
+	{
+		OSWriteHWReg(gpvOCPRegsLinAddr,
+					 EUR_CR_OCP_DEBUG_CONFIG - EUR_CR_OCP_REVISION,
+					 EUR_CR_OCP_DEBUG_CONFIG_THALIA_INT_BYPASS_MASK);
+	}
+
+	return eError;
+}
+
+#else 
+
+static INLINE PVRSRV_ERROR EnableSGXClocksWrap(SYS_DATA *psSysData)
+{
+	return EnableSGXClocks(psSysData);
+}
+
+#endif 
+
+static INLINE PVRSRV_ERROR EnableSystemClocksWrap(SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError = EnableSystemClocks(psSysData);
+
+#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if(eError == PVRSRV_OK)
+	{
+		
+		EnableSGXClocksWrap(psSysData);
+	}
+#endif
+
+	return eError;
+}
+
+static PVRSRV_ERROR SysLocateDevices(SYS_DATA *psSysData)
+{
+#if defined(NO_HARDWARE)
+	PVRSRV_ERROR eError;
+	IMG_CPU_PHYADDR sCpuPAddr;
+#endif
+
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+
+	
+	gsSGXDeviceMap.ui32Flags = 0x0;
+	
+#if defined(NO_HARDWARE)
+	
+	
+	eError = OSBaseAllocContigMemory(SYS_TI335x_SGX_REGS_SIZE, 
+									 &gsSGXRegsCPUVAddr,
+									 &sCpuPAddr);
+	if(eError != PVRSRV_OK)
+	{
+		return eError;
+	}
+	gsSGXDeviceMap.sRegsCpuPBase = sCpuPAddr;
+	gsSGXDeviceMap.sRegsSysPBase = SysCpuPAddrToSysPAddr(gsSGXDeviceMap.sRegsCpuPBase);
+	gsSGXDeviceMap.ui32RegsSize = SYS_TI335x_SGX_REGS_SIZE;
+#if defined(__linux__)
+	
+	gsSGXDeviceMap.pvRegsCpuVBase = gsSGXRegsCPUVAddr;
+#else
+	
+	gsSGXDeviceMap.pvRegsCpuVBase = IMG_NULL;
+#endif
+
+	OSMemSet(gsSGXRegsCPUVAddr, 0, SYS_TI335x_SGX_REGS_SIZE);
+
+	
+
+
+	gsSGXDeviceMap.ui32IRQ = 0;
+
+#else 
+
+	gsSGXDeviceMap.sRegsSysPBase.uiAddr = SYS_TI335x_SGX_REGS_SYS_PHYS_BASE;
+	gsSGXDeviceMap.sRegsCpuPBase = SysSysPAddrToCpuPAddr(gsSGXDeviceMap.sRegsSysPBase);
+	gsSGXDeviceMap.ui32RegsSize = SYS_TI335x_SGX_REGS_SIZE;
+
+	gsSGXDeviceMap.ui32IRQ = SYS_TI335x_SGX_IRQ;
+
+#endif 
+
+#if defined(PDUMP)
+	{
+		
+		static IMG_CHAR pszPDumpDevName[] = "SGXMEM";
+		gsSGXDeviceMap.pszPDumpDevName = pszPDumpDevName;
+	}
+#endif
+
+	
+
+
+	return PVRSRV_OK;
+}
+
+
+IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion)
+{
+	static IMG_CHAR aszVersionString[100];
+	SYS_DATA	*psSysData;
+	IMG_UINT32	ui32SGXRevision;
+	IMG_INT32	i32Count;
+#if !defined(NO_HARDWARE)
+	IMG_VOID	*pvRegsLinAddr;
+
+	pvRegsLinAddr = OSMapPhysToLin(sRegRegion,
+								   SYS_TI335x_SGX_REGS_SIZE,
+								   PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+								   IMG_NULL);
+	if(!pvRegsLinAddr)
+	{
+		return IMG_NULL;
+	}
+
+	ui32SGXRevision = OSReadHWReg((IMG_PVOID)((IMG_PBYTE)pvRegsLinAddr),
+								  EUR_CR_CORE_REVISION);
+#else
+	ui32SGXRevision = 0;
+#endif
+
+	SysAcquireData(&psSysData);
+
+	i32Count = OSSNPrintf(aszVersionString, 100,
+						  "SGX revision = %u.%u.%u",
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAJOR_MASK)
+							>> EUR_CR_CORE_REVISION_MAJOR_SHIFT),
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MINOR_MASK)
+							>> EUR_CR_CORE_REVISION_MINOR_SHIFT),
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAINTENANCE_MASK)
+							>> EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT)
+						 );
+
+#if !defined(NO_HARDWARE)
+	OSUnMapPhysToLin(pvRegsLinAddr,
+					 SYS_TI335x_SGX_REGS_SIZE,
+					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+					 IMG_NULL);
+#endif
+
+	if(i32Count == -1)
+	{
+		return IMG_NULL;
+	}
+
+	return aszVersionString;
+}
+
+
+PVRSRV_ERROR SysInitialise(IMG_VOID)
+{
+	IMG_UINT32			i;
+	PVRSRV_ERROR 		eError;
+	PVRSRV_DEVICE_NODE	*psDeviceNode;
+	IMG_CPU_PHYADDR		TimerRegPhysBase;
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+	SGX_TIMING_INFORMATION*	psTimingInfo;
+#endif
+	gpsSysData = &gsSysData;
+	OSMemSet(gpsSysData, 0, sizeof(SYS_DATA));
+
+	gpsSysSpecificData =  &gsSysSpecificData;
+	OSMemSet(gpsSysSpecificData, 0, sizeof(SYS_SPECIFIC_DATA));
+
+	gpsSysData->pvSysSpecificData = gpsSysSpecificData;
+
+	eError = OSInitEnvData(&gpsSysData->pvEnvSpecificData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to setup env structure"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA);
+
+	gpsSysData->ui32NumDevices = SYS_DEVICE_COUNT;
+
+	
+	for(i=0; i<SYS_DEVICE_COUNT; i++)
+	{
+		gpsSysData->sDeviceID[i].uiID = i;
+		gpsSysData->sDeviceID[i].bInUse = IMG_FALSE;
+	}
+
+	gpsSysData->psDeviceNodeList = IMG_NULL;
+	gpsSysData->psQueueList = IMG_NULL;
+
+	eError = SysInitialiseCommon(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed in SysInitialiseCommon"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+
+	TimerRegPhysBase.uiAddr = SYS_TI335x_GP7TIMER_REGS_SYS_PHYS_BASE;
+	gpsSysData->pvSOCTimerRegisterKM = IMG_NULL;
+	gpsSysData->hSOCTimerRegisterOSMemHandle = 0;
+	OSReservePhys(TimerRegPhysBase,
+				  4,
+				  PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
+				  (IMG_VOID **)&gpsSysData->pvSOCTimerRegisterKM,
+				  &gpsSysData->hSOCTimerRegisterOSMemHandle);
+
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+	
+	psTimingInfo = &gsSGXDeviceMap.sTimingInfo;
+	psTimingInfo->ui32CoreClockSpeed = SYS_SGX_CLOCK_SPEED;
+
+	psTimingInfo->ui32HWRecoveryFreq = SYS_SGX_HWRECOVERY_TIMEOUT_FREQ; 
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else	
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS; 
+	psTimingInfo->ui32uKernelFreq = SYS_SGX_PDS_TIMER_FREQ; 
+#endif
+
+	
+
+	gpsSysSpecificData->ui32SrcClockDiv = 3;
+
+	
+
+
+
+	eError = SysLocateDevices(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to locate devices"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV);
+
+#if defined(SGX_OCP_REGS_ENABLED)
+	{
+		IMG_SYS_PHYADDR sOCPRegsSysPBase;
+		IMG_CPU_PHYADDR sOCPRegsCpuPBase;
+
+		sOCPRegsSysPBase.uiAddr	= SYS_TI335x_OCP_REGS_SYS_PHYS_BASE;
+		sOCPRegsCpuPBase		= SysSysPAddrToCpuPAddr(sOCPRegsSysPBase);
+
+		gpvOCPRegsLinAddr		= OSMapPhysToLin(sOCPRegsCpuPBase,
+												 SYS_TI335x_OCP_REGS_SIZE,
+												 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+												 IMG_NULL);
+
+		if (gpvOCPRegsLinAddr == IMG_NULL)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to map OCP registers"));
+			return PVRSRV_ERROR_BAD_MAPPING;
+		}
+	}
+#endif
+
+	
+
+
+	eError = PVRSRVRegisterDevice(gpsSysData, SGXRegisterDevice,
+								  DEVICE_SGX_INTERRUPT, &gui32SGXDeviceID);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to register device!"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_REGDEV);
+
+	
+
+
+	
+	psDeviceNode = gpsSysData->psDeviceNodeList;
+	while(psDeviceNode)
+	{
+		
+		switch(psDeviceNode->sDevId.eDeviceType)
+		{
+			case PVRSRV_DEVICE_TYPE_SGX:
+			{
+				DEVICE_MEMORY_INFO *psDevMemoryInfo;
+				DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+
+				
+
+
+				psDeviceNode->psLocalDevMemArena = IMG_NULL;
+
+				
+				psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
+				psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
+
+				
+				for(i=0; i<psDevMemoryInfo->ui32HeapCount; i++)
+				{
+					psDeviceMemoryHeap[i].ui32Attribs |= PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG;
+				}
+
+				gpsSGXDevNode = psDeviceNode;
+				gsSysSpecificData.psSGXDevNode = psDeviceNode;
+
+				break;
+			}
+			default:
+				PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to find SGX device node!"));
+				return PVRSRV_ERROR_INIT_FAILURE;
+		}
+
+		
+		psDeviceNode = psDeviceNode->psNext;
+	}
+
+	eError = EnableSystemClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable system clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	eError = EnableSGXClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+#endif	
+
+	dump_omap34xx_clocks();
+
+	eError = PVRSRVInitialiseDevice(gui32SGXDeviceID);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to initialise device!"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV);
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	DisableSGXClocks(gpsSysData);
+#endif	
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysFinalise(IMG_VOID)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	eError = EnableSGXClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+#endif	
+
+#if defined(SYS_USING_INTERRUPTS)
+
+	eError = OSInstallMISR(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install MISR"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR);
+
+	
+	eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install ISR"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+#endif 
+
+	
+	gpsSysData->pszVersionString = SysCreateVersionString(gsSGXDeviceMap.sRegsCpuPBase);
+	if (!gpsSysData->pszVersionString)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to create a system version string"));
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_WARNING, "SysFinalise: Version string: %s", gpsSysData->pszVersionString));
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	DisableSGXClocks(gpsSysData);
+#endif	
+
+	gpsSysSpecificData->bSGXInitComplete = IMG_TRUE;
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysDeinitialise (SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError;
+
+#if defined(SYS_USING_INTERRUPTS)
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+	{
+		eError = OSUninstallDeviceLISR(psSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallDeviceLISR failed"));
+			return eError;
+		}
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR))
+	{
+		eError = OSUninstallMISR(psSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallMISR failed"));
+			return eError;
+		}
+	}
+#else
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif 
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV))
+	{
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+		PVR_ASSERT(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS));
+		
+		eError = EnableSGXClocksWrap(gpsSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: EnableSGXClocks failed"));
+			return eError;
+		}
+#endif	
+
+		
+		eError = PVRSRVDeinitialiseDevice (gui32SGXDeviceID);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init the device"));
+			return eError;
+		}
+	}
+	
+#if defined(SGX_OCP_REGS_ENABLED)
+	OSUnMapPhysToLin(gpvOCPRegsLinAddr,
+					 SYS_TI335x_OCP_REGS_SIZE,
+					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+					 IMG_NULL);
+#endif
+
+	
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+	{
+		DisableSystemClocks(gpsSysData);
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA))
+	{	
+		eError = OSDeInitEnvData(gpsSysData->pvEnvSpecificData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init env structure"));
+			return eError;
+		}
+	}
+
+	if(gpsSysData->pvSOCTimerRegisterKM)
+	{
+		OSUnReservePhys(gpsSysData->pvSOCTimerRegisterKM,
+						4,
+						PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
+						gpsSysData->hSOCTimerRegisterOSMemHandle);
+	}
+
+	SysDeinitialiseCommon(gpsSysData);
+
+#if defined(NO_HARDWARE)
+	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV))
+	{
+		
+		OSBaseFreeContigMemory(SYS_TI335x_SGX_REGS_SIZE, gsSGXRegsCPUVAddr, gsSGXDeviceMap.sRegsCpuPBase);
+	}
+#endif
+
+	
+	gpsSysSpecificData->ui32SysSpecificData = 0;
+	gpsSysSpecificData->bSGXInitComplete = IMG_FALSE;
+
+	gpsSysData = IMG_NULL;
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE	eDeviceType,
+								   IMG_VOID				**ppvDeviceMap)
+{
+
+	switch(eDeviceType)
+	{
+		case PVRSRV_DEVICE_TYPE_SGX:
+		{
+			
+			*ppvDeviceMap = (IMG_VOID*)&gsSGXDeviceMap;
+
+			break;
+		}
+		default:
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysGetDeviceMemoryMap: unsupported device type"));
+		}
+	}
+	return PVRSRV_OK;
+}
+
+
+IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE	eDeviceType,
+									  IMG_CPU_PHYADDR		CpuPAddr)
+{
+	IMG_DEV_PHYADDR DevPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	DevPAddr.uiAddr = CpuPAddr.uiAddr;
+	
+	return DevPAddr;
+}
+
+IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr (IMG_SYS_PHYADDR sys_paddr)
+{
+	IMG_CPU_PHYADDR cpu_paddr;
+
+	
+	cpu_paddr.uiAddr = sys_paddr.uiAddr;
+	return cpu_paddr;
+}
+
+IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr (IMG_CPU_PHYADDR cpu_paddr)
+{
+	IMG_SYS_PHYADDR sys_paddr;
+
+	
+	sys_paddr.uiAddr = cpu_paddr.uiAddr;
+	return sys_paddr;
+}
+
+
+IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_SYS_PHYADDR SysPAddr)
+{
+	IMG_DEV_PHYADDR DevPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	DevPAddr.uiAddr = SysPAddr.uiAddr;
+
+	return DevPAddr;
+}
+
+
+IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_DEV_PHYADDR DevPAddr)
+{
+	IMG_SYS_PHYADDR SysPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	SysPAddr.uiAddr = DevPAddr.uiAddr;
+
+	return SysPAddr;
+}
+
+
+IMG_VOID SysRegisterExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+}
+
+
+IMG_VOID SysRemoveExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+}
+
+
+IMG_UINT32 SysGetInterruptSource(SYS_DATA			*psSysData,
+								 PVRSRV_DEVICE_NODE	*psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#if defined(NO_HARDWARE)
+	
+	return 0xFFFFFFFF;
+#else
+	
+	return psDeviceNode->ui32SOCInterruptBit;
+#endif
+}
+
+
+IMG_VOID SysClearInterrupts(SYS_DATA* psSysData, IMG_UINT32 ui32ClearBits)
+{
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+	PVR_UNREFERENCED_PARAMETER(ui32ClearBits);
+
+	
+	OSReadHWReg(((PVRSRV_SGXDEV_INFO *)gpsSGXDevNode->pvDevice)->pvRegsBaseKM,
+										EUR_CR_EVENT_HOST_CLEAR);
+}
+
+
+PVRSRV_ERROR SysSystemPrePowerState(PVRSRV_SYS_POWER_STATE eNewPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (eNewPowerState == PVRSRV_SYS_POWER_STATE_D3)
+	{
+		PVR_TRACE(("SysSystemPrePowerState: Entering state D3"));
+
+#if defined(SYS_USING_INTERRUPTS)
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+		{
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
+#endif
+			eError = OSUninstallDeviceLISR(gpsSysData);
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			if (bWrapped)
+			{
+				UnwrapSystemPowerChange(&gsSysSpecificData);
+			}
+#endif
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPrePowerState: OSUninstallDeviceLISR failed (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+		}
+#endif
+
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+		{
+			DisableSystemClocks(gpsSysData);
+
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+		}
+	}
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysSystemPostPowerState(PVRSRV_SYS_POWER_STATE eNewPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (eNewPowerState == PVRSRV_SYS_POWER_STATE_D0)
+	{
+		PVR_TRACE(("SysSystemPostPowerState: Entering state D0"));
+
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS))
+		{
+			eError = EnableSystemClocksWrap(gpsSysData);
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: EnableSystemClocksWrap failed (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+		}
+
+#if defined(SYS_USING_INTERRUPTS)
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR))
+		{
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
+#endif
+
+			eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			if (bWrapped)
+			{
+				UnwrapSystemPowerChange(&gsSysSpecificData);
+			}
+#endif
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: OSInstallDeviceLISR failed to install ISR (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+		}
+#endif
+	}
+	return eError;
+}
+
+
+PVRSRV_ERROR SysDevicePrePowerState(IMG_UINT32				ui32DeviceIndex,
+									PVRSRV_DEV_POWER_STATE	eNewPowerState,
+									PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
+{
+	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
+
+	if (ui32DeviceIndex != gui32SGXDeviceID)
+	{
+		return PVRSRV_OK;
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eNewPowerState == PVRSRV_DEV_POWER_STATE_OFF)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePrePowerState: SGX Entering state D3"));
+		DisableSGXClocks(gpsSysData);
+	}
+#else	
+	PVR_UNREFERENCED_PARAMETER(eNewPowerState );
+#endif 
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysDevicePostPowerState(IMG_UINT32				ui32DeviceIndex,
+									 PVRSRV_DEV_POWER_STATE	eNewPowerState,
+									 PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	PVR_UNREFERENCED_PARAMETER(eNewPowerState);
+
+	if (ui32DeviceIndex != gui32SGXDeviceID)
+	{
+		return eError;
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eCurrentPowerState == PVRSRV_DEV_POWER_STATE_OFF)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePostPowerState: SGX Leaving state D3"));
+		eError = EnableSGXClocksWrap(gpsSysData);
+	}
+#else	
+	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
+#endif	
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysOEMFunction (	IMG_UINT32	ui32ID,
+								IMG_VOID	*pvIn,
+								IMG_UINT32	ulInSize,
+								IMG_VOID	*pvOut,
+								IMG_UINT32	ulOutSize)
+{
+	PVR_UNREFERENCED_PARAMETER(ui32ID);
+	PVR_UNREFERENCED_PARAMETER(pvIn);
+	PVR_UNREFERENCED_PARAMETER(ulInSize);
+	PVR_UNREFERENCED_PARAMETER(pvOut);
+	PVR_UNREFERENCED_PARAMETER(ulOutSize);
+
+	if ((ui32ID == OEM_GET_EXT_FUNCS) &&
+		(ulOutSize == sizeof(PVRSRV_DC_OEM_JTABLE)))
+	{
+		
+		PVRSRV_DC_OEM_JTABLE *psOEMJTable = (PVRSRV_DC_OEM_JTABLE*) pvOut;
+		psOEMJTable->pfnOEMBridgeDispatch = &PVRSRV_BridgeDispatchKM;
+		return PVRSRV_OK;
+	}
+
+	return PVRSRV_ERROR_INVALID_PARAMS;
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/ti335x/sysconfig.h b/drivers/staging/omap3-sgx/services4/system/ti335x/sysconfig.h
new file mode 100644
index 0000000..db9a774
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti335x/sysconfig.h
@@ -0,0 +1,54 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SOCCONFIG_H__)
+#define __SOCCONFIG_H__
+
+#include "syscommon.h"
+
+#define VS_PRODUCT_NAME	"TI335x"
+
+#define SYS_SGX_CLOCK_SPEED		200000000
+
+#define SYS_SGX_HWRECOVERY_TIMEOUT_FREQ		(100)	
+#define SYS_SGX_PDS_TIMER_FREQ				(1000)	
+
+#if !defined(SYS_SGX_ACTIVE_POWER_LATENCY_MS)
+#define SYS_SGX_ACTIVE_POWER_LATENCY_MS		(1)
+#endif
+
+
+#define SYS_TI335x_SGX_REGS_SYS_PHYS_BASE  0x56000000
+
+#define SYS_TI335x_SGX_REGS_SIZE           0x1000000
+
+#define SYS_TI335x_SGX_IRQ				 37
+
+#define SYS_TI335x_GP7TIMER_ENABLE_SYS_PHYS_BASE      0x4804A038
+#define SYS_TI335x_GP7TIMER_REGS_SYS_PHYS_BASE	      0x4804A03C
+#define SYS_TI335x_GP7TIMER_TSICR_SYS_PHYS_BASE	      0x4804A054
+ 
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/ti335x/sysinfo.h b/drivers/staging/omap3-sgx/services4/system/ti335x/sysinfo.h
new file mode 100644
index 0000000..79766ed
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti335x/sysinfo.h
@@ -0,0 +1,40 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SYSINFO_H__)
+#define __SYSINFO_H__
+
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#define MAX_HW_TIME_US				(1000000)
+#else
+#define MAX_HW_TIME_US				(500000)
+#endif
+
+#define WAIT_TRY_COUNT				(10000)
+
+#define SYS_DEVICE_COUNT 3 
+
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/ti335x/syslocal.h b/drivers/staging/omap3-sgx/services4/system/ti335x/syslocal.h
new file mode 100644
index 0000000..b05fc1c
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti335x/syslocal.h
@@ -0,0 +1,135 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SYSLOCAL_H__)
+#define __SYSLOCAL_H__
+
+#if defined(__linux__)
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#include <linux/mutex.h>
+#else
+#include <linux/spinlock.h>
+#endif
+#include <asm/atomic.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#include <linux/semaphore.h>
+#include <linux/resource.h>
+#else 
+#include <asm/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+#include <asm/arch/resource.h>
+#endif 
+#endif 
+
+#endif 
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+ 
+ 
+IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion);
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData);
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData);
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData);
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData);
+
+#define SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS	0x00000001
+#define SYS_SPECIFIC_DATA_ENABLE_LISR		0x00000002
+#define SYS_SPECIFIC_DATA_ENABLE_MISR		0x00000004
+#define SYS_SPECIFIC_DATA_ENABLE_ENVDATA	0x00000008
+#define SYS_SPECIFIC_DATA_ENABLE_LOCDEV		0x00000010
+#define SYS_SPECIFIC_DATA_ENABLE_REGDEV		0x00000020
+#define SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT	0x00000040
+#define SYS_SPECIFIC_DATA_ENABLE_INITDEV	0x00000080
+#define SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV	0x00000100
+
+#define	SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR	0x00000200
+#define	SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS	0x00000400
+
+#define	SYS_SPECIFIC_DATA_SET(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData |= (flag)))
+
+#define	SYS_SPECIFIC_DATA_CLEAR(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData &= ~(flag)))
+
+#define	SYS_SPECIFIC_DATA_TEST(psSysSpecData, flag) (((psSysSpecData)->ui32SysSpecificData & (flag)) != 0)
+ 
+typedef struct _SYS_SPECIFIC_DATA_TAG_
+{
+	IMG_UINT32	ui32SysSpecificData;
+	PVRSRV_DEVICE_NODE *psSGXDevNode;
+	IMG_BOOL	bSGXInitComplete;
+#if !defined(__linux__)
+	IMG_BOOL	bSGXClocksEnabled;
+#endif
+	IMG_UINT32	ui32SrcClockDiv;
+#if defined(__linux__)
+	IMG_BOOL	bSysClocksOneTimeInit;
+	atomic_t	sSGXClocksEnabled;
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+	struct mutex	sPowerLock;
+#else
+	IMG_BOOL	bConstraintNotificationsEnabled;
+	spinlock_t	sPowerLock;
+	atomic_t	sPowerLockCPU;
+	spinlock_t	sNotifyLock;
+	atomic_t	sNotifyLockCPU;
+	IMG_BOOL	bCallVDD2PostFunc;
+#endif
+	struct clk	*psCORE_CK;
+	struct clk	*psSGX_FCK;
+	struct clk	*psSGX_ICK;
+	struct clk	*psMPU_CK;
+#if defined(DEBUG) || defined(TIMING)
+	struct clk	*psGPT11_FCK;
+	struct clk	*psGPT11_ICK;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))		
+	struct constraint_handle *pVdd2Handle;
+#endif	
+#endif	
+} SYS_SPECIFIC_DATA;
+
+extern SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
+#endif
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	
+
+
diff --git a/drivers/staging/omap3-sgx/services4/system/ti335x/sysutils.c b/drivers/staging/omap3-sgx/services4/system/ti335x/sysutils.c
new file mode 100644
index 0000000..7d81114
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti335x/sysutils.c
@@ -0,0 +1,34 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if defined(__linux__)
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#include "sysutils_linux_wqueue_compat.c"
+#else
+#include "sysutils_linux.c"
+#endif
+#endif
+
diff --git a/drivers/staging/omap3-sgx/services4/system/ti335x/sysutils_linux.c b/drivers/staging/omap3-sgx/services4/system/ti335x/sysutils_linux.c
new file mode 100644
index 0000000..4cac03a
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti335x/sysutils_linux.c
@@ -0,0 +1,774 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/hardirq.h>
+#include <linux/spinlock.h>
+#include <asm/bug.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#include <linux/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
+//#include <plat/resource.h>
+#include <plat/omap-pm.h>
+#else 
+#include <mach/resource.h>
+#endif 
+#else 
+#include <asm/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+#include <asm/arch/resource.h>
+#endif 
+#endif 
+
+#if	(LINUX_VERSION_CODE >  KERNEL_VERSION(2,6,22)) && \
+	(LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,27))
+#define CONSTRAINT_NOTIFICATIONS
+#endif 
+#include "sgxdefs.h"
+#include "services_headers.h"
+#include "sysinfo.h"
+#include "sgxapi_km.h"
+#include "sysconfig.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+
+#define	ONE_MHZ	1000000
+#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
+
+#if defined(SUPPORT_OMAP3430_SGXFCLK_96M)
+#define SGX_PARENT_CLOCK "cm_96m_fck"
+#else
+#define SGX_PARENT_CLOCK "core_ck"
+#endif
+
+//#define DEBUG
+#if !defined(PDUMP) && !defined(NO_HARDWARE)
+static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+	IMG_BOOL bLocked = IMG_FALSE;
+
+	if (!in_interrupt())
+	{
+		iCPU = get_cpu();
+		bLocked = (iCPU == atomic_read(&psSysSpecData->sPowerLockCPU));
+
+		put_cpu();
+	}
+
+	return bLocked;
+}
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+
+	if (!in_interrupt())
+	{
+		
+		iCPU = get_cpu();
+
+		
+		PVR_ASSERT(iCPU != -1);
+
+		PVR_ASSERT(!PowerLockWrappedOnCPU(psSysSpecData));
+
+		spin_lock(&psSysSpecData->sPowerLock);
+
+		atomic_set(&psSysSpecData->sPowerLockCPU, iCPU);
+	}
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		PVR_ASSERT(PowerLockWrappedOnCPU(psSysSpecData));
+
+		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
+
+		spin_unlock(&psSysSpecData->sPowerLock);
+
+		put_cpu();
+	}
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockWrap(psSysSpecData);
+
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockUnwrap(psSysSpecData);
+}
+#else	
+static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+	return IMG_FALSE;
+}
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA unref__ *psSysData)
+{
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA unref__ *psSysData)
+{
+}
+#endif	
+
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_BOOL bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+
+	if (bPowerLock)
+	{
+		PowerLockUnwrap(psSysSpecData);
+	}
+
+	return bPowerLock;
+}
+
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	PowerLockWrap(psSysSpecData);
+}
+
+static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
+{
+	if (rate1 >= rate2)
+	{
+		return val * (rate1 / rate2);
+	}
+
+	return val / (rate2 / rate1);
+}
+
+static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+
+	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
+}
+
+static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
+}
+
+IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
+{
+	IMG_UINT32 rate;
+
+#if defined(NO_HARDWARE)
+	rate = SYS_SGX_CLOCK_SPEED;
+
+#else
+	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
+
+	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+	PVR_ASSERT(rate != 0);
+#endif
+	psTimingInfo->ui32CoreClockSpeed = rate;
+	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
+	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
+}
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+#error "SGX_DYNAMIC_TIMING_INFO must be defined for this platform"
+#endif
+
+static struct constraint_id cnstr_id_vdd2 = {
+	.type = RES_OPP_CO,
+	.data = (IMG_VOID *)"vdd2_opp"
+};
+
+#if !defined(PDUMP) && !defined(NO_HARDWARE)
+static inline IMG_BOOL ConstraintNotificationsEnabled(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	return (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0) && psSysSpecData->bSGXInitComplete && psSysSpecData->bConstraintNotificationsEnabled;
+
+}
+
+static IMG_BOOL NotifyLockedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU = get_cpu();
+	IMG_BOOL bLocked = (iCPU == atomic_read(&psSysSpecData->sNotifyLockCPU));
+
+	put_cpu();
+
+	return bLocked;
+}
+
+static IMG_VOID NotifyLock(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+
+	BUG_ON(in_interrupt());
+
+	
+	iCPU = get_cpu();
+
+	
+	PVR_ASSERT(iCPU != -1);
+
+	PVR_ASSERT(!NotifyLockedOnCPU(psSysSpecData));
+
+	spin_lock(&psSysSpecData->sNotifyLock);
+
+	atomic_set(&psSysSpecData->sNotifyLockCPU, iCPU);
+}
+
+static IMG_VOID NotifyUnlock(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	PVR_ASSERT(NotifyLockedOnCPU(psSysSpecData));
+
+	atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
+
+	spin_unlock(&psSysSpecData->sNotifyLock);
+
+	put_cpu();
+}
+
+static int VDD2PostFunc(struct notifier_block *n, unsigned long event, IMG_VOID *ptr)
+{
+	PVR_UNREFERENCED_PARAMETER(n);
+	PVR_UNREFERENCED_PARAMETER(event);
+	PVR_UNREFERENCED_PARAMETER(ptr);
+
+	if (in_interrupt())
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	
+	if (!NotifyLockedOnCPU(gpsSysSpecificData))
+	{
+		return 0;
+	}
+
+#if defined(DEBUG)
+	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+	{
+		IMG_UINT32 rate;
+
+		rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+
+		PVR_ASSERT(rate != 0);
+
+		PVR_DPF((PVR_DBG_MESSAGE, "%s: SGX clock rate: %dMHz", __FUNCTION__, HZ_TO_MHZ(rate)));
+	}
+#endif
+	if (gpsSysSpecificData->bCallVDD2PostFunc)
+	{
+		PVRSRVDevicePostClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
+
+		gpsSysSpecificData->bCallVDD2PostFunc = IMG_FALSE;
+	}
+	else
+	{
+		if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+		{
+			PVR_TRACE(("%s: Not calling PVR clock speed notification functions", __FUNCTION__));
+		}
+	}
+
+	NotifyUnlock(gpsSysSpecificData);
+
+	return 0;
+}
+
+static int VDD2PreFunc(struct notifier_block *n, unsigned long event, IMG_VOID *ptr)
+{
+	PVR_UNREFERENCED_PARAMETER(n);
+	PVR_UNREFERENCED_PARAMETER(event);
+	PVR_UNREFERENCED_PARAMETER(ptr);
+
+	if (in_interrupt())
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	if (PowerLockWrappedOnCPU(gpsSysSpecificData))
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s Called from within a power transition.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	NotifyLock(gpsSysSpecificData);
+
+	PVR_ASSERT(!gpsSysSpecificData->bCallVDD2PostFunc);
+
+	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+	{
+		PVRSRV_ERROR eError;
+
+		eError = PVRSRVDevicePreClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
+
+		gpsSysSpecificData->bCallVDD2PostFunc = (eError == PVRSRV_OK);
+
+	}
+
+	return 0;
+}
+
+static struct notifier_block sVDD2Pre = {
+	VDD2PreFunc,
+	 NULL
+};
+
+static struct notifier_block sVDD2Post = {
+	VDD2PostFunc,
+	 NULL
+};
+
+static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
+{
+	PVR_TRACE(("Registering constraint notifications"));
+
+	PVR_ASSERT(!gpsSysSpecificData->bConstraintNotificationsEnabled);
+
+	constraint_register_pre_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Pre,
+						max_vdd2_opp+1);
+
+	constraint_register_post_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Post,
+						max_vdd2_opp+1);
+
+	
+	NotifyLock(gpsSysSpecificData);
+	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_TRUE;
+	NotifyUnlock(gpsSysSpecificData);
+
+	PVR_TRACE(("VDD2 constraint notifications registered"));
+}
+
+static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
+{
+	PVR_TRACE(("Unregistering constraint notifications"));
+
+	
+	NotifyLock(gpsSysSpecificData);
+	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_FALSE;
+	NotifyUnlock(gpsSysSpecificData);
+
+	
+	constraint_unregister_pre_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Pre,
+						max_vdd2_opp+1);
+
+	constraint_unregister_post_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Post,
+						max_vdd2_opp+1);
+}
+#else
+static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
+{
+}
+
+static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
+{
+}
+#endif 
+#endif 
+
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	long lNewRate;
+	long lRate;
+	IMG_INT res;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
+	{
+		return PVRSRV_OK;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
+
+	res = clk_enable(psSysSpecData->psSGX_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+#if 0
+	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
+	if (lNewRate <= 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
+		return PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE;
+	}
+
+	
+	lRate = clk_get_rate(psSysSpecData->psSGX_FCK);
+	if (lRate != lNewRate)
+	{
+		res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: Couldn't set SGX functional clock rate (%d)", res));
+		}
+	}
+#endif
+
+//		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+//		PVR_TRACE((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
+#if defined(DEBUG)
+	{
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+	return PVRSRV_OK;
+}
+
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
+	{
+		return;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
+
+	if (psSysSpecData->psSGX_FCK)
+	{
+		clk_disable(psSysSpecData->psSGX_FCK);
+	}
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+}
+
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	struct clk *psCLK;
+	IMG_INT res;
+	PVRSRV_ERROR eError;
+	IMG_BOOL bPowerLock;
+
+#if defined(DEBUG) || defined(TIMING)
+	IMG_INT rate;
+	struct clk *sys_ck;
+	IMG_CPU_PHYADDR     TimerRegPhysBase;
+	IMG_HANDLE hTimerEnable;
+	IMG_UINT32 *pui32TimerEnable;
+
+#endif	
+
+	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
+
+	if (!psSysSpecData->bSysClocksOneTimeInit)
+	{
+		bPowerLock = IMG_FALSE;
+
+		spin_lock_init(&psSysSpecData->sPowerLock);
+		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
+		spin_lock_init(&psSysSpecData->sNotifyLock);
+		atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
+
+		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+                
+		psCLK = clk_get(NULL, "sgx_ck");
+		
+                if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
+			goto ExitError;
+		}
+		if(clk_enable(psCLK) != 0)
+		{
+			printk("Could not enable SGX clock\n");
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_FCK = psCLK;
+
+		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
+	}
+	else
+	{
+		
+		bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+		if (bPowerLock)
+		{
+			PowerLockUnwrap(psSysSpecData);
+		}
+	}
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	psSysSpecData->pVdd2Handle = constraint_get(PVRSRV_MODNAME, &cnstr_id_vdd2);
+	if (IS_ERR(psSysSpecData->pVdd2Handle))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get VDD2 constraint handle"));
+		goto ExitError;
+	}
+
+	RegisterConstraintNotifications();
+#endif
+
+#if defined(DEBUG) || defined(TIMING)
+        psCLK = clk_get(NULL, "gpt7_fck");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_FCK = psCLK;
+
+        psCLK = clk_get(NULL, "gpt7_ick");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_ICK = psCLK;
+
+	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
+	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
+
+	res = clk_enable(psSysSpecData->psGPT11_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	res = clk_enable(psSysSpecData->psGPT11_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
+		goto ExitDisableGPT11FCK;
+	}
+
+	
+	TimerRegPhysBase.uiAddr = SYS_TI335x_GP7TIMER_TSICR_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	rate = *pui32TimerEnable;
+	if(!(rate & 4))
+	{
+		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
+
+		
+		*pui32TimerEnable = rate | 4;
+	}
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+	
+	TimerRegPhysBase.uiAddr = SYS_TI335x_GP7TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	
+	*pui32TimerEnable = 3;
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+#endif 
+
+#if defined(PDUMP) && !defined(NO_HARDWARE) && defined(CONSTRAINT_NOTIFICATIONS)
+	PVR_TRACE(("EnableSystemClocks: Setting SGX OPP constraint"));
+
+	
+	res = constraint_set(psSysSpecData->pVdd2Handle, max_vdd2_opp);
+	if (res != 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: constraint_set failed (%d)", res));
+		goto ExitConstraintSetFailed;
+	}
+#endif
+	eError = PVRSRV_OK;
+	goto Exit;
+
+#if defined(PDUMP) && !defined(NO_HARDWARE) && defined(CONSTRAINT_NOTIFICATIONS)
+ExitConstraintSetFailed:
+#endif
+#if defined(DEBUG) || defined(TIMING)
+ExitDisableGPT11ICK:
+	clk_disable(psSysSpecData->psGPT11_ICK);
+ExitDisableGPT11FCK:
+	clk_disable(psSysSpecData->psGPT11_FCK);
+ExitUnRegisterConstraintNotifications:
+#endif	
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	UnRegisterConstraintNotifications();
+	constraint_put(psSysSpecData->pVdd2Handle);
+#endif
+Exit:
+	if (bPowerLock)
+	{
+		PowerLockWrap(psSysSpecData);
+	}
+
+ExitError:
+	eError = PVRSRV_ERROR_DISABLE_CLOCK_FAILURE;
+	return eError;
+}
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	IMG_BOOL bPowerLock;
+#if defined(DEBUG) || defined(TIMING)
+	IMG_CPU_PHYADDR TimerRegPhysBase;
+	IMG_HANDLE hTimerDisable;
+	IMG_UINT32 *pui32TimerDisable;
+#endif	
+
+	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+
+	
+	DisableSGXClocks(psSysData);
+
+	bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+	if (bPowerLock)
+	{
+		
+		PowerLockUnwrap(psSysSpecData);
+	}
+
+#if defined(PDUMP) && !defined(NO_HARDWARE) && defined(CONSTRAINT_NOTIFICATIONS)
+	{
+		int res;
+
+		PVR_TRACE(("DisableSystemClocks: Removing SGX OPP constraint"));
+
+		
+		res = constraint_remove(psSysSpecData->pVdd2Handle);
+		if (res != 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "DisableSystemClocks: constraint_remove failed (%d)", res));
+		}
+	}
+#endif
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	UnRegisterConstraintNotifications();
+#endif
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	TimerRegPhysBase.uiAddr = SYS_TI335x_GP7TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				&hTimerDisable);
+
+	if (pui32TimerDisable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
+	}
+	else
+	{
+		*pui32TimerDisable = 0;
+
+		OSUnMapPhysToLin(pui32TimerDisable,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				hTimerDisable);
+	}
+
+	clk_disable(psSysSpecData->psGPT11_ICK);
+
+	clk_disable(psSysSpecData->psGPT11_FCK);
+
+#endif 
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	constraint_put(psSysSpecData->pVdd2Handle);
+#endif
+	if (bPowerLock)
+	{
+		PowerLockWrap(psSysSpecData);
+	}
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/ti335x/sysutils_linux_wqueue_compat.c b/drivers/staging/omap3-sgx/services4/system/ti335x/sysutils_linux_wqueue_compat.c
new file mode 100644
index 0000000..4185daf
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti335x/sysutils_linux_wqueue_compat.c
@@ -0,0 +1,505 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/hardirq.h>
+#include <linux/mutex.h>
+
+#include "sgxdefs.h"
+#include "services_headers.h"
+#include "sysinfo.h"
+#include "sgxapi_km.h"
+#include "sysconfig.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+
+#if !defined(PVR_LINUX_USING_WORKQUEUES)
+#error "PVR_LINUX_USING_WORKQUEUES must be defined"
+#endif
+
+#define	ONE_MHZ	1000000
+#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
+
+#if defined(SUPPORT_OMAP3430_SGXFCLK_96M)
+#define SGX_PARENT_CLOCK "cm_96m_fck"
+#else
+#define SGX_PARENT_CLOCK "core_ck"
+#endif
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		mutex_lock(&psSysSpecData->sPowerLock);
+
+	}
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		mutex_unlock(&psSysSpecData->sPowerLock);
+	}
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockWrap(psSysSpecData);
+
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockUnwrap(psSysSpecData);
+}
+
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	return IMG_TRUE;
+}
+
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+}
+
+static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
+{
+	if (rate1 >= rate2)
+	{
+		return val * (rate1 / rate2);
+	}
+
+	return val / (rate2 / rate1);
+}
+
+static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
+}
+
+static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
+}
+
+IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
+{
+	IMG_UINT32 rate;
+
+#if defined(NO_HARDWARE)
+	rate = SYS_SGX_CLOCK_SPEED;
+
+#else
+	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
+
+	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+	PVR_ASSERT(rate != 0);
+#endif
+	psTimingInfo->ui32CoreClockSpeed = rate;
+	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
+	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
+}
+
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+/*
+	long lNewRate;
+	long lRate;
+*/
+	IMG_INT res;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
+	{
+		return PVRSRV_OK;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
+
+#if defined(DEBUG)
+	{
+
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psMPU_CK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	res = clk_enable(psSysSpecData->psSGX_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+/*
+	res = clk_enable(psSysSpecData->psSGX_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX interface clock (%d)", res));
+
+		clk_disable(psSysSpecData->psSGX_FCK);
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
+	if (lNewRate <= 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
+		return PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE;
+	}
+
+	
+	lRate = clk_get_rate(psSysSpecData->psSGX_FCK);
+	if (lRate != lNewRate)
+	{
+		res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: Couldn't set SGX functional clock rate (%d)", res));
+		}
+	}
+*/
+#if defined(DEBUG)
+	{
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+	return PVRSRV_OK;
+}
+
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
+	{
+		return;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
+
+/*	if (psSysSpecData->psSGX_ICK)
+	{
+		clk_disable(psSysSpecData->psSGX_ICK);
+	}
+*/
+	if (psSysSpecData->psSGX_FCK)
+	{
+		clk_disable(psSysSpecData->psSGX_FCK);
+	}
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+}
+
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	struct clk *psCLK;
+//	IMG_INT res;
+//      IMG_BOOL bPowerLock;
+	PVRSRV_ERROR eError;
+
+#if defined(DEBUG) || defined(TIMING)
+        IMG_INT res;
+	IMG_INT rate;
+	struct clk *sys_ck;
+	IMG_CPU_PHYADDR     TimerRegPhysBase;
+	IMG_HANDLE hTimerEnable;
+	IMG_UINT32 *pui32TimerEnable;
+
+#endif	
+
+	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
+
+	if (!psSysSpecData->bSysClocksOneTimeInit)
+	{
+		mutex_init(&psSysSpecData->sPowerLock);
+
+		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+              	psCLK = clk_get(NULL, "sgx_ck");
+                if (IS_ERR(psCLK))
+                {
+                        PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
+                        goto ExitError;
+                }
+		if(clk_enable(psCLK) != 0)
+                {
+                        printk("Could not enable SGX clock\n");
+                        goto ExitError;
+                }
+
+                psSysSpecData->psSGX_FCK = psCLK; 
+
+                psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
+        }
+/*        else
+        {
+
+                bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+                if (bPowerLock)
+                {
+                        PowerLockUnwrap(psSysSpecData);
+                }
+        }
+
+*/
+
+/*		
+                psCLK = clk_get(NULL, SGX_PARENT_CLOCK);
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get Core Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psCORE_CK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_fck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_FCK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_ick");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get SGX Interface Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_ICK = psCLK;
+
+#if defined(DEBUG)
+		psCLK = clk_get(NULL, "mpu_ck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get MPU Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psMPU_CK = psCLK;
+#endif
+		res = clk_set_parent(psSysSpecData->psSGX_FCK, psSysSpecData->psCORE_CK);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set SGX parent clock (%d)", res));
+			goto ExitError;
+		}
+
+		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
+	}
+*/
+#if defined(DEBUG) || defined(TIMING)
+        psCLK = clk_get(NULL, "gpt7_fck");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_FCK = psCLK;
+
+        psCLK = clk_get(NULL, "gpt7_ick");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_ICK = psCLK;
+/*
+	sys_ck = clk_get(NULL, "sys_ck");
+	if (IS_ERR(sys_ck))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get System clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
+	{
+		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
+		res = clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set GPTIMER11 parent clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+		}
+	}
+*/
+	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
+	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
+
+	res = clk_enable(psSysSpecData->psGPT11_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	res = clk_enable(psSysSpecData->psGPT11_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
+		goto ExitDisableGPT11FCK;
+	}
+
+	
+	TimerRegPhysBase.uiAddr = SYS_TI335x_GP7TIMER_TSICR_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	rate = *pui32TimerEnable;
+	if(!(rate & 4))
+	{
+		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
+
+		
+		*pui32TimerEnable = rate | 4;
+	}
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+	
+	TimerRegPhysBase.uiAddr = SYS_TI335x_GP7TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	
+	*pui32TimerEnable = 3;
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+#endif 
+
+	eError = PVRSRV_OK;
+	goto Exit;
+
+#if defined(DEBUG) || defined(TIMING)
+ExitDisableGPT11ICK:
+	clk_disable(psSysSpecData->psGPT11_ICK);
+ExitDisableGPT11FCK:
+	clk_disable(psSysSpecData->psGPT11_FCK);
+ExitUnRegisterConstraintNotifications:
+#endif	
+ExitError:
+	eError = PVRSRV_ERROR_DISABLE_CLOCK_FAILURE;
+Exit:
+	return eError;
+}
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
+{
+#if defined(DEBUG) || defined(TIMING)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	IMG_CPU_PHYADDR TimerRegPhysBase;
+	IMG_HANDLE hTimerDisable;
+	IMG_UINT32 *pui32TimerDisable;
+#endif	
+
+	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+
+	
+	DisableSGXClocks(psSysData);
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	TimerRegPhysBase.uiAddr = SYS_TI335x_GP7TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				&hTimerDisable);
+
+	if (pui32TimerDisable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
+	}
+	else
+	{
+		*pui32TimerDisable = 0;
+
+		OSUnMapPhysToLin(pui32TimerDisable,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				hTimerDisable);
+	}
+
+	clk_disable(psSysSpecData->psGPT11_ICK);
+
+	clk_disable(psSysSpecData->psGPT11_FCK);
+
+#endif 
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux_wqueue_compat.c b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux_wqueue_compat.c
index 248da05..9fe7dfe0 100644
--- a/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux_wqueue_compat.c
+++ b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux_wqueue_compat.c
@@ -163,8 +163,10 @@ PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
 {
 #if !defined(NO_HARDWARE)
 	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+/*
 	long lNewRate;
 	long lRate;
+*/
 	IMG_INT res;
 
 	
@@ -269,11 +271,12 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 {
 	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
 	struct clk *psCLK;
-	IMG_INT res;
-        IMG_BOOL bPowerLock;
+//	IMG_INT res;
+//      IMG_BOOL bPowerLock;
 	PVRSRV_ERROR eError;
 
 #if defined(DEBUG) || defined(TIMING)
+        IMG_INT res;
 	IMG_INT rate;
 	struct clk *sys_ck;
 	IMG_CPU_PHYADDR     TimerRegPhysBase;
diff --git a/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux_wqueue_compat_orig.c b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux_wqueue_compat_orig.c
deleted file mode 100644
index f94ec0e..0000000
--- a/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux_wqueue_compat_orig.c
+++ /dev/null
@@ -1,472 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#include <linux/version.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/hardirq.h>
-#include <linux/mutex.h>
-
-#include "sgxdefs.h"
-#include "services_headers.h"
-#include "sysinfo.h"
-#include "sgxapi_km.h"
-#include "sysconfig.h"
-#include "sgxinfokm.h"
-#include "syslocal.h"
-
-#if !defined(PVR_LINUX_USING_WORKQUEUES)
-#error "PVR_LINUX_USING_WORKQUEUES must be defined"
-#endif
-
-#define	ONE_MHZ	1000000
-#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
-
-#if defined(SUPPORT_OMAP3430_SGXFCLK_96M)
-#define SGX_PARENT_CLOCK "cm_96m_fck"
-#else
-#define SGX_PARENT_CLOCK "core_ck"
-#endif
-
-static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	if (!in_interrupt())
-	{
-		mutex_lock(&psSysSpecData->sPowerLock);
-
-	}
-}
-
-static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	if (!in_interrupt())
-	{
-		mutex_unlock(&psSysSpecData->sPowerLock);
-	}
-}
-
-PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
-	PowerLockWrap(psSysSpecData);
-
-	return PVRSRV_OK;
-}
-
-IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
-	PowerLockUnwrap(psSysSpecData);
-}
-
-IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	return IMG_TRUE;
-}
-
-IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-}
-
-static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
-{
-	if (rate1 >= rate2)
-	{
-		return val * (rate1 / rate2);
-	}
-
-	return val / (rate2 / rate1);
-}
-
-static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
-{
-	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
-}
-
-static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
-{
-	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
-}
-
-IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
-{
-	IMG_UINT32 rate;
-
-#if defined(NO_HARDWARE)
-	rate = SYS_SGX_CLOCK_SPEED;
-#else
-	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
-
-	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
-	PVR_ASSERT(rate != 0);
-#endif
-	psTimingInfo->ui32CoreClockSpeed = rate;
-	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
-	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	psTimingInfo->bEnableActivePM = IMG_TRUE;
-#else
-	psTimingInfo->bEnableActivePM = IMG_FALSE;
-#endif 
-	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
-}
-
-PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
-{
-#if !defined(NO_HARDWARE)
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-	long lNewRate;
-	long lRate;
-	IMG_INT res;
-
-	
-	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
-	{
-		return PVRSRV_OK;
-	}
-
-	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
-
-#if defined(DEBUG)
-	{
-
-		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psMPU_CK);
-		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
-	}
-#endif
-
-	res = clk_enable(psSysSpecData->psSGX_FCK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
-		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
-	}
-
-	res = clk_enable(psSysSpecData->psSGX_ICK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX interface clock (%d)", res));
-
-		clk_disable(psSysSpecData->psSGX_FCK);
-		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
-	}
-
-	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
-	if (lNewRate <= 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
-		return PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE;
-	}
-
-	
-	lRate = clk_get_rate(psSysSpecData->psSGX_FCK);
-	if (lRate != lNewRate)
-	{
-		res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
-		if (res < 0)
-		{
-			PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: Couldn't set SGX functional clock rate (%d)", res));
-		}
-	}
-
-#if defined(DEBUG)
-	{
-		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
-		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
-	}
-#endif
-
-	
-	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
-
-#else	
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#endif	
-	return PVRSRV_OK;
-}
-
-
-IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
-{
-#if !defined(NO_HARDWARE)
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
-	
-	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
-	{
-		return;
-	}
-
-	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
-
-	if (psSysSpecData->psSGX_ICK)
-	{
-		clk_disable(psSysSpecData->psSGX_ICK);
-	}
-
-	if (psSysSpecData->psSGX_FCK)
-	{
-		clk_disable(psSysSpecData->psSGX_FCK);
-	}
-
-	
-	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
-
-#else	
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#endif	
-}
-
-PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-	struct clk *psCLK;
-	IMG_INT res;
-	PVRSRV_ERROR eError;
-
-#if defined(DEBUG) || defined(TIMING)
-	IMG_INT rate;
-	struct clk *sys_ck;
-	IMG_CPU_PHYADDR     TimerRegPhysBase;
-	IMG_HANDLE hTimerEnable;
-	IMG_UINT32 *pui32TimerEnable;
-
-#endif	
-
-	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
-
-	if (!psSysSpecData->bSysClocksOneTimeInit)
-	{
-		mutex_init(&psSysSpecData->sPowerLock);
-
-		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
-
-		psCLK = clk_get(NULL, SGX_PARENT_CLOCK);
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get Core Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psCORE_CK = psCLK;
-
-		psCLK = clk_get(NULL, "sgx_fck");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psSGX_FCK = psCLK;
-
-		psCLK = clk_get(NULL, "sgx_ick");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get SGX Interface Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psSGX_ICK = psCLK;
-
-#if defined(DEBUG)
-		psCLK = clk_get(NULL, "mpu_ck");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get MPU Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psMPU_CK = psCLK;
-#endif
-		res = clk_set_parent(psSysSpecData->psSGX_FCK, psSysSpecData->psCORE_CK);
-		if (res < 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set SGX parent clock (%d)", res));
-			goto ExitError;
-		}
-
-		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
-	}
-
-#if defined(DEBUG) || defined(TIMING)
-	
-	psCLK = clk_get(NULL, "gpt11_fck");
-	if (IS_ERR(psCLK))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-	psSysSpecData->psGPT11_FCK = psCLK;
-
-	psCLK = clk_get(NULL, "gpt11_ick");
-	if (IS_ERR(psCLK))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-	psSysSpecData->psGPT11_ICK = psCLK;
-
-	sys_ck = clk_get(NULL, "sys_ck");
-	if (IS_ERR(sys_ck))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get System clock"));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-
-	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
-	{
-		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
-		res = clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck);
-		if (res < 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set GPTIMER11 parent clock (%d)", res));
-		goto ExitUnRegisterConstraintNotifications;
-		}
-	}
-
-	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
-	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
-
-	res = clk_enable(psSysSpecData->psGPT11_FCK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-
-	res = clk_enable(psSysSpecData->psGPT11_ICK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
-		goto ExitDisableGPT11FCK;
-	}
-
-	
-	TimerRegPhysBase.uiAddr = SYS_TI81xx_GP7TIMER_TSICR_SYS_PHYS_BASE;
-	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
-                  4,
-                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-                  &hTimerEnable);
-
-	if (pui32TimerEnable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
-		goto ExitDisableGPT11ICK;
-	}
-
-	rate = *pui32TimerEnable;
-	if(!(rate & 4))
-	{
-		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
-
-		
-		*pui32TimerEnable = rate | 4;
-	}
-
-	OSUnMapPhysToLin(pui32TimerEnable,
-		    4,
-		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-		    hTimerEnable);
-
-	
-	TimerRegPhysBase.uiAddr = SYS_TI81xx_GP7TIMER_ENABLE_SYS_PHYS_BASE;
-	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
-                  4,
-                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-                  &hTimerEnable);
-
-	if (pui32TimerEnable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
-		goto ExitDisableGPT11ICK;
-	}
-
-	
-	*pui32TimerEnable = 3;
-
-	OSUnMapPhysToLin(pui32TimerEnable,
-		    4,
-		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-		    hTimerEnable);
-
-#endif 
-
-	eError = PVRSRV_OK;
-	goto Exit;
-
-#if defined(DEBUG) || defined(TIMING)
-ExitDisableGPT11ICK:
-	clk_disable(psSysSpecData->psGPT11_ICK);
-ExitDisableGPT11FCK:
-	clk_disable(psSysSpecData->psGPT11_FCK);
-ExitUnRegisterConstraintNotifications:
-#endif	
-ExitError:
-	eError = PVRSRV_ERROR_DISABLE_CLOCK_FAILURE;
-Exit:
-	return eError;
-}
-
-IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
-{
-#if defined(DEBUG) || defined(TIMING)
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-	IMG_CPU_PHYADDR TimerRegPhysBase;
-	IMG_HANDLE hTimerDisable;
-	IMG_UINT32 *pui32TimerDisable;
-#endif	
-
-	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
-
-	
-	DisableSGXClocks(psSysData);
-
-#if defined(DEBUG) || defined(TIMING)
-	
-	TimerRegPhysBase.uiAddr = SYS_TI81xx_GP7TIMER_ENABLE_SYS_PHYS_BASE;
-	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
-				4,
-				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-				&hTimerDisable);
-
-	if (pui32TimerDisable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
-	}
-	else
-	{
-		*pui32TimerDisable = 0;
-
-		OSUnMapPhysToLin(pui32TimerDisable,
-				4,
-				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-				hTimerDisable);
-	}
-
-	clk_disable(psSysSpecData->psGPT11_ICK);
-
-	clk_disable(psSysSpecData->psGPT11_FCK);
-
-#endif 
-}
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/hostfunc.c b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/hostfunc.c
index ecd1160..1560067 100644
--- a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/hostfunc.c
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/hostfunc.c
@@ -29,6 +29,7 @@
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/kernel.h>
+#include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/string.h>
 #include <asm/page.h>
@@ -54,7 +55,7 @@
 #include "hostfunc.h"
 #include "dbgdriv.h"
 
-#if defined(DEBUG) && !defined(SUPPORT_DRI_DRM)
+#if defined(MODULE) && defined(DEBUG) && !defined(SUPPORT_DRI_DRM)
 IMG_UINT32	gPVRDebugLevel = (DBGPRIV_FATAL | DBGPRIV_ERROR | DBGPRIV_WARNING);
 
 #define PVR_STRING_TERMINATOR		'\0'
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/main.c b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/main.c
index 965c352..d4fe778 100644
--- a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/main.c
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/main.c
@@ -116,7 +116,7 @@ IMG_VOID DBGDrvGetServiceTable(IMG_VOID **fn_table)
 #if defined(SUPPORT_DRI_DRM)
 void dbgdrv_cleanup(void)
 #else
-void cleanup_module(void)
+static void __exit dbgdrv_cleanup(void)
 #endif
 {
 #if !defined(SUPPORT_DRI_DRM)
@@ -136,7 +136,7 @@ void cleanup_module(void)
 #if defined(SUPPORT_DRI_DRM)
 IMG_INT dbgdrv_init(void)
 #else
-int init_module(void)
+static int __init dbgdrv_init(void)
 #endif
 {
 #if (defined(LDM_PLATFORM) || defined(LDM_PCI)) && !defined(SUPPORT_DRI_DRM)
@@ -309,3 +309,8 @@ IMG_VOID DefineHotKey (IMG_UINT32 ui32ScanCode, IMG_UINT32 ui32ShiftState, PHOTK
 }
 
 EXPORT_SYMBOL(DBGDrvGetServiceTable);
+
+#if !defined(SUPPORT_DRI_DRM)
+subsys_initcall(dbgdrv_init);
+module_exit(dbgdrv_cleanup);
+#endif
-- 
1.7.4.1

